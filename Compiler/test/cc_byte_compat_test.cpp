#include <iostream>  
#include <fstream>
#include <string>
#include <map>

#include "script/cc_options.h"
#include "gtest/gtest.h"
#include "script/cs_parser.h"
#include "script/cc_symboltable.h"
#include "script/cc_internallist.h"


/* This file is for Bytecode compatibility tests ONLY, i.e. for testing that
   the rewritten parser emits exactly the same Bytecode as the original
   one. Testing for programs that won't compile should be done elsewhere IMHO.
   Reason: Later on, when we trust the rewritten compiler, we'll want
   to extend it in such a way that it emits _different_ codes from the
   original compiler. Then we can simply throw away those tests in this
   file that no longer work.

   1. Head over to a release version that has the old compiler.
   2. Copy a template (search for "PROTOTYPE") to the end of the file.
   3. Change test name and file name in the prototype.
   4. Add in an AGS program that will be tested.
   5. Uncomment the "WriteOutput(" line of the test, run the test.
      The parser should not emit an error (do these tests elsewhere).
   6. A file has now been written. Copy its content immediately above
      the closing brace of the test. This will copy the code that
      is generated by the old compiler, byte-for-byte, into the googletest.
   7. Comment out the "WriteOutput(" line again (important).
   8. Copy the test to the clipboard.
   9. Head over to the version that has the rewritten compiler.
   10. Paste the test from the clipboard to the testfile of this version.
   11. Run the test.
       If the parser emits an error, the test will fail.
       If the parser emits Bytecode that is different in any way,
       the test will point out the first code that is different and fail.

   If a test generates wrong code, often a good way to debug it is as follows:
   - Uncomment the "WriteOutput(" line and run the test; now you have the bytes
     that the _new_ compiler emits in the file. Compare it by hand to the code
     that's in the test. See what the problem is: Has the new compiler left
     opcodes out, or has it added some in? Has it changed a single value somewhere?
   - Find the line with "iii" in cs_compiledscript.cpp and put a breakpoint there.
     (Uncomment that piece of code if it is commented out.)
   - Modify that piece of code so that the debugger will break as soon as the
     compiler generates the last byte that is still correct.
   - Debug test:
     Trace along from the breakpoint and find the point where the logic fails.

   But bear in mind:
   - Sometimes the compiler emits some code, then rips it out and stashes it away,
     then, later on, retrieves it and emits it again.
   - Sometimes the compiler emits some code value (usually 0), then
     patches it afterwards.
   In both cases, the logic will _not_ pass through function write_cmd()
   when the code is touched the second time! These are the hard cases to debug. :)
*/


// NOTE! If any "WriteOutput" lines in this file are uncommented, then the 
//  #define below _must_ be changed to a local writable temp dir. 
// (If you only want to run the tests to see if any tests fail, you do NOT 
// need that dir and you do NOT need any local files whatsoever.)
# define LOCAL_PATH "C:\\TEMP\\"

extern void clear_error();
extern const char *last_seen_cc_error();
extern ccCompiledScript *newScriptFixture();

std::string Esc(const char ch)
{
    static const char *tohex = "0123456789abcdef";

    if (ch >= ' ' && ch <= 126)
    {
        return std::string(1, ch);
    }

    switch (ch)
    {
    default:
    {
        std::string ret = "\\x";
        ret.push_back(tohex[ch / 16]);
        ret.push_back(tohex[ch % 16]);
        return ret;
    }
    case '\a': return "\\a";
    case '\b': return "\\b";
    case '\f': return "\\f";
    case '\n': return "\\n";
    case '\r': return "\\r";
    case '\v': return "\\v";
    case '\'': return "\\\'";
    case '\"': return "\\\"";
    case '\\': return "\\\\";
    }
}

std::string EscapeString(const char *in)
{
    if (in == nullptr)
        return "0";

    std::string ret = "";
    size_t const in_len = strlen(in);
    for (size_t idx = 0; idx < in_len; idx++)
        ret += Esc(in[idx]);
    return "\"" + ret + "\"";
}

void WriteOutputCode(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t codesize = " << scrip->codesize << ";" << std::endl;
    of << "EXPECT_EQ(codesize, scrip->codesize);" << std::endl << std::endl;

    if (scrip->codesize == 0)
        return;

    of << "intptr_t code[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->codesize; idx++)
    {
        of.width(4);
        of << scrip->code[idx] << ", ";
        if (idx % 8 == 3) of << "        ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " -999 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < codesize; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->codesize) break;" << std::endl;
    of << "     std::string prefix = \"code[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + std::to_string(code[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->code[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;

}

void WriteOutputFixups(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t numfixups = " << scrip->numfixups << ";" << std::endl;
    of << "EXPECT_EQ(numfixups, scrip->numfixups);" << std::endl << std::endl;

    if (scrip->numfixups == 0)
        return;

    of << "intptr_t fixups[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->numfixups; idx++)
    {
        of.width(4);
        of << scrip->fixups[idx] << ", ";
        if (idx % 8 == 3) of << "      ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " -999 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numfixups; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numfixups) break;" << std::endl;
    of << "     std::string prefix = \"fixups[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string   is_val = prefix + std::to_string(fixups[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->fixups[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;

    of << "char fixuptypes[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->numfixups; idx++)
    {
        of.width(3);
        of << static_cast<int>(scrip->fixuptypes[idx]) << ", ";
        if (idx % 8 == 3) of << "   ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " '\\0' " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numfixups; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numfixups) break;" << std::endl;
    of << "     std::string prefix = \"fixuptypes[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string   is_val = prefix + std::to_string(fixuptypes[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputImports(std::ofstream &of, ccCompiledScript *scrip)
{
    // Unfortunately, imports can contain empty strings that
    // mustn't be counted. So we can't just believe numimports,
    // and we can't check against scrip->numimports.
    size_t realNumImports = 0;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
        if (0 != strcmp(scrip->imports[idx], ""))
            ++realNumImports;

    of << "const int numimports = " << realNumImports << ";" << std::endl;

    of << "std::string imports[] = {" << std::endl;

    size_t linelen = 0;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;

        std::string item = EscapeString(scrip->imports[idx]);
        item += ",";
        item += std::string(15 - (item.length() % 15), ' ');
        of << item;
        linelen += item.length();
        if (linelen >= 75)
        {
            linelen = 0;
            of << "// " << idx << std::endl;
        }
    }
    of << " \"[[SENTINEL]]\" " << std::endl << "};" << std::endl << std::endl;

    of << "int idx2 = -1;" << std::endl;
    of << "for (size_t idx = 0; idx < scrip->numimports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (!strcmp(scrip->imports[idx], \"\"))" << std::endl;
    of << "         continue;" << std::endl;
    of << "     idx2++;" << std::endl;
    of << "     ASSERT_LT(idx2, numimports);" << std::endl;
    of << "     std::string prefix = \"imports[\";" << std::endl;
    // Note that the prefix has to be identical for is_val and test_val,
    // or ASSERT_EQ will always fail.
    of << "     prefix += std::to_string(idx2) + \"] == \";" << std::endl;
    of << "     std::string is_val   = prefix + scrip->imports[idx];" << std::endl;
    of << "     std::string test_val = prefix + imports[idx2];" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputExports(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t numexports = " << scrip->numexports << ";" << std::endl;
    of << "EXPECT_EQ(numexports, scrip->numexports);" << std::endl << std::endl;

    if (scrip->numexports == 0)
        return;

    of << "std::string exports[] = {" << std::endl;

    size_t linelen = 0;
    for (size_t idx = 0; idx < scrip->numexports; idx++)
    {
        std::string item = EscapeString(scrip->exports[idx]);
        item += ",";
        item += std::string(6 - (item.length() % 6), ' ');
        of << item;
        linelen += item.length();
        if (linelen >= 50)
        {
            linelen = 0;
            of << "// " << idx << std::endl;
        }
    }
    of << " \"[[SENTINEL]]\" " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numexports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numexports) break;" << std::endl;
    of << "     std::string prefix = \"exports[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + exports[idx];" << std::endl;
    of << "     std::string test_val = prefix + scrip->exports[idx];" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;


    of << "int32_t export_addr[] = {" << std::endl;

    for (size_t idx = 0; idx < scrip->numexports; idx++)
    {
        of.setf(std::ios::hex, std::ios::basefield);
        of.setf(std::ios::showbase);
        of.width(4);
        of << scrip->export_addr[idx] << ", ";
        if (idx % 4 == 1) of << "   ";
        if (idx % 8 == 3)
        {
            of.setf(std::ios::dec, std::ios::basefield);
            of.unsetf(std::ios::showbase);
            of.width(0);
            of << "// " << idx;
            of << std::endl;
        }
    }

    of.setf(std::ios::dec, std::ios::basefield);
    of.unsetf(std::ios::showbase);
    of.width(0);

    of << " 0 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numexports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numexports) break;" << std::endl;
    of << "     std::string prefix = \"export_addr[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val   = prefix + std::to_string(export_addr[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->export_addr[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputStrings(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t stringssize = " << scrip->stringssize << ";" << std::endl;
    of << "EXPECT_EQ(stringssize, scrip->stringssize);" << std::endl << std::endl;

    if (scrip->stringssize == 0)
        return;

    of << "char strings[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->stringssize; idx++)
    {
        std::string out = "";
        if (scrip->strings[idx] == 0)
            out = "  0";
        else
            out += '\'' + Esc(scrip->strings[idx]) + '\'';
        of << out << ",  ";
        if (idx % 8 == 3) of << "        ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << "'\\0'" << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < stringssize; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->stringssize) break;" << std::endl;
    of << "     std::string prefix = \"strings[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + std::to_string(strings[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->strings[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl;

}

void WriteOutput(char *fname, ccCompiledScript *scrip)
{
    std::string path = LOCAL_PATH;
    std::ofstream of;
    of.open(path.append(fname).append(".txt"));

    WriteOutputCode(of, scrip);
    WriteOutputFixups(of, scrip);
    WriteOutputImports(of, scrip);
    WriteOutputExports(of, scrip);
    WriteOutputStrings(of, scrip);

    of.close();
}

void WriteReducedOutput(char *fname, ccCompiledScript *scrip)
{
    std::string path = LOCAL_PATH;
    std::ofstream of;
    of.open(path.append(fname).append(".txt"));

    WriteOutputCode(of, scrip);
    WriteOutputFixups(of, scrip);
    
    of.close();
}

/*    PROTOTYPE

TEST(Compatibility, P_r_o_t_o_t_y_p_e) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo(int a)      \n\
        {                   \n\
            return a*a;     \n\
        }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("P_r_o_t_o_t_y_p_e", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

}
*/

TEST(Compatibility, SimpleVoidFunction) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void Foo()          \n\
        {                   \n\
            return;         \n\
        }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("SimpleVoidFunction", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 10;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    5,    6,    3,    // 7
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, SimpleIntFunction) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo()      \n\
    {                  \n\
        return 15;     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("SimpleIntFunction", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 10;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,    5,    6,    3,    // 7
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IntFunctionLocalV) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo()      \n\
    {                  \n\
        int a = 15;    \n\
        return a;     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IntFunctionLocalV", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 28;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   51,    4,    7,    // 15
       3,    2,    1,    4,            5,    6,    3,    0,    // 23
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IntFunctionParam) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo(int a) \n\
    {                  \n\
        return a;      \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IntFunctionParam", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 11;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,    5,    6,    // 7
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IntFunctionGlobalV) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int a = 15;    \n\
        int Foo( )     \n\
    {                  \n\
        return a;      \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IntFunctionGlobalV", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 12;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    2,            0,    7,    3,    5,    // 7
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, FloatExpr1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        float a = 15.0;     \n\
        float Foo()     \n\
    {                   \n\
        float f = 3.14; \n\
        return a + f;   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FloatExpr1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 43;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,         1078523331,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    6,    2,    0,    // 15
       7,    3,   29,    3,           51,    8,    7,    3,    // 23
      30,    4,   57,    4,            3,    3,    4,    3,    // 31
       2,    1,    4,    5,            6,    3,    0,    2,    // 39
       1,    4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      15,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, FloatExpr2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        float a = 15.0;           \n\
        float Foo()               \n\
    {                             \n\
        float b = 22.2;           \n\
        int E1 = (3.14 < 1.34) == 1;         \n\
        short E2 = 0 == (1234.5 > 5.0) && 1; \n\
        long E3 = a <= 44.4;      \n\
        char E4 = 55.5 >= 44.4;   \n\
        int E5 = (((a == b) || (a != b))); \n\
        return a - b * (a / b);   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FloatExpr2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 269;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,         1102158234,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    6,    3, 1078523331,    // 15
      29,    3,    6,    3,         1068205343,   30,    4,   60,    // 23
       4,    3,    3,    4,            3,   29,    3,    6,    // 31
       3,    1,   30,    4,           15,    4,    3,    3,    // 39
       4,    3,    3,    1,            2,    8,    3,    1,    // 47
       1,    4,    6,    3,            0,   29,    3,    6,    // 55
       3, 1150963712,   29,    3,            6,    3, 1084227584,   30,    // 63
       4,   59,    4,    3,            3,    4,    3,   30,    // 71
       4,   15,    4,    3,            3,    4,    3,   28,    // 79
      13,   29,    3,    6,            3,    1,   30,    4,    // 87
      21,    4,    3,    3,            4,    3,    3,    1,    // 95
       2,   27,    3,    1,            1,    2,    6,    2,    // 103
       0,    7,    3,   29,            3,    6,    3, 1110546842,    // 111
      30,    4,   62,    4,            3,    3,    4,    3,    // 119
       3,    1,    2,    8,            3,    1,    1,    4,    // 127
       6,    3, 1113456640,   29,            3,    6,    3, 1110546842,    // 135
      30,    4,   61,    4,            3,    3,    4,    3,    // 143
       3,    1,    2,   26,            3,    1,    1,    1,    // 151
       6,    2,    0,    7,            3,   29,    3,   51,    // 159
      19,    7,    3,   30,            4,   15,    4,    3,    // 167
       3,    4,    3,   70,           29,   29,    3,    6,    // 175
       2,    0,    7,    3,           29,    3,   51,   23,    // 183
       7,    3,   30,    4,           16,    4,    3,    3,    // 191
       4,    3,   30,    4,           22,    4,    3,    3,    // 199
       4,    3,    3,    1,            2,    8,    3,    1,    // 207
       1,    4,    6,    2,            0,    7,    3,   29,    // 215
       3,   51,   23,    7,            3,   29,    3,    6,    // 223
       2,    0,    7,    3,           29,    3,   51,   31,    // 231
       7,    3,   30,    4,           56,    4,    3,    3,    // 239
       4,    3,   30,    4,           55,    4,    3,    3,    // 247
       4,    3,   30,    4,           58,    4,    3,    3,    // 255
       4,    3,    2,    1,           19,    5,    6,    3,    // 263
       0,    2,    1,   19,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
     104,  154,  177,  212,        225,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IfThenElse1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo()               \n\
    {                       \n\
        int a = 15 - 4 * 2; \n\
        if (a < 5)          \n\
            a >>= 2;        \n\
        else                \n\
            a <<= 3;        \n\
        return a;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfThenElse1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 111;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,   29,    3,    6,    // 7
       3,    4,   29,    3,            6,    3,    2,   30,    // 15
       4,    9,    4,    3,            3,    4,    3,   30,    // 23
       4,   12,    4,    3,            3,    4,    3,    3,    // 31
       1,    2,    8,    3,            1,    1,    4,   51,    // 39
       4,    7,    3,   29,            3,    6,    3,    5,    // 47
      30,    4,   18,    4,            3,    3,    4,    3,    // 55
      28,   20,    6,    3,            2,   29,    3,   51,    // 63
       8,    7,    3,   30,            4,   44,    3,    4,    // 71
      51,    4,    8,    3,           31,   18,    6,    3,    // 79
       3,   29,    3,   51,            8,    7,    3,   30,    // 87
       4,   43,    3,    4,           51,    4,    8,    3,    // 95
      51,    4,    7,    3,            2,    1,    4,    5,    // 103
       6,    3,    0,    2,            1,    4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, IfThenElse2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo()               \n\
    {                       \n\
        int a = 15 - 4 % 2; \n\
        if (a >= 5) {       \n\
            a -= 2;         \n\
        } else {            \n\
            a += 3;         \n\
        }                   \n\
        return a;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfThenElse2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 111;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,   29,    3,    6,    // 7
       3,    4,   29,    3,            6,    3,    2,   30,    // 15
       4,   40,    4,    3,            3,    4,    3,   30,    // 23
       4,   12,    4,    3,            3,    4,    3,    3,    // 31
       1,    2,    8,    3,            1,    1,    4,   51,    // 39
       4,    7,    3,   29,            3,    6,    3,    5,    // 47
      30,    4,   19,    4,            3,    3,    4,    3,    // 55
      28,   20,    6,    3,            2,   29,    3,   51,    // 63
       8,    7,    3,   30,            4,   12,    3,    4,    // 71
      51,    4,    8,    3,           31,   18,    6,    3,    // 79
       3,   29,    3,   51,            8,    7,    3,   30,    // 87
       4,   11,    3,    4,           51,    4,    8,    3,    // 95
      51,    4,    7,    3,            2,    1,    4,    5,    // 103
       6,    3,    0,    2,            1,    4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);


    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);






}

TEST(Compatibility, While) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    char c = 'x';             \n\
    int Foo(int i, float f)   \n\
    {                         \n\
        int sum = 0;          \n\
        while (c >= 0)        \n\
        {                     \n\
            sum += (500 & c); \n\
            c--;              \n\
            if (c == 1) continue; \n\
        }                     \n\
        return sum;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("While", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 118;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    6,    2,    0,    // 15
      24,    3,   29,    3,            6,    3,    0,   30,    // 23
       4,   19,    4,    3,            3,    4,    3,   28,    // 31
      70,    6,    3,  500,           29,    3,    6,    2,    // 39
       0,   24,    3,   30,            4,   13,    4,    3,    // 47
       3,    4,    3,   29,            3,   51,    8,    7,    // 55
       3,   30,    4,   11,            3,    4,   51,    4,    // 63
       8,    3,    6,    2,            0,   24,    3,    2,    // 71
       3,    1,   26,    3,            6,    2,    0,   24,    // 79
       3,   29,    3,    6,            3,    1,   30,    4,    // 87
      15,    4,    3,    3,            4,    3,   28,    5,    // 95
       6,    3,    0,   31,          -88,   31,  -90,   51,    // 103
       4,    7,    3,    2,            1,    4,    5,    6,    // 111
       3,    0,    2,    1,            4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      15,   40,   68,   78,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}



TEST(Compatibility, DoNCall) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    char c = 'x';             \n\
    int Foo(int i)            \n\
    {                         \n\
        int sum = 0;          \n\
        do                    \n\
        {                     \n\
            sum -= (500 | c); \n\
            c--;              \n\
        }                     \n\
        while (c > 0);        \n\
        return sum;           \n\
    }                         \n\
                              \n\
    int Bar(int x)            \n\
    {                         \n\
        return Foo(x^x);      \n\
    }                         \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("DoNCall", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 130;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   31,    2,   31,    // 15
      63,    6,    3,  500,           29,    3,    6,    2,    // 23
       0,   24,    3,   30,            4,   14,    4,    3,    // 31
       3,    4,    3,   29,            3,   51,    8,    7,    // 39
       3,   30,    4,   12,            3,    4,   51,    4,    // 47
       8,    3,    6,    2,            0,   24,    3,    2,    // 55
       3,    1,   26,    3,            6,    2,    0,   24,    // 63
       3,   29,    3,    6,            3,    0,   30,    4,    // 71
      17,    4,    3,    3,            4,    3,   70,  -63,    // 79
      51,    4,    7,    3,            2,    1,    4,    5,    // 87
       6,    3,    0,    2,            1,    4,    5,   38,    // 95
      95,   51,    8,    7,            3,   29,    3,   51,    // 103
      12,    7,    3,   30,            4,   41,    4,    3,    // 111
       3,    4,    3,   29,            3,    6,    3,    0,    // 119
      23,    3,    2,    1,            4,    5,    6,    3,    // 127
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      24,   52,   62,  119,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   2,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);


}

TEST(Compatibility, Do2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    void noloopcheck main()   \n\
    {                         \n\
        int sum = 0;          \n\
        do                    \n\
            if (sum < 100)    \n\
                sum += 10;    \n\
            else              \n\
                break;        \n\
        while (sum >= -1);    \n\
    }                         \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Do2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 88;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   68,    6,            3,    0,    3,    1,    // 7
       2,    8,    3,    1,            1,    4,   31,    2,    // 15
      31,   63,   51,    4,            7,    3,   29,    3,    // 23
       6,    3,  100,   30,            4,   18,    4,    3,    // 31
       3,    4,    3,   28,           20,    6,    3,   10,    // 39
      29,    3,   51,    8,            7,    3,   30,    4,    // 47
      11,    3,    4,   51,            4,    8,    3,   31,    // 55
       5,    6,    3,    0,           31,  -46,   51,    4,    // 63
       7,    3,   29,    3,            6,    3,   -1,   30,    // 71
       4,   19,    4,    3,            3,    4,    3,   70,    // 79
     -63,    6,    3,    0,            2,    1,    4,    5,    // 87
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, For1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int loop;                       \n\
    int Foo(int i, float f)         \n\
    {                               \n\
        for (loop = 0; loop < 10; loop += 3)  \n\
        {                           \n\
            int sum = loop - 4 - 7; \n\
            if (loop == 6) break;   \n\
        }                           \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 130;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    6,    2,    0,    // 7
       8,    3,    6,    2,            0,    7,    3,   29,    // 15
       3,    6,    3,   10,           30,    4,   18,    4,    // 23
       3,    3,    4,    3,           28,   92,    6,    2,    // 31
       0,    7,    3,   29,            3,    6,    3,    4,    // 39
      30,    4,   12,    4,            3,    3,    4,    3,    // 47
      29,    3,    6,    3,            7,   30,    4,   12,    // 55
       4,    3,    3,    4,            3,    3,    1,    2,    // 63
       8,    3,    1,    1,            4,    6,    2,    0,    // 71
       7,    3,   29,    3,            6,    3,    6,   30,    // 79
       4,   15,    4,    3,            3,    4,    3,   28,    // 87
       8,    2,    1,    4,            6,    3,    0,   31,    // 95
     -69,    2,    1,    4,            6,    3,    3,   29,    // 103
       3,    6,    2,    0,            7,    3,   30,    4,    // 111
      11,    3,    4,    6,            2,    0,    8,    3,    // 119
      31, -112,    6,    3,            0,    5,    6,    3,    // 127
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 6;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   12,   32,   71,        107,  117,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, For2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)         \n\
    {                               \n\
        int lp, sum;                \n\
        for (; ; lp += 1)           \n\
            sum += lp;              \n\
        for ( ;; )                  \n\
            sum -= lp;              \n\
        for (; lp < 2; lp += 3)     \n\
            sum *= lp;              \n\
        for (; lp < 4; )            \n\
            sum /= lp;              \n\
        for (lp = 5; ; lp += 6)     \n\
            sum /= lp;              \n\
        for (int loop = 7; ; )      \n\
            sum &= loop;            \n\
        for (int loop = 8; loop < 9; )  \n\
            sum |= loop;            \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 345;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    3,    1,            2,   63,    4,    1,    // 15
       1,    4,    6,    3,            1,   28,   39,   51,    // 23
       8,    7,    3,   29,            3,   51,    8,    7,    // 31
       3,   30,    4,   11,            3,    4,   51,    4,    // 39
       8,    3,    6,    3,            1,   29,    3,   51,    // 47
      12,    7,    3,   30,            4,   11,    3,    4,    // 55
      51,    8,    8,    3,           31,  -44,    6,    3,    // 63
       1,   28,   21,   51,            8,    7,    3,   29,    // 71
       3,   51,    8,    7,            3,   30,    4,   12,    // 79
       3,    4,   51,    4,            8,    3,   31,  -26,    // 87
      51,    8,    7,    3,           29,    3,    6,    3,    // 95
       2,   30,    4,   18,            4,    3,    3,    4,    // 103
       3,   28,   39,   51,            8,    7,    3,   29,    // 111
       3,   51,    8,    7,            3,   30,    4,    9,    // 119
       3,    4,   51,    4,            8,    3,    6,    3,    // 127
       3,   29,    3,   51,           12,    7,    3,   30,    // 135
       4,   11,    3,    4,           51,    8,    8,    3,    // 143
      31,  -58,   51,    8,            7,    3,   29,    3,    // 151
       6,    3,    4,   30,            4,   18,    4,    3,    // 159
       3,    4,    3,   28,           21,   51,    8,    7,    // 167
       3,   29,    3,   51,            8,    7,    3,   30,    // 175
       4,   10,    3,    4,           51,    4,    8,    3,    // 183
      31,  -40,    6,    3,            5,   51,    8,    8,    // 191
       3,    6,    3,    1,           28,   39,   51,    8,    // 199
       7,    3,   29,    3,           51,    8,    7,    3,    // 207
      30,    4,   10,    3,            4,   51,    4,    8,    // 215
       3,    6,    3,    6,           29,    3,   51,   12,    // 223
       7,    3,   30,    4,           11,    3,    4,   51,    // 231
       8,    8,    3,   31,          -44,    6,    3,    7,    // 239
       3,    1,    2,    8,            3,    1,    1,    4,    // 247
       6,    3,    1,   28,           21,   51,    4,    7,    // 255
       3,   29,    3,   51,           12,    7,    3,   30,    // 263
       4,   13,    3,    4,           51,    8,    8,    3,    // 271
      31,  -26,    2,    1,            4,    6,    3,    8,    // 279
       3,    1,    2,    8,            3,    1,    1,    4,    // 287
      51,    4,    7,    3,           29,    3,    6,    3,    // 295
       9,   30,    4,   18,            4,    3,    3,    4,    // 303
       3,   28,   21,   51,            4,    7,    3,   29,    // 311
       3,   51,   12,    7,            3,   30,    4,   14,    // 319
       3,    4,   51,    8,            8,    3,   31,  -40,    // 327
       2,    1,    4,    6,            3,    0,    2,    1,    // 335
       8,    5,    6,    3,            0,    2,    1,    8,    // 343
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, For3) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct           \n\
    {                               \n\
        float Payload[1];           \n\
    };                              \n\
    Struct *S;                      \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        for (Struct *loop; ;)       \n\
        {                           \n\
            return ((loop == S));   \n\
        }                           \n\
        return -7;                  \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For3", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 65;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    6,    3,            1,   28,   36,   51,    // 15
       4,   29,    2,   30,            2,   48,    3,   29,    // 23
       3,    6,    2,    0,           29,    2,   30,    2,    // 31
      48,    3,   30,    4,           15,    4,    3,    3,    // 39
       4,    3,   51,    4,           69,    2,    1,    4,    // 47
       5,   31,  -41,   51,            4,   49,    2,    1,    // 55
       4,    6,    3,   -7,            5,    6,    3,    0,    // 63
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      27,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, For4) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    void main()                     \n\
    {                               \n\
        for (int loop = 0; loop < 10; loop++)  \n\
            if (loop == 5)          \n\
                continue;           \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For4", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 83;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   51,    4,    7,    // 15
       3,   29,    3,    6,            3,   10,   30,    4,    // 23
      18,    4,    3,    3,            4,    3,   28,   44,    // 31
      51,    4,    7,    3,           29,    3,    6,    3,    // 39
       5,   30,    4,   15,            4,    3,    3,    4,    // 47
       3,   28,   14,   51,            4,    7,    3,    1,    // 55
       3,    1,    8,    3,            6,    3,    0,   31,    // 63
     -52,   51,    4,    7,            3,    1,    3,    1,    // 71
       8,    3,   31,  -63,            2,    1,    4,    6,    // 79
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, IfDoWhile) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)                      \n\
    {                                            \n\
        int five = 5, sum, loop = -2;            \n\
        if (five < 10)                           \n\
            for (loop = 0; loop < 10; loop += 3) \n\
            {                                    \n\
                sum += loop;                     \n\
                if (loop == 6) return loop;      \n\
            }                                    \n\
        else                                     \n\
            do { loop += 1; } while (loop < 100);   \n\
        return 0;                                \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfDoWhile", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 200;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    3,    1,    2,    // 15
      63,    4,    1,    1,            4,    6,    3,   -2,    // 23
       3,    1,    2,    8,            3,    1,    1,    4,    // 31
      51,   12,    7,    3,           29,    3,    6,    3,    // 39
      10,   30,    4,   18,            4,    3,    3,    4,    // 47
       3,   28,   94,    6,            3,    0,   51,    4,    // 55
       8,    3,   51,    4,            7,    3,   29,    3,    // 63
       6,    3,   10,   30,            4,   18,    4,    3,    // 71
       3,    4,    3,   28,           66,   51,    4,    7,    // 79
       3,   29,    3,   51,           12,    7,    3,   30,    // 87
       4,   11,    3,    4,           51,    8,    8,    3,    // 95
      51,    4,    7,    3,           29,    3,    6,    3,    // 103
       6,   30,    4,   15,            4,    3,    3,    4,    // 111
       3,   28,    8,   51,            4,    7,    3,    2,    // 119
       1,   12,    5,    6,            3,    3,   29,    3,    // 127
      51,    8,    7,    3,           30,    4,   11,    3,    // 135
       4,   51,    4,    8,            3,   31,  -85,   31,    // 143
      41,   31,    2,   31,           37,    6,    3,    1,    // 151
      29,    3,   51,    8,            7,    3,   30,    4,    // 159
      11,    3,    4,   51,            4,    8,    3,   51,    // 167
       4,    7,    3,   29,            3,    6,    3,  100,    // 175
      30,    4,   18,    4,            3,    3,    4,    3,    // 183
      70,  -37,    6,    3,            0,    2,    1,   12,    // 191
       5,    6,    3,    0,            2,    1,   12,    5,    // 199
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Switch) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)         \n\
    {                               \n\
        switch (i * i)              \n\
        {                           \n\
        case 2: return 10; break;   \n\
        default: i *= 2; return i;  \n\
        case 3:                     \n\
        case 4: i = 0;              \n\
        case 5: i += 5 - i - 4;  break; \n\
        }                           \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Switch", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 174;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   12,    7,    3,           30,    4,    9,    4,    // 15
       3,    3,    4,    3,            3,    3,    4,   31,    // 23
      91,   31,  139,    6,            3,   10,    5,    6,    // 31
       3,    0,   31,  -11,            6,    3,    2,   29,    // 39
       3,   51,   12,    7,            3,   30,    4,    9,    // 47
       3,    4,   51,    8,            8,    3,   51,    8,    // 55
       7,    3,    5,    6,            3,    0,   51,    8,    // 63
       8,    3,    6,    3,            5,   29,    3,   51,    // 71
      12,    7,    3,   30,            4,   12,    4,    3,    // 79
       3,    4,    3,   29,            3,    6,    3,    4,    // 87
      30,    4,   12,    4,            3,    3,    4,    3,    // 95
      29,    3,   51,   12,            7,    3,   30,    4,    // 103
      11,    3,    4,   51,            8,    8,    3,    6,    // 111
       3,    0,   31,   50,           29,    4,    6,    3,    // 119
       2,   30,    4,   16,            3,    4,   28, -101,    // 127
      29,    4,    6,    3,            3,   30,    4,   16,    // 135
       3,    4,   28,  -81,           29,    4,    6,    3,    // 143
       4,   30,    4,   16,            3,    4,   28,  -93,    // 151
      29,    4,    6,    3,            5,   30,    4,   16,    // 159
       3,    4,   28,  -98,           31, -130,    6,    3,    // 167
       0,    5,    6,    3,            0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, FreeLocalPtr) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct S                  \n\
    {                                 \n\
        int i;                        \n\
    };                                \n\
                                      \n\
    int foo()                         \n\
    {                                 \n\
        S *sptr = new S;              \n\
                                      \n\
        for (int i = 0; i < 10; i++)  \n\
            sptr = new S;             \n\
    }                                 \n\
    ";
    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FreeLocalPtr", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 78;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   73,    3,            4,    3,    1,    2,    // 7
      50,    3,    1,    1,            4,    6,    3,    0,    // 15
       3,    1,    2,    8,            3,    1,    1,    4,    // 23
      51,    4,    7,    3,           29,    3,    6,    3,    // 31
      10,   30,    4,   18,            4,    3,    3,    4,    // 39
       3,   28,   22,   73,            3,    4,   51,    8,    // 47
      29,    2,   30,    2,           47,    3,   51,    4,    // 55
       7,    3,    1,    3,            1,    8,    3,   31,    // 63
     -41,    2,    1,    4,            6,    3,    0,   51,    // 71
       4,   69,    2,    1,            4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Strings1) {

    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        string GLOBAL; \
\
        string MyFunction(int a)\
        {\
            string x;\
            return GLOBAL;\
        }\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Strings1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 32;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            5,    1,    1,  200,    // 7
       3,    1,    2,    8,            5,    1,    1,    4,    // 15
       6,    2,  200,    7,            3,    2,    1,  204,    // 23
       5,    6,    3,    0,            2,    1,  204,    5,    // 31
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
     200,   18,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      5,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Strings2) {

    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void sub(const string s) \n\
        {                       \n\
            return;             \n\
        }                       \n\
                                \n\
        void main()             \n\
        {                       \n\
            sub(\"Foo\");       \n\
        }                       \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Strings2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 29;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    5,    6,    3,    // 7
       0,    5,   38,   10,            6,    3,    0,   29,    // 15
       3,    6,    3,    0,           23,    3,    2,    1,    // 23
       4,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      14,   19,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      3,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 4;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'F',  'o',  'o',    0,          '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }

}

TEST(Compatibility, Struct1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct               \n\
    {                               \n\
        float Float;                \n\
        import int[] Func(int i);   \n\
    };                              \n\
                                    \n\
    int Ret[];                      \n\
                                    \n\
    int[] Struct::Func(int i)       \n\
    {                               \n\
        this.Float = 0.0;           \n\
        Ret = new int[5];           \n\
        return Ret;                 \n\
    }                               \n\
                                    \n\
    void main()                     \n\
    {                               \n\
        Struct S;                   \n\
        S.Func(-1);                 \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 90;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,    6,            3,    0,   29,    6,    // 15
      30,    2,   52,    8,            3,    6,    3,    5,    // 23
      72,    3,    4,    0,            6,    2,    0,   47,    // 31
       3,    6,    2,    0,           48,    3,    2,    1,    // 39
       4,    5,    6,    3,            0,    2,    1,    4,    // 47
       5,   38,   49,    3,            1,    2,   63,    4,    // 55
       1,    1,    4,   29,            6,    6,    3,   -1,    // 63
      29,    3,   51,   12,            3,    2,    3,   45,    // 71
       3,    6,    3,    0,           23,    3,    2,    1,    // 79
       4,   30,    6,    6,            3,    0,    2,    1,    // 87
       4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      30,   35,   75,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Struct2) {
    ccCompiledScript *scrip = newScriptFixture();

    // test arrays; arrays in structs;
    // whether the namespace in structs is independent of the global namespace

    char *inpl = "\
    struct Struct1                  \n\
    {                               \n\
        int Array[17], Ix;          \n\
    };                              \n\
                                    \n\
    Struct1 S;                      \n\
    int Array[5];                   \n\
                                    \n\
    void main()                     \n\
    {                               \n\
        S.Ix = 5;                   \n\
        Array[2] = 3;               \n\
        S.Array[Array[2]] = 42;     \n\
        S.Array[S.Ix] = 19;         \n\
        return;                     \n\
    }";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 118;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    6,    2,   68,    // 7
       8,    3,    6,    3,            3,   29,    3,    6,    // 15
       3,    2,   46,    3,            5,   32,    3,    4,    // 23
       3,    3,    5,   30,            3,    6,    2,   72,    // 31
      11,    2,    5,    8,            3,    6,    3,   42,    // 39
      29,    3,    6,    3,            2,   46,    3,    5,    // 47
      32,    3,    4,    3,            3,    5,    6,    2,    // 55
      72,   11,    2,    5,            7,    3,   46,    3,    // 63
      17,   32,    3,    4,            3,    3,    5,   30,    // 71
       3,    6,    2,    0,           11,    2,    5,    8,    // 79
       3,    6,    3,   19,           29,    3,    6,    2,    // 87
      68,    7,    3,   46,            3,   17,   32,    3,    // 95
       4,    3,    3,    5,           30,    3,    6,    2,    // 103
       0,   11,    2,    5,            8,    3,    6,    3,    // 111
       0,    5,    6,    3,            0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 6;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   31,   56,   75,         88,  104,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Struct3) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        managed struct StructI                               \n\
        {                                                    \n\
            int k;                                           \n\
        };                                                   \n\
                                                             \n\
        struct StructO                                       \n\
        {                                                    \n\
            StructI *SI;                                     \n\
            StructI *SJ[3];                                  \n\
        };                                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
            StructO SO;                                      \n\
            SO.SI = new StructI;                             \n\
            SO.SI.k = 12345;                                 \n\
            StructO SOA[3];                                  \n\
            SOA[2].SI = new StructI;                         \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct3", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 147;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,   16,    1,    // 7
       1,   16,   73,    3,            4,   51,   16,   29,    // 15
       2,   30,    2,   47,            3,    6,    3, 12345,    // 23
      51,   16,   29,    2,           30,    2,   29,    3,    // 31
      48,    3,   30,    4,           29,    3,    3,    4,    // 39
       3,   30,    2,   52,            8,    3,    3,    1,    // 47
       2,   63,   48,    1,            1,   48,   73,    3,    // 55
       4,   29,    3,    6,            3,    2,   46,    3,    // 63
       3,   32,    3,   16,            3,    3,    5,   30,    // 71
       3,   51,   48,   29,            2,   30,    2,   11,    // 79
       2,    5,   47,    3,            6,    3,    0,   51,    // 87
      64,   49,   51,   60,           49,    1,    2,    4,    // 95
      49,    1,    2,    4,           49,   51,   48,   49,    // 103
      51,   32,   49,   51,           16,   49,   51,   44,    // 111
      49,    1,    2,    4,           49,    1,    2,    4,    // 119
      49,   51,   28,   49,            1,    2,    4,   49,    // 127
       1,    2,    4,   49,           51,   12,   49,    1,    // 135
       2,    4,   49,    1,            2,    4,   49,    2,    // 143
       1,   64,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Struct4) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct StructO                                       \n\
        {                                                    \n\
            static import int StInt(int i);                  \n\
        };                                                   \n\
        StructO        S1;                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
             StructO        S2;                              \n\
             return S1.StInt(S2.StInt(7));                   \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct4", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 37;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    0,    6,    // 7
       3,    7,   34,    3,           39,    1,    6,    3,    // 15
       0,   33,    3,   35,            1,   34,    3,   39,    // 23
       1,    6,    3,    0,           33,    3,   35,    1,    // 31
       5,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,   27,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "StructO::StInt^1",            "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Struct5) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        managed struct Struct0;                              \n\
                                                             \n\
        struct Struct1                                       \n\
        {                                                    \n\
            Struct0 *Array[];                                \n\
        };                                                   \n\
                                                             \n\
        managed struct Struct0                               \n\
        {                                                    \n\
            int Payload;                                     \n\
        };                                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
             Struct1 S;                                      \n\
                                                             \n\
             S.Array = new Struct0[5];                       \n\
             S.Array[3].Payload ++;                          \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct5", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 72;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    6,    3,            5,   72,    3,    4,    // 15
       1,   51,    4,   29,            2,   30,    2,   47,    // 23
       3,    6,    3,    3,            3,    3,    7,   51,    // 31
       4,   32,    7,    4,           48,    2,   52,   71,    // 39
       7,   11,    2,    7,           29,    2,   30,    2,    // 47
      48,    3,   29,    3,           30,    2,   52,    7,    // 55
       3,    1,    3,    1,            8,    3,    6,    3,    // 63
       0,   51,    4,   49,            2,    1,    4,    5,    // 71
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }






























    const size_t numfixups = 0;



















    EXPECT_EQ(numfixups, scrip->numfixups);














    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }





































    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);





















}


TEST(Compatibility, Struct6) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct1                                       \n\
        {                                                    \n\
            int IPayload;                                    \n\
            char CPayload[3];                                \n\
        };                                                   \n\
                                                             \n\
        Struct1 S1[3];                                       \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
            S1[1].IPayload = 0;                              \n\
            S1[1].CPayload[0] = 'A';                         \n\
            S1[1].CPayload[1] = S1[1].CPayload[0] - 'A';     \n\
            S1[1].CPayload[0] --;                            \n\
            return 0;                                        \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct6", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 218;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,   29,    3,    6,    // 7
       3,    1,   46,    3,            3,   32,    3,    8,    // 15
       3,    3,    5,   30,            3,    6,    2,    0,    // 23
      11,    2,    5,    8,            3,    6,    3,   65,    // 31
      29,    3,    6,    3,            1,   46,    3,    3,    // 39
      32,    3,    8,    3,            3,    5,   30,    3,    // 47
      29,    3,   29,    5,            6,    3,    0,   46,    // 55
       3,    3,   32,    3,            1,   30,    5,   11,    // 63
       5,    3,   30,    3,            6,    2,    4,   11,    // 71
       2,    5,   26,    3,            6,    3,    1,   46,    // 79
       3,    3,   32,    3,            8,    3,    3,    5,    // 87
      29,    5,    6,    3,            0,   46,    3,    3,    // 95
      32,    3,    1,   30,            5,   11,    5,    3,    // 103
       6,    2,    4,   11,            2,    5,   24,    3,    // 111
      29,    3,    6,    3,           65,   30,    4,   12,    // 119
       4,    3,    3,    4,            3,   29,    3,    6,    // 127
       3,    1,   46,    3,            3,   32,    3,    8,    // 135
       3,    3,    5,   30,            3,   29,    3,   29,    // 143
       5,    6,    3,    1,           46,    3,    3,   32,    // 151
       3,    1,   30,    5,           11,    5,    3,   30,    // 159
       3,    6,    2,    4,           11,    2,    5,   26,    // 167
       3,    6,    3,    1,           46,    3,    3,   32,    // 175
       3,    8,    3,    3,            5,   29,    5,    6,    // 183
       3,    0,   46,    3,            3,   32,    3,    1,    // 191
      30,    5,   11,    5,            3,    6,    2,    4,    // 199
      11,    2,    5,   24,            3,    2,    3,    1,    // 207
      26,    3,    6,    3,            0,    5,    6,    3,    // 215
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      23,   70,  106,  163,        199,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, StructExtender) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct                                        \n\
        {                                                    \n\
            int k;                                           \n\
        };                                                   \n\
                                                             \n\
        struct Sub extends Struct                            \n\
        {                                                    \n\
            int l;                                           \n\
        };                                                   \n\
                                                             \n\
        int Func(this Sub *, int i, int j)                   \n\
        {                                                    \n\
            return !i || !(j) && this.k || (0 != this.l);    \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StructExtender", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 100;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   51,           12,    7,    3,   42,    // 15
       3,   70,   35,   29,            3,   51,   20,    7,    // 23
       3,   42,    3,   28,           17,   29,    3,   29,    // 31
       6,   30,    2,   52,            7,    3,   30,    4,    // 39
      21,    4,    3,    3,            4,    3,   30,    4,    // 47
      22,    4,    3,    3,            4,    3,   70,   33,    // 55
      29,    3,    6,    3,            0,   29,    3,   29,    // 63
       6,   30,    2,   52,            1,    2,    4,    7,    // 71
       3,   30,    4,   16,            4,    3,    3,    4,    // 79
       3,   30,    4,   22,            4,    3,    3,    4,    // 87
       3,    2,    1,    4,            5,    6,    3,    0,    // 95
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Func1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 82;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    3,    1,            2,   63,    4,    1,    // 15
       1,    4,   51,    4,           29,    2,   30,    2,    // 23
      48,    3,   34,    3,           51,    8,   29,    2,    // 31
      30,    2,   48,    3,           34,    3,   39,    2,    // 39
       6,    3,    0,   33,            3,   35,    2,    3,    // 47
       1,    2,    8,    3,            1,    1,    4,   51,    // 55
       4,    7,    3,   51,           12,   69,   51,    8,    // 63
      69,    2,    1,   12,            5,    6,    3,    0,    // 71
      51,   12,   69,   51,            8,   69,    2,    1,    // 79
      12,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      42,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func1A) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func1A", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 82;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    3,    1,            2,   63,    4,    1,    // 15
       1,    4,   51,    4,           29,    2,   30,    2,    // 23
      48,    3,   34,    3,           51,    8,   29,    2,    // 31
      30,    2,   48,    3,           34,    3,   39,    2,    // 39
       6,    3,    0,   33,            3,   35,    2,    3,    // 47
       1,    2,    8,    3,            1,    1,    4,   51,    // 55
       4,    7,    3,   51,           12,   69,   51,    8,    // 63
      69,    2,    1,   12,            5,    6,    3,    0,    // 71
      51,   12,   69,   51,            8,   69,    2,    1,    // 79
      12,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      42,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
                                    \n\
    int Func(Struct1 *S1, Struct2 *S2)  \n\
    {                               \n\
        return 0;                   \n\
    }                               \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
   ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 115;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   50,    3,    // 7
      51,   12,    7,    3,           50,    3,    6,    3,    // 15
       0,   51,    8,   69,           51,   12,   69,    5,    // 23
       6,    3,    0,   51,            8,   69,   51,   12,    // 31
      69,    5,   38,   34,            3,    1,    2,   63,    // 39
       4,    1,    1,    4,            3,    1,    2,   63,    // 47
       4,    1,    1,    4,           51,    4,   29,    2,    // 55
      30,    2,   48,    3,           29,    3,   51,   12,    // 63
      29,    2,   30,    2,           48,    3,   29,    3,    // 71
       6,    3,    0,   23,            3,    2,    1,    8,    // 79
       3,    1,    2,    8,            3,    1,    1,    4,    // 87
      51,    4,    7,    3,           51,   12,   69,   51,    // 95
       8,   69,    2,    1,           12,    5,    6,    3,    // 103
       0,   51,   12,   69,           51,    8,   69,    2,    // 111
       1,   12,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      74,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Func3A) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1 = Func(5);     \n\
        return -1;                  \n\
    }                               \n\
                                    \n\
    Struct1 *Func(int Int)          \n\
    {                               \n\
        return new Struct1;         \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func3A", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 53;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
        38,    0,    6,    3,            5,   29,    3,    6,    // 7
         3,    0,   23,    3,            2,    1,    4,    3,    // 15
         1,    2,   50,    3,            1,    1,    4,    6,    // 23
         3,   -1,   51,    4,           69,    2,    1,    4,    // 31
         5,    6,    3,    0,           51,    4,   69,    2,    // 39
         1,    4,    5,   38,           43,   73,    3,    4,    // 47
         5,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       9,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Func4) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        int Func(int P1, int P2)     \n\
        {                            \n\
            return P1 + P2;          \n\
        }                            \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int = Func(4);       \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func4", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 60;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   11,    4,    // 15
       3,    3,    4,    3,            5,    6,    3,    0,    // 23
       5,   38,   25,    6,            3,    5,   29,    3,    // 31
       6,    3,    4,   29,            3,    6,    3,    0,    // 39
      23,    3,    2,    1,            8,    3,    1,    2,    // 47
       8,    3,    1,    1,            4,    6,    3,    0,    // 55
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      39,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func5) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func5", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 63;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,   34,    3,    6,    // 7
       3,    4,   34,    3,           39,    2,    6,    3,    // 15
       0,   33,    3,   35,            2,    3,    1,    2,    // 23
       8,    3,    1,    1,            4,    6,    3,    1,    // 31
      34,    3,    6,    3,            4,   34,    3,   39,    // 39
       2,    6,    3,    0,           33,    3,   35,    2,    // 47
       3,    1,    2,    8,            3,    1,    1,    4,    // 55
       6,    3,    0,    2,            1,    8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,   43,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func5a) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
                                     \n\
        import int Func(int, int = 5); \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func5a", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 63;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,   34,    3,    6,    // 7
       3,    4,   34,    3,           39,    2,    6,    3,    // 15
       0,   33,    3,   35,            2,    3,    1,    2,    // 23
       8,    3,    1,    1,            4,    6,    3,    1,    // 31
      34,    3,    6,    3,            4,   34,    3,   39,    // 39
       2,    6,    3,    0,           33,    3,   35,    2,    // 47
       3,    1,    2,    8,            3,    1,    1,    4,    // 55
       6,    3,    0,    2,            1,    8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,   43,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func6) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int f, int = 5); \n\
        import int Func(int, int = 5); \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func6", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 63;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,   34,    3,    6,    // 7
       3,    4,   34,    3,           39,    2,    6,    3,    // 15
       0,   33,    3,   35,            2,    3,    1,    2,    // 23
       8,    3,    1,    1,            4,    6,    3,    1,    // 31
      34,    3,    6,    3,            4,   34,    3,   39,    // 39
       2,    6,    3,    0,           33,    3,   35,    2,    // 47
       3,    1,    2,    8,            3,    1,    1,    4,    // 55
       6,    3,    0,    2,            1,    8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,   43,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Func7) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        int Func(int P1, int P2)     \n\
        {                            \n\
            return P1 + P2;          \n\
        }                            \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int = Func(4,-99);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func7", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 60;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   11,    4,    // 15
       3,    3,    4,    3,            5,    6,    3,    0,    // 23
       5,   38,   25,    6,            3,  -99,   29,    3,    // 31
       6,    3,    4,   29,            3,    6,    3,    0,    // 39
      23,    3,    2,    1,            8,    3,    1,    2,    // 47
       8,    3,    1,    1,            4,    6,    3,    0,    // 55
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      39,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func8) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    struct Struct                   \n\
    {                               \n\
        float Float;                \n\
        int Func();                 \n\
    };                              \n\
                                    \n\
    int Struct::Func()              \n\
    {                               \n\
        return 5;                   \n\
    }                               \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct s;                   \n\
        int Int = s.Func() % 3;     \n\
        return Int;                 \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func8", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 72;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    5,    6,    3,    // 7
       0,    5,   38,   10,            3,    1,    2,   63,    // 15
       4,    1,    1,    4,           29,    6,   51,    8,    // 23
       3,    2,    3,   45,            3,    6,    3,    0,    // 31
      23,    3,   30,    6,           29,    3,    6,    3,    // 39
       3,   30,    4,   40,            4,    3,    3,    4,    // 47
       3,    3,    1,    2,            8,    3,    1,    1,    // 55
       4,   51,    4,    7,            3,    2,    1,    8,    // 63
       5,    6,    3,    0,            2,    1,    8,    5,    // 71
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      31,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Export) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    struct Struct                   \n\
    {                               \n\
        float Float;                \n\
        int Int;                    \n\
    };                              \n\
    Struct StructyStructy;          \n\
    export StructyStructy;          \n\
                                    \n\
    int Inty;                       \n\
    float Floaty;                   \n\
    export Floaty, Inty;            \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct s;                   \n\
        s.Int = 3;                  \n\
        s.Float = 1.1 / 2.2;        \n\
        return -2;                  \n\
    }                               \n\
    export main;                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Export", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 51;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    8,    1,    // 7
       1,    8,    6,    3,            3,   51,    4,    8,    // 15
       3,    6,    3, 1066192077,           29,    3,    6,    3,    // 23
    1074580685,   30,    4,   56,            4,    3,    3,    4,    // 31
       3,   51,    8,    8,            3,    6,    3,   -2,    // 39
       2,    1,    8,    5,            6,    3,    0,    2,    // 47
       1,    8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 4;
    EXPECT_EQ(numexports, scrip->numexports);

    std::string exports[] = {
    "StructyStructy", "Floaty",   "Inty",     "main$0",   // 3
     "[[SENTINEL]]"
    };

    for (size_t idx = 0; idx < numexports; idx++)
    {
        if (idx >= scrip->numexports) break;
        std::string prefix = "exports[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + exports[idx];
        std::string test_val = prefix + scrip->exports[idx];
        ASSERT_EQ(is_val, test_val);
    }

    int32_t export_addr[] = {
    0x2000000, 0x200000c,    0x2000008, 0x1000000, // 3
     0
    };

    for (size_t idx = 0; idx < numexports; idx++)
    {
        if (idx >= scrip->numexports) break;
        std::string prefix = "export_addr[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(export_addr[idx]);
        std::string test_val = prefix + std::to_string(scrip->export_addr[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, ArrayOfPointers1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        float Float;                     \n\
        protected int Int;               \n\
    };                                   \n\
    Struct *arr[50];                     \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        for(int i = 0; i < 9; i++)       \n\
            arr[i] = new Struct;         \n\
                                         \n\
        int test = (arr[10] == null);    \n\
                                         \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayOfPointers1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 130;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   51,    4,    7,    // 15
       3,   29,    3,    6,            3,    9,   30,    4,    // 23
      18,    4,    3,    3,            4,    3,   28,   43,    // 31
      73,    3,    8,   29,            3,   51,    8,    7,    // 39
       3,   46,    3,   50,            3,    3,    7,   30,    // 47
       3,    6,    2,    0,           32,    7,    4,   11,    // 55
       2,    7,   29,    2,           30,    2,   47,    3,    // 63
      51,    4,    7,    3,            1,    3,    1,    8,    // 71
       3,   31,  -62,    2,            1,    4,    6,    3,    // 79
      10,   46,    3,   50,            3,    3,    7,    6,    // 87
       2,    0,   32,    7,            4,   11,    2,    7,    // 95
      29,    2,   30,    2,           48,    3,   29,    3,    // 103
       6,    3,    0,   30,            4,   15,    4,    3,    // 111
       3,    4,    3,    3,            1,    2,    8,    3,    // 119
       1,    1,    4,    6,            3,    0,    2,    1,    // 127
       4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      51,   89,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, ArrayOfPointers2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        float Float;                     \n\
        protected int Int;               \n\
    };                                   \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        Struct *arr2[50];                \n\
        for (int i = 0; i < 20; i++) {   \n\
                arr2[i] = new Struct;    \n\
        }                                \n\
        arr2[5].Float = 2.2 - 0.0 * 3.3; \n\
        arr2[4] = null;                  \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayOfPointers2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 391;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,  200,    1,    // 7
       1,  200,    6,    3,            0,    3,    1,    2,    // 15
       8,    3,    1,    1,            4,   51,    4,    7,    // 23
       3,   29,    3,    6,            3,   20,   30,    4,    // 31
      18,    4,    3,    3,            4,    3,   28,   42,    // 39
      73,    3,    8,   29,            3,   51,    8,    7,    // 47
       3,   46,    3,   50,            3,    3,    7,   30,    // 55
       3,   51,  204,   32,            7,    4,   11,    2,    // 63
       7,   29,    2,   30,            2,   47,    3,   51,    // 71
       4,    7,    3,    1,            3,    1,    8,    3,    // 79
      31,  -61,    2,    1,            4,    6,    3, 1074580685,    // 87
      29,    3,    6,    3,            0,   29,    3,    6,    // 95
       3, 1079194419,   30,    4,           55,    4,    3,    3,    // 103
       4,    3,   30,    4,           58,    4,    3,    3,    // 111
       4,    3,   29,    3,            6,    3,    5,   46,    // 119
       3,   50,    3,    3,            7,   30,    3,   51,    // 127
     200,   32,    7,    4,           11,    2,    7,   29,    // 135
       2,   30,    2,   29,            3,   48,    3,   30,    // 143
       4,   29,    3,    3,            4,    3,   30,    2,    // 151
      52,    8,    3,    6,            3,    0,   29,    3,    // 159
       6,    3,    4,   46,            3,   50,    3,    3,    // 167
       7,   30,    3,   51,          200,   32,    7,    4,    // 175
      11,    2,    7,   29,            2,   30,    2,   47,    // 183
       3,    6,    3,    0,           51,  200,   69,    1,    // 191
       2,    4,   69,    1,            2,    4,   69,    1,    // 199
       2,    4,   69,    1,            2,    4,   69,    1,    // 207
       2,    4,   69,    1,            2,    4,   69,    1,    // 215
       2,    4,   69,    1,            2,    4,   69,    1,    // 223
       2,    4,   69,    1,            2,    4,   69,    1,    // 231
       2,    4,   69,    1,            2,    4,   69,    1,    // 239
       2,    4,   69,    1,            2,    4,   69,    1,    // 247
       2,    4,   69,    1,            2,    4,   69,    1,    // 255
       2,    4,   69,    1,            2,    4,   69,    1,    // 263
       2,    4,   69,    1,            2,    4,   69,    1,    // 271
       2,    4,   69,    1,            2,    4,   69,    1,    // 279
       2,    4,   69,    1,            2,    4,   69,    1,    // 287
       2,    4,   69,    1,            2,    4,   69,    1,    // 295
       2,    4,   69,    1,            2,    4,   69,    1,    // 303
       2,    4,   69,    1,            2,    4,   69,    1,    // 311
       2,    4,   69,    1,            2,    4,   69,    1,    // 319
       2,    4,   69,    1,            2,    4,   69,    1,    // 327
       2,    4,   69,    1,            2,    4,   69,    1,    // 335
       2,    4,   69,    1,            2,    4,   69,    1,    // 343
       2,    4,   69,    1,            2,    4,   69,    1,    // 351
       2,    4,   69,    1,            2,    4,   69,    1,    // 359
       2,    4,   69,    1,            2,    4,   69,    1,    // 367
       2,    4,   69,    1,            2,    4,   69,    1,    // 375
       2,    4,   69,    1,            2,    4,   69,    1,    // 383
       2,    4,   69,    2,            1,  200,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, ArrayInStruct) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        int Int[10];                     \n\
    };                                   \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        Struct *S = new Struct;          \n\
        S.Int[4] =  1;                   \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayInStruct", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 67;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   73,    3,           40,    3,    1,    2,    // 7
      50,    3,    1,    1,            4,    6,    3,    1,    // 15
      51,    4,   29,    2,           30,    2,   29,    3,    // 23
      48,    3,   30,    4,           29,    3,    3,    4,    // 31
       3,   29,    3,    6,            3,    4,   46,    3,    // 39
      10,   32,    3,    4,            3,    3,    5,   30,    // 47
       3,   30,    2,   52,           11,    2,    5,    8,    // 55
       3,    6,    3,    0,           51,    4,   69,    2,    // 63
       1,    4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, FuncVarargs1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Func(int I, ...)                 \n\
    {                                    \n\
        return I + I / I;                \n\
    }                                    \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        return 0;                        \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FuncVarargs1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 49;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   12,    7,    3,           29,    3,   51,   16,    // 15
       7,    3,   30,    4,           10,    4,    3,    3,    // 23
       4,    3,   30,    4,           11,    4,    3,    3,    // 31
       4,    3,    5,    6,            3,    0,    5,   38,    // 39
      39,    6,    3,    0,            5,    6,    3,    0,    // 47
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Writeprotected) {
    ccCompiledScript *scrip = newScriptFixture();

    // Directly taken from the doc on writeprotected, simplified.
    char *inpl = "\
        struct Weapon {                        \n\
            writeprotected int Damage;         \n\
            import int SetDamage(int damage);  \n\
        };                                     \n\
                                               \n\
        Weapon wp;                             \n\
                                               \n\
        int  Weapon::SetDamage(int damage)     \n\
        {                                      \n\
            this.Damage = damage;              \n\
            return 0;                          \n\
        }                                      \n\
                                               \n\
        int main()                             \n\
        {                                      \n\
            return wp.Damage;                  \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Writeprotected", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 48;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   51,           12,    7,    3,   29,    // 15
       6,   30,    2,   52,            8,    3,    6,    3,    // 23
       0,    2,    1,    4,            5,    6,    3,    0,    // 31
       2,    1,    4,    5,           38,   36,    6,    2,    // 39
       0,    7,    3,    5,            6,    3,    0,    5,    // 47
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      40,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Protected) {
    ccCompiledScript *scrip = newScriptFixture();

    // Directly taken from the doc on writeprotected, simplified.
    char *inpl = "\
        struct Weapon {                        \n\
            protected int Damage;              \n\
            import int SetDamage(int damage);  \n\
        };                                     \n\
                                               \n\
        Weapon wp;                             \n\
                                               \n\
        int  Weapon::SetDamage(int damage)     \n\
        {                                      \n\
            this.Damage = damage;              \n\
            return 0;                          \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Protected", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 36;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   51,           12,    7,    3,   29,    // 15
       6,   30,    2,   52,            8,    3,    6,    3,    // 23
       0,    2,    1,    4,            5,    6,    3,    0,    // 31
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Static1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Weapon {                        \n\
            import static int CalcDamage(      \n\
                 int Lifepoints, int Hitpoints = 5);   \n\
        };                                     \n\
                                               \n\
        static int Weapon::CalcDamage(int Lifepoints, int Hitpoints)  \n\
        {                                      \n\
            return Lifepoints - Hitpoints;     \n\
        }                                      \n\
                                               \n\
        int main()                             \n\
        {                                      \n\
            int hp = Weapon.CalcDamage(9) + Weapon.CalcDamage(9, 40);  \n\
            return hp + Weapon.CalcDamage(100);  \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Static1", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 124;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   12,    4,    // 15
       3,    3,    4,    3,            5,    6,    3,    0,    // 23
       5,   38,   25,    6,            3,    5,   29,    3,    // 31
       6,    3,    9,   29,            3,    6,    3,    0,    // 39
      23,    3,    2,    1,            8,   29,    3,    6,    // 47
       3,   40,   29,    3,            6,    3,    9,   29,    // 55
       3,    6,    3,    0,           23,    3,    2,    1,    // 63
       8,   30,    4,   11,            4,    3,    3,    4,    // 71
       3,    3,    1,    2,            8,    3,    1,    1,    // 79
       4,   51,    4,    7,            3,   29,    3,    6,    // 87
       3,    5,   29,    3,            6,    3,  100,   29,    // 95
       3,    6,    3,    0,           23,    3,    2,    1,    // 103
       8,   30,    4,   11,            4,    3,    3,    4,    // 111
       3,    2,    1,    4,            5,    6,    3,    0,    // 119
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      39,   59,   99,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Static2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Weapon {                        \n\
        };                                     \n\
                                               \n\
        int CalcDamage(static Weapon, int Lifepoints, int Hitpoints)  \n\
        {                                      \n\
            return Lifepoints - Hitpoints;     \n\
        }                                      \n\
                                               \n\
        int main()                             \n\
        {                                      \n\
            return Weapon.CalcDamage(9, 40);   \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Static2", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 50;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   12,    4,    // 15
       3,    3,    4,    3,            5,    6,    3,    0,    // 23
       5,   38,   25,    6,            3,   40,   29,    3,    // 31
       6,    3,    9,   29,            3,    6,    3,    0,    // 39
      23,    3,    2,    1,            8,    5,    6,    3,    // 47
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      39,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Readonly) {
    ccCompiledScript *scrip = newScriptFixture();

    // Directly taken from the doc on writeprotected, simplified.
    char *inpl = "\
        struct Weapon {                        \n\
            writeprotected int Damage;         \n\
            import int SetDamage(int damage);  \n\
        };                                     \n\
                                               \n\
        Weapon wp;                             \n\
                                               \n\
        int  Weapon::SetDamage(int damage)     \n\
        {                                      \n\
            this.Damage = damage;              \n\
            return 0;                          \n\
        }                                      \n\
                                               \n\
        int main()                             \n\
        {                                      \n\
            return wp.Damage;                  \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Readonly", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 48;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   51,           12,    7,    3,   29,    // 15
       6,   30,    2,   52,            8,    3,    6,    3,    // 23
       0,    2,    1,    4,            5,    6,    3,    0,    // 31
       2,    1,    4,    5,           38,   36,    6,    2,    // 39
       0,    7,    3,    5,            6,    3,    0,    5,    // 47
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      40,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Attribute1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Weapon {                          \n\
            protected int D_amage;               \n\
            import attribute int Damage;         \n\
            import int get_Damage();             \n\
            import void set_Damage(int damage);  \n\
        };                                       \n\
                                                 \n\
        int Weapon::get_Damage()                 \n\
        {                                        \n\
            return this.D_amage;                 \n\
        }                                        \n\
        Weapon sword;                            \n\
                                                 \n\
        void main()                              \n\
        {                                        \n\
            sword.Damage = 5;                    \n\
        }                                        \n\
        ";

    // [fw] NOTE: This test doesn't work so far, and rightly so:
    // The parser detects that int Weapon::get_Damage() has a local
    // definition, and the parser concludes that the import declaration
    // for it is a forward declaration. Yes indeed!
    ASSERT_STREQ("TEST IS COMMENTED OUT", "TEST IS COMMENTED OUT");
    
    /*
    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Attribute1", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 64;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   29,            6,   30,    2,   52,    // 15
       7,    3,    2,    1,            4,    5,    6,    3,    // 23
       0,    2,    1,    4,            5,   38,   29,    6,    // 31
       3,    5,    3,    3,            4,    6,    2,    0,    // 39
       3,    2,    3,   29,            6,   45,    3,   34,    // 47
       4,   39,    1,    6,            3,    1,   33,    3,    // 55
      35,    1,   30,    6,            6,    3,    0,    5,    // 63
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      39,   53,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 2;
    std::string imports[] = {
    "Weapon::set_Damage",         "Weapon::set_Damage^1",        "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);
    */
}

TEST(Compatibility, Import) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Weapon;                     \n\
                                               \n\
        int Func(int damage)                   \n\
        {                                      \n\
            int Int = 0;                       \n\
            Weapon = 77;                       \n\
            if (Weapon < 0)                    \n\
                Weapon = damage - (Int - Weapon) / Int; \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Import", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 100;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    6,    3,   77,    // 15
       6,    2,    0,    8,            3,    6,    2,    0,    // 23
       7,    3,   29,    3,            6,    3,    0,   30,    // 31
       4,   18,    4,    3,            3,    4,    3,   28,    // 39
      52,   51,   12,    7,            3,   29,    3,   51,    // 47
       8,    7,    3,   29,            3,    6,    2,    0,    // 55
       7,    3,   30,    4,           12,    4,    3,    3,    // 63
       4,    3,   29,    3,           51,   12,    7,    3,    // 71
      30,    4,   10,    4,            3,    3,    4,    3,    // 79
      30,    4,   12,    4,            3,    3,    4,    3,    // 87
       6,    2,    0,    8,            3,    6,    3,    0,    // 95
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      18,   23,   55,   90,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,   4,   4,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Weapon",       "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

// Copied from the file that initializes AGS programs
std::string gStringInit =
"\
        enum bool { false = 0, true };                                  \n\
                                                                        \n\
        internalstring autoptr builtin managed struct String {          \n\
            import static String Format(const string format, ...);      \n\
            import static bool IsNullOrEmpty(String stringToCheck);     \n\
            import String  Append(const string appendText);             \n\
            import String  AppendChar(char extraChar);                  \n\
            import int     CompareTo(const string otherString, bool caseSensitive = false);      \n\
            import int     Contains(const string needle);               \n\
            import String  Copy();                                      \n\
            import bool    EndsWith(const string endsWithText, bool caseSensitive = false);      \n\
            import int     IndexOf(const string needle);                \n\
            import String  LowerCase();                                 \n\
            import String  Replace(const string lookForText, const string replaceWithText, bool caseSensitive = false); \n\
            import String  ReplaceCharAt(int index, char newChar);      \n\
            import bool    StartsWith(const string startsWithText, bool caseSensitive = false);  \n\
            import String  Substring(int index, int length);            \n\
            import String  Truncate(int length);                        \n\
            import String  UpperCase();                                 \n\
            readonly import attribute float AsFloat;                    \n\
            readonly import attribute int AsInt;                        \n\
            readonly import attribute char Chars[];                     \n\
            readonly import attribute int Length;                       \n\
        };                                                              \n\
                                                                        \n\
        "; // these are 25 lines

TEST(Compatibility, StandardString) {
    ccCompiledScript *scrip = newScriptFixture();

    std::string sourcecode = "\
        int main()                         \n\
        {                                  \n\
            String s = \"Hello, world!\";  \n\
            if (s != \"Bye\")              \n\
                return 1;                  \n\
            return 0;                      \n\
        }                                  \n\
        ";
    sourcecode = gStringInit + sourcecode;

    char inpl[5000];
    strncpy(inpl, sourcecode.c_str(), 5000);

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StandardString", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 68;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,   64,    3,    3,    // 7
       1,    2,   50,    3,            1,    1,    4,   51,    // 15
       4,   29,    2,   30,            2,   48,    3,   29,    // 23
       3,    6,    3,   14,           30,    4,   66,    4,    // 31
       3,    3,    4,    3,           28,   10,    6,    3,    // 39
       1,   51,    4,   69,            2,    1,    4,    5,    // 47
       6,    3,    0,   51,            4,   69,    2,    1,    // 55
       4,    5,    6,    3,            0,   51,    4,   69,    // 63
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,   27,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      3,   3,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 20;
    std::string imports[] = {
    "String::Format^101",         "String::IsNullOrEmpty^1",    "String::Append^1",           // 2
    "String::AppendChar^1",       "String::CompareTo^2",        "String::Contains^1",         // 5
    "String::Copy^0",             "String::EndsWith^2",         "String::IndexOf^1",          // 8
    "String::LowerCase^0",        "String::Replace^3",          "String::ReplaceCharAt^2",    // 11
    "String::StartsWith^2",       "String::Substring^2",        "String::Truncate^1",         // 14
    "String::UpperCase^0",        "String::get_AsFloat",        "String::get_AsInt",          // 17
    "String::geti_Chars",         "String::get_Length",          "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 18;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'H',  'e',  'l',  'l',          'o',  ',',  ' ',  'w',     // 7
    'o',  'r',  'l',  'd',          '!',    0,  'B',  'y',     // 15
    'e',    0,  '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }
}

TEST(Compatibility, SwitchNoBreak) {
    ccCompiledScript *scrip = newScriptFixture();

    // Last switch clause no "break"
    char *inpl = "\
        void main()                     \n\
        {                               \n\
            int i = 5;                  \n\
            switch(i)                   \n\
            {                           \n\
            default: break;             \n\
            case 5: i = 0;              \n\
            }                           \n\
            return;                     \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("SwitchNoBreak", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code
    const size_t codesize = 66;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   51,    4,    7,    // 15
       3,    3,    3,    4,           31,   16,   31,   28,    // 23
       6,    3,    0,   31,           -7,    6,    3,    0,    // 31
      51,    4,    8,    3,           31,   14,   29,    4,    // 39
       6,    3,    5,   30,            4,   16,    3,    4,    // 47
      28,  -21,   31,  -28,            6,    3,    0,    2,    // 55
       1,    4,    5,    6,            3,    0,    2,    1,    // 63
       4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);
}
