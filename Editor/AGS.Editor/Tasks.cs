using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using AGS.Types;
using AGS.Editor.Preferences;
using AGS.Editor.Components;
using AGS.Editor.Utils;

namespace AGS.Editor
{
    public class Tasks
    {
        public const string AUTO_GENERATED_HEADER_NAME = "_AutoGenerated.ash";

        public delegate void TestGameFinishedHandler(int exitCode);
        public event TestGameFinishedHandler TestGameFinished;
        public delegate void GetFilesForInclusionInTemplateHandler(List<string> fileNames);
        public event GetFilesForInclusionInTemplateHandler GetFilesForInclusionInTemplate;
        // Fired when a new game directory has just been created from a template,
        // but before the game is loaded into AGS.
        public delegate void NewGameFilesExtractedHandler();
        public event NewGameFilesExtractedHandler NewGameFilesExtracted;

        private Process _testGameProcess = null;
        private bool _runningGameWithDebugger = false;

        public void CreateNewGameFromTemplate(string templateFileName, string newGameDirectory)
        {
            Directory.CreateDirectory(newGameDirectory);
            Directory.SetCurrentDirectory(newGameDirectory);
            Utilities.EnsureStandardSubFoldersExist();
            Factory.NativeProxy.ExtractTemplateFiles(templateFileName);

            if (NewGameFilesExtracted != null)
            {
                NewGameFilesExtracted();
            }
        }

        /// <summary>
        /// Returns a collection of patterns used to find standard game project files.
        /// Uses game's last saved format version to distinguish different file sets.
        /// </summary>
        public string[] GetPatternsForStandardGameFiles(Game game, bool mediaResources)
        {
            string[] commonFiles = new string[]
            {
                AGSEditor.GAME_FILE_NAME,
                AGSEditor.SPRITE_FILE_NAME,
                "*.ico",
                "*.asc",
                "*.ash",
                "*.txt",
                "*.trs",
                // Exclude patterns
                "!_Debug/*",
                "!Compiled/*"
            };

            string[] mediaRes;
            if (mediaResources)
            {
                mediaRes = new string[]
                {
                    $"{AudioComponent.AUDIO_CACHE_DIRECTORY}\\*.*",
                    $"{SpeechComponent.SPEECH_DIRECTORY}\\*.*",
                    "preload.pcx",
                    "flic*.fl?",
                    "*.ogv"
                };
            }
            else
            {
                mediaRes = new string[0];
            }

            string[] roomFiles = null;
            if (game.SavedXmlVersionIndex != null && game.SavedXmlVersionIndex < AGSEditor.AGS_4_0_0_XML_VERSION_INDEX_OPEN_ROOMS)
            {
                roomFiles = new string[] { "*.crm" };
            }
            else if ((game.SavedXmlVersionIndex != null && game.SavedXmlVersionIndex >= AGSEditor.AGS_4_0_0_XML_VERSION_INDEX_OPEN_ROOMS)
                || game.SavedXmlVersion >= new System.Version(AGSEditor.FIRST_XML_VERSION_WITHOUT_INDEX))
            {
                roomFiles = new string[] {
                    "Rooms/*/data.xml",
                    "Rooms/*/*.png",
                    "Rooms/*/room*.asc"
                };
            }

            string[] fontFiles = null;
            if (game.SavedXmlVersionIndex != null && game.SavedXmlVersionIndex < AGSEditor.AGS_4_0_0_XML_VERSION_INDEX_FONT_SOURCES)
            {
                fontFiles = new string[]
                {
                    "*.ttf",
                    "*.wfn"
                };
            }
            else if ((game.SavedXmlVersionIndex != null && game.SavedXmlVersionIndex >= AGSEditor.AGS_4_0_0_XML_VERSION_INDEX_FONT_SOURCES)
                || game.SavedXmlVersion >= new System.Version(AGSEditor.FIRST_XML_VERSION_WITHOUT_INDEX))
            {
                fontFiles = new string[]
                {
                    $"{FontsComponent.FONT_FILES_DIRECTORY}/*.ttf",
                    $"{FontsComponent.FONT_FILES_DIRECTORY}/*.wfn"
                };
            }

            List<string> allFiles = new List<string>();
            allFiles.AddRange(commonFiles);
            if (mediaRes != null)
                allFiles.AddRange(mediaRes);
            if (roomFiles != null)
                allFiles.AddRange(roomFiles);
            if (fontFiles != null)
                allFiles.AddRange(fontFiles);
            return allFiles.ToArray();
        }

        private void ConstructFileListUsingIncludeFile(List<string> filesToInclude, string fileDir, string includeFile)
        {
            using (Stream s = File.OpenRead(includeFile))
            {
                var patterns = 
                    IncludeUtils.CreatePatternList(s, IncludeUtils.MatchOption.CaseInsensitive);
                if (patterns.Length == 0)
                    return;

                string[] files = Utilities.GetDirectoryFileList(fileDir, "*.*", SearchOption.AllDirectories, relativePaths: true);
                if (files.Length == 0)
                    return;

                files = IncludeUtils.FilterItemList(files, patterns, IncludeUtils.MatchOption.CaseInsensitive);
                filesToInclude.AddRange(files);
            }
        }

        private void ConstructBasicFileListForTemplate(List<string> filesToInclude, List<string> filesToDeleteAfterwards)
        {
            var patternStr = GetPatternsForStandardGameFiles(Factory.AGSEditor.CurrentGame, mediaResources: true);
            var patterns = IncludeUtils.CreatePatternList(patternStr, IncludeUtils.MatchOption.CaseInsensitive);
            string[] files = Utilities.GetDirectoryFileList(Factory.AGSEditor.CurrentGame.DirectoryPath, "*.*", SearchOption.AllDirectories, relativePaths: true);
            filesToInclude.AddRange(files);

            if (GetFilesForInclusionInTemplate != null)
            {
                List<string> extraFiles = new List<string>();

                GetFilesForInclusionInTemplate(extraFiles);

                // FIXME: remind why do we have to copy these files into the current directory?!
                // there has to be a way to avoid doing this!
                foreach (string fullFileName in extraFiles)
                {
                    string baseFileName = Path.GetFileName(fullFileName);
                    if (Path.GetDirectoryName(fullFileName).ToLower() != Directory.GetCurrentDirectory().ToLower())
                    {
                        File.Copy(fullFileName, baseFileName, true);
                        filesToDeleteAfterwards.Add(baseFileName);
                    }
                    filesToInclude.Add(baseFileName);
                }
            }
        }

        public void CreateTemplateFromCurrentGame(string templateFileName)
        {
            List<string> files = new List<string>();
            List<string> filesToDeleteAfterwards = new List<string>();

            string templateIncludeFile = Path.Combine(Factory.AGSEditor.CurrentGame.DirectoryPath, AGSEditor.TEMPLATE_INCLUDE_FILE);
            if (File.Exists(templateIncludeFile))
            {
                ConstructFileListUsingIncludeFile(files, Factory.AGSEditor.CurrentGame.DirectoryPath, templateIncludeFile);
            }
            else
            {
                ConstructBasicFileListForTemplate(files, filesToDeleteAfterwards);
            }

            Utilities.TryDeleteFile(templateFileName);

            Factory.NativeProxy.CreateTemplateFile(templateFileName, files.ToArray());

            foreach (string fileName in filesToDeleteAfterwards)
            {
                Utilities.TryDeleteFile(fileName);
            }
        }

        public bool LoadGameFromDisk(string gameToLoad, bool interactive)
        {
            bool needToSave = false;
            string gameDirectory = Path.GetDirectoryName(gameToLoad);

            CompileMessages errors = new CompileMessages();

            Directory.SetCurrentDirectory(gameDirectory);
            Factory.NativeProxy.NewWorkingDirSet(gameDirectory);
            Game game = null;

            Factory.AGSEditor.LoadGameFile(gameToLoad);
            game = Factory.AGSEditor.CurrentGame;

            if (game == null)
                return false;

            game.DirectoryPath = gameDirectory;

            // Run game upgrade process if necessary
            UpgradeGameManager.UpgradeGameResult result;
            if (!UpgradeGameManager.UpgradeWithWizard(game, errors, out result))
                return false;
            needToSave = result.ForceSaveProject;

            Utilities.EnsureStandardSubFoldersExist();

            InitSpritesAfterGameLoad(game, errors);

            // Process after game load operations
            RecentGame recentGame = new RecentGame(game.Settings.GameName, gameDirectory);
            if (Factory.AGSEditor.Settings.RecentGames.Contains(recentGame))
            {
                Factory.AGSEditor.Settings.RecentGames.Remove(recentGame);
            }
            Factory.AGSEditor.Settings.RecentGames.Insert(0, recentGame);

            Factory.Events.OnGamePostLoad(game);

            // WARNING: this is where the "global" Factory.AGSEditor.CurrentGame is set;
            // any tasks and events that expect to reference it must be called after!
            Factory.AGSEditor.RefreshEditorAfterGameLoad(game, errors);
            if (needToSave)
            {
                Factory.AGSEditor.SaveGameFiles();
            }

            Factory.AGSEditor.ReportGameLoad(errors);
            return true;
        }

        /// <summary>
        /// Initializes sprite file after loading a new game.
        /// Tests if the file exists and suggests to recreate if one is missing.
        /// </summary>
        private static void InitSpritesAfterGameLoad(Game game, CompileMessages errors)
        {
            // TODO: could not quickly find a more suitable place for this update...
            // we might do this somewhere in SpriteManagerComponent, for example, but then
            // there's a chance that spritefile will be recreated twice on game import.
            // ...revise this later
            bool colorDepth16bitFixed = false;
            if (game.Settings.ColorDepth == GameColorDepth.HighColor)
            {
                Factory.GUIController.ShowMessage("16-bit games are no longer supported by this version of AGS. Your game will be changed to a 32-bit game.\nAll the sprites and room backgrounds will be converted to match the new color depth.", MessageBoxIconType.Warning);
                // NOTE: sprite reimport from sources below will be using this new color depth
                game.Settings.ColorDepth = GameColorDepth.TrueColor;
                colorDepth16bitFixed = true;
            }

            // Load the sprite file
            bool isNewSpriteFile = false;
            bool isSpriteFileRecreated = false;
            if (!File.Exists(Path.Combine(game.DirectoryPath, AGSEditor.SPRITE_FILE_NAME)))
            {
                if (Factory.GUIController.ShowQuestion(string.Format("Spriteset file ({0}) was not found. Would you like to try reimport sprites from their sources? Otherwise, we'll generate an empty spritefile.\nNOTE: you may always try reimporting sprites later using respective menu commands.", AGSEditor.SPRITE_FILE_NAME), MessageBoxIcon.Warning)
                    == DialogResult.Yes)
                {
                    RecreateSpriteFileFromSources();
                    isSpriteFileRecreated = true;
                }
                else
                {
                    CreateNewSpriteFile();
                    isNewSpriteFile = true;
                }
            }

            if (colorDepth16bitFixed && !isNewSpriteFile && !isSpriteFileRecreated)
            {
                RecreateSpriteFileWithNewGameColorDepth();
            }

            try
            {
                Factory.NativeProxy.LoadNewSpriteFile();
            }
            catch (Exception e)
            {
                errors.Add(new CompileError(e.Message));
                if (!isNewSpriteFile)
                {
                    CreateNewSpriteFile();
                }
            }
        }

        public static void CreateNewSpriteFile()
        {
            string tempFilename = Path.GetTempFileName();
            SpriteTools.WriteDummySpriteFile(tempFilename);
            Factory.NativeProxy.ReplaceSpriteFile(tempFilename);
            File.Delete(tempFilename);
        }

        private class WriteSpriteFileArgs
        {
            public string DestFilename;
            public string SrcSetFilename;
            public string SrcIndexFilename;

            public WriteSpriteFileArgs(string destFilename, string srcSetFilename, string srcIndexFilename)
            {
                DestFilename = destFilename;
                SrcSetFilename = srcSetFilename;
                SrcIndexFilename = srcIndexFilename;
            }
        }

        private delegate void WriteSpriteFileWithProgress(string destFilename,
            string srcSetFilename, string srcIndexFilename, IWorkProgress progress);

        private static void RecreateSpriteFile(WriteSpriteFileWithProgress taskProc)
        {
            string tempFilename;
            try
            {
                tempFilename = Path.GetTempFileName();
                var args = new WriteSpriteFileArgs(tempFilename, AGSEditor.SPRITE_FILE_NAME, AGSEditor.SPRITE_INDEX_FILE_NAME);
                BusyDialog.Show("Please wait while the sprite file is recreated...",
                    new BusyDialog.ProcessingHandler(
                        (IWorkProgress progress, object o) => {
                            WriteSpriteFileArgs writeArgs = (WriteSpriteFileArgs)o;
                            taskProc(writeArgs.DestFilename, writeArgs.SrcSetFilename, writeArgs.SrcIndexFilename, progress);
                            return null;
                        }),
                    args);
            }
            catch (Exception e)
            {
                Factory.GUIController.ShowError("The recreation of a sprite file was interrupted by error.\nNO CHANGES were applied to your game.", e, MessageBoxIcon.Error);
                return;
            }

            Factory.NativeProxy.ReplaceSpriteFile(tempFilename);
            File.Delete(tempFilename);

            Factory.Events.OnSpritesImported(null);
        }

        public static void RecreateSpriteFileFromSources()
        {
            RecreateSpriteFile(SpriteTools.WriteSpriteFileFromSources);
        }

        public static void RecreateSpriteFileWithNewGameColorDepth()
        {
            RecreateSpriteFile(SpriteTools.WriteSpriteFileWithNewGameColorDepth);
        }

        public static void ExportSprites(SpriteFolder folder, SpriteTools.ExportSpritesOptions options)
        {
            try
            {
                BusyDialog.Show("Please wait while the sprites are exported...",
                    new BusyDialog.ProcessingHandler(
                        (IWorkProgress progress, object o) => { SpriteTools.ExportSprites(folder, options, progress); return null; }), null);
            }
            catch (Exception ex)
            {
                String message = String.Format("There was an error during the export. The error message was: '{0}'", ex.Message);
                Factory.GUIController.ShowMessage(message, MessageBoxIcon.Warning);
            }
        }

        public static void ExportSprites(SpriteTools.ExportSpritesOptions options)
        {
            ExportSprites(Factory.AGSEditor.CurrentGame.RootSpriteFolder, options);
        }

        public delegate int RemapColourProperty(int color, bool isBackgroundColor = false);

        /// <summary>
        /// Remaps all color properties in game from old color depth to a new color depth;
        /// for example: from palette mode to 32-bit mode, or other way.
        /// </summary>
        public static void RemapColourPropertiesOnDepthChange(Game game, GameColorDepth oldColorDepth)
        {
            RemapColourProperty remapColor = (color, isBg) => { return ColorMapper.RemapColourNumberToDepth(color, game.Palette, game.Settings.ColorDepth, oldColorDepth); };
            RemapColourProperties(game, remapColor);
        }

        /// <summary>
        /// Remaps color properties in particular Character from old color depth to a new color depth;
        /// for example: from palette mode to 32-bit mode, or other way.
        /// </summary>
        public static void RemapCharacterColours(Character character, Game game, GameColorDepth oldColorDepth)
        {
            RemapColourProperty remapColor = (color, isBg) => { return ColorMapper.RemapColourNumberToDepth(color, game.Palette, game.Settings.ColorDepth, oldColorDepth); };
            RemapColourProperties(character, remapColor);
        }

        /// <summary>
        /// Remaps color properties in particular GUI from old color depth to a new color depth;
        /// for example: from palette mode to 32-bit mode, or other way.
        /// </summary>
        public static void RemapGUIColours(GUI gui, Game game, GameColorDepth oldColorDepth)
        {
            RemapColourProperty remapColor = (color, isBg) => { return ColorMapper.RemapColourNumberToDepth(color, game.Palette, game.Settings.ColorDepth, oldColorDepth); };
            RemapColourProperties(gui, remapColor);
        }

        /// <summary>
        /// Remaps color properties in particular GUI control from old color depth to a new color depth;
        /// for example: from palette mode to 32-bit mode, or other way.
        /// </summary>
        public static void RemapGUIColours(GUIControl guiControl, Game game, GameColorDepth oldColorDepth)
        {
            RemapColourProperty remapColor = (color, isBg) => { return ColorMapper.RemapColourNumberToDepth(color, game.Palette, game.Settings.ColorDepth, oldColorDepth); };
            RemapColourProperties(guiControl, remapColor);
        }

        /// <summary>
        /// Remaps all color properties in game using provided delegate.
        /// </summary>
        public static void RemapColourProperties(Game game, RemapColourProperty remapColor)
        {
            var settings = game.Settings;
            settings.InventoryHotspotMarkerCrosshairColor = remapColor(settings.InventoryHotspotMarkerCrosshairColor);
            settings.InventoryHotspotMarkerDotColor = remapColor(settings.InventoryHotspotMarkerDotColor);

            foreach (var c in game.Characters)
            {
                RemapColourProperties(c, remapColor);
            }

            foreach (var gui in game.GUIs)
            {
                RemapColourProperties(gui, remapColor);
            }
        }

        private static void RemapColourProperties(Character character, RemapColourProperty remapColor)
        {
            character.SpeechColor = remapColor(character.SpeechColor);
        }

        private static void RemapColourProperties(GUI gui, RemapColourProperty remapColor)
        {
            gui.BackgroundColor = remapColor(gui.BackgroundColor, isBackgroundColor: true);
            if (gui is NormalGUI)
            {
                var ngui = gui as NormalGUI;
                ngui.BorderColor = remapColor(ngui.BorderColor, isBackgroundColor: true);
            }
            else if (gui is TextWindowGUI)
            {
                var tw = gui as TextWindowGUI;
                tw.TextColor = remapColor(tw.TextColor);
                // NOTE: TextWindowGUI.BorderColor currently internally maps to TextColor
            }

            foreach (var ctrl in gui.Controls)
            {
                RemapColourProperties(ctrl, remapColor);
            }
        }

        private static void RemapColourProperties(GUIControl guiControl, RemapColourProperty remapColor)
        {
            if (guiControl is GUIButton)
            {
                GUIButton but = guiControl as GUIButton;
                but.TextColor = remapColor(but.TextColor);
            }
            else if (guiControl is GUILabel)
            {
                GUILabel lab = guiControl as GUILabel;
                lab.TextColor = remapColor(lab.TextColor);
            }
            else if (guiControl is GUIListBox)
            {
                GUIListBox list = guiControl as GUIListBox;
                list.TextColor = remapColor(list.TextColor);
                list.SelectedTextColor = remapColor(list.SelectedTextColor);
                list.SelectedBackgroundColor = remapColor(list.SelectedBackgroundColor, isBackgroundColor: true);
            }
            else if (guiControl is GUITextBox)
            {
                GUITextBox textbox = guiControl as GUITextBox;
                textbox.TextColor = remapColor(textbox.TextColor);
            }
        }

        public void RunGameSetup()
        {
            RunGameEXE("--setup", false);
        }

        public void TestGame(bool withDebugger)
        {
            string exePath = Path.Combine(AGSEditor.DEBUG_OUTPUT_DIRECTORY, Factory.AGSEditor.BaseGameFileName + ".exe");
            string parameter = string.Empty;
                        
            if (withDebugger)
            {
                string logDebugger = Factory.ComponentController.FindComponent<DebugLogComponent>()?.GetCmdLineLogGroupsAndLevels();
                // debugger connection params
                parameter = logDebugger + " --enabledebugger " + Factory.AGSEditor.Debugger.InstanceIdentifier;
            }
            else if (Factory.AGSEditor.Settings.TestGameWindowStyle == TestGameWindowStyle.Windowed)
            {
                parameter = "--windowed";
            }
            else if (Factory.AGSEditor.Settings.TestGameWindowStyle == TestGameWindowStyle.FullScreen)
            {
                parameter = "--fullscreen";
            }
            _runningGameWithDebugger = withDebugger;
            // Pass both compiled dir and custom game data directories (point to where all supplemental data files are);
            // Command syntax is:
            //    --runfromide <INSTALLDIR> [OPT_PATH1:FILTER[,OPT_PATH2:FILTER[, ...]]]
            //
            // NOTE: OPT_PATHs and FILTERs must be encased in doublequotes, and separated by a single comma (no spaces).
            //
            parameter += " --runfromide" +
                " \"" + Path.Combine(AGSEditor.OUTPUT_DIRECTORY, BuildTargetWindows.WINDOWS_DIRECTORY) + "\" " +
                "\"" + Factory.AGSEditor.GameDirectory + "\":\"\"" + "," +
                "\"" + Path.Combine(Factory.AGSEditor.GameDirectory, FontsComponent.FONT_FILES_DIRECTORY) + "\":\"\"" + "," +
                "\"" + AudioComponent.AUDIO_CACHE_DIRECTORY + "\":\"audio\"" + "," +
                "\"" + SpeechComponent.SPEECH_DIRECTORY + "\":\"voice\"";

            // Explicit path to the file containing main game data,
            // this is to ensure that the engine won't try to scan other places
            parameter += " \"" + exePath + "\"";

            Factory.GUIController.ClearEngineLogMessages();

            RunEXEFile(exePath, parameter, true);

            if (withDebugger)
            {
                Factory.AGSEditor.Debugger.InitializeEngine(Factory.AGSEditor.CurrentGame, Factory.GUIController.TopLevelWindowHandle);
            }

        }

        private void RunGameEXE(string parameter, bool raiseEventOnExit)
        {
            string gameDirectory = Directory.GetCurrentDirectory();
            try
            {
                string exeName = Factory.AGSEditor.BaseGameFileName + ".exe";
                string exeDir = Path.Combine(AGSEditor.OUTPUT_DIRECTORY, BuildTargetWindows.WINDOWS_DIRECTORY);
                Directory.CreateDirectory(exeDir); // creates Windows directory if it does not exist
                Directory.SetCurrentDirectory(exeDir); // change into Windows directory to run setup

                RunEXEFile(exeName, parameter, raiseEventOnExit);
            }
            finally
            {
                Directory.SetCurrentDirectory(gameDirectory);
            }
        }

        private void RunEXEFile(string exeName, string parameter, bool raiseEventOnExit)
        {
            try
            {
                if (!File.Exists(exeName))
                {
                    throw new FileNotFoundException("Game EXE '" + exeName + "' has not been built. Use the Build EXE command and then try again.");
                }

                _testGameProcess = new Process();
                _testGameProcess.StartInfo.UseShellExecute = false;
                _testGameProcess.StartInfo.FileName = exeName;
                _testGameProcess.StartInfo.Arguments = parameter;
                if (raiseEventOnExit)
                {
                    _testGameProcess.EnableRaisingEvents = true;
                    _testGameProcess.Exited += _testGameProcess_Exited;
                }
                _testGameProcess.Start();
            }
            catch (Exception ex)
            {
                if (raiseEventOnExit)
                {
                    _testGameProcess_Exited(null, null);
                }
                throw ex;
            }
        }

        private void _testGameProcess_Exited(object sender, EventArgs e)
        {
            if (_runningGameWithDebugger)
            {
                Factory.AGSEditor.Debugger.EngineHasExited();
                _runningGameWithDebugger = false;
            }

            if (TestGameFinished != null)
            {
                int exitCode = -1;
                try
                {
                    // the ExitCode property will throw an exception
                    // if the process didn't start, in which case
                    // we use -1 as the exit code
                    exitCode = _testGameProcess.ExitCode;
                }
                catch (InvalidOperationException) { }

                TestGameFinished(exitCode);
            }

            _testGameProcess = null;
        }

        public Script RegenerateScriptHeader(Game game, Room currentRoom)
        {
            StringBuilder sb = new StringBuilder(10000);

            AppendCursorsToHeader(sb, game.Cursors);

            AppendFontsToHeader(sb, game.Fonts);

            AppendCharactersToHeader(sb, game.RootCharacterFolder, game);

            AppendAudioClipTypesToHeader(sb, game.AudioClipTypes);

            AppendAudioClipsToHeader(sb, game.RootAudioClipFolder);

            AppendInventoryToHeader(sb, game.InventoryItems);

            AppendDialogsToHeader(sb, game.Dialogs);

            AppendGUIsToHeader(sb, game.GUIs);

            AppendViewsToHeader(sb, game.RootViewFolder);

            if (currentRoom != null)
            {
                AppendRoomObjectsAndHotspotsToHeader(sb, currentRoom);
            }

            return new Script(AUTO_GENERATED_HEADER_NAME, sb.ToString(), true);
        }

        private void AppendRoomObjectsAndHotspotsToHeader(StringBuilder sb, Room room)
        {
            foreach (RoomObject obj in room.Objects)
            {
                if (obj.Name.Length > 0)
                {
                    sb.AppendLine("import readonly Object *" + obj.Name + ";");
                }
            }

            foreach (RoomHotspot hotspot in room.Hotspots)
            {
                if (hotspot.Name.Length > 0)
                {
                    sb.AppendLine("import readonly Hotspot *" + hotspot.Name + ";");
                }
            }
        }

        private void AppendInventoryToHeader(StringBuilder sb, IList<InventoryItem> items)
        {
            if (items.Count > 0)
            {
                // NOTE: there's always a dummy inv item at index 0
                sb.AppendLine(string.Format("import readonly InventoryItem *inventory[{0}];", items.Count + 1));

                foreach (InventoryItem item in items)
                {
                    if (item.Name.Length > 0)
                    {
                        sb.AppendLine("import readonly InventoryItem *" + item.Name + ";");
                    }
                }
            }
            else
            {
                // Declare a dummy array of 1 null pointer, prevent "undefined symbol" errors
                sb.AppendLine(string.Format("import readonly InventoryItem *inventory[1];"));
            }
        }

        private void AppendDialogsToHeader(StringBuilder sb, IList<Dialog> dialogs)
        {
            if (dialogs.Count > 0)
            {
                sb.AppendLine(string.Format("import readonly Dialog *dialog[{0}];", dialogs.Count));

                foreach (Dialog item in dialogs)
                {
                    if (item.Name.Length > 0)
                    {
                        sb.AppendLine("import readonly Dialog *" + item.Name + ";");
                    }
                }
            }
            else
            {
                // Declare a dummy array of 1 null pointer, prevent "undefined symbol" errors
                sb.AppendLine(string.Format("import readonly Dialog *dialog[1];"));
            }
        }

        private void AppendViewsToHeader(StringBuilder sb, ViewFolder viewFolder)
        {
            foreach (AGS.Types.View view in viewFolder.Views)
            {
                if (view.Name.Length > 0)
                {
                    sb.AppendLine("#define " + view.Name.ToUpperInvariant() + " " + view.ID);
                }
            }

            foreach (ViewFolder subFolder in viewFolder.SubFolders)
            {
                AppendViewsToHeader(sb, subFolder);
            }
        }

        private void AppendGUIsToHeader(StringBuilder sb, IList<GUI> guis)
        {
            if (guis.Count > 0)
            {
                sb.AppendLine(string.Format("import readonly GUI *gui[{0}];", guis.Count));

                foreach (GUI gui in guis)
                {
                    if (gui.Name.Length == 0)
                    {
                        continue;
                    }

                    sb.AppendLine("import readonly GUI *" + gui.Name + ";");

                    if (gui.Name.StartsWith("g"))
                    {
                        string guiMacroName = gui.Name.Substring(1).ToUpperInvariant();
                        sb.AppendLine(string.Format("#define {0} FindGUIID(\"{1}\")", guiMacroName, guiMacroName));
                    }

                    foreach (GUIControl control in gui.Controls)
                    {
                        if (control.Name.Length > 0)
                        {
                            sb.AppendLine("import readonly " + control.ScriptClassType + " *" + control.Name + ";");
                        }
                    }
                }
            }
            else
            {
                // Declare a dummy array of 1 null pointer, prevent "undefined symbol" errors
                sb.AppendLine(string.Format("import readonly GUI *gui[1];"));
            }
        }

        private void AppendAudioClipsToHeader(StringBuilder sb, AudioClipFolder clips)
        {
            foreach (AudioClip clip in clips.AllItemsFlat)
            {
                sb.AppendLine("import AudioClip *" + clip.ScriptName + ";");
            }
        }

        private void AppendCharactersToHeader(StringBuilder sb, CharacterFolder characters, Game game)
        {
            int charactersCount = characters.GetAllItemsCount();
            if (charactersCount > 0)
            {
                sb.AppendLine(string.Format("import readonly Character *character[{0}];", charactersCount));

                foreach (Character character in characters.AllItemsFlat)
                {
                    if (character.ScriptName.StartsWith("c") &&
                        (character.ScriptName.Length > 1))
                    {
                        string macroName = character.ScriptName.Substring(1).ToUpperInvariant();
                        // only create the legacy #define if it doesn't start with 0-9
                        // (eg. c500 would cause error)
                        if (!Char.IsDigit(macroName[0]))
                        {
                            sb.AppendLine("#define " + macroName + " " + character.ID);
                        }
                    }
                    if (character.ScriptName.Length > 0)
                    {
                        sb.AppendLine("import readonly Character *" + character.ScriptName + ";");
                    }
                }
            }
            else
            {
                // Declare a dummy array of 1 null pointer, prevent "undefined symbol" errors
                sb.AppendLine(string.Format("import readonly Character *character[1];"));
            }
        }

        private void AppendCursorsToHeader(StringBuilder sb, IList<MouseCursor> cursors)
        {
            sb.AppendLine("enum CursorMode {");
            bool firstCursor = true;
            foreach (MouseCursor cursor in cursors)
            {
                string cursorName = cursor.ScriptID;
                if (cursorName.Length > 0)
                {
                    if (!firstCursor)
                    {
                        sb.AppendLine(",");
                    }
                    sb.Append("  " + cursorName + " = " + cursor.ID);
                    firstCursor = false;
                }
            }
            if (firstCursor)
            {
                // no cursors, make sure the enum has something in it
                sb.Append("eDummyCursor__ = 99  // $AUTOCOMPLETEIGNORE$ ");
            }
            sb.AppendLine();
            sb.AppendLine("};");
        }

        private void AppendFontsToHeader(StringBuilder sb, IList<AGS.Types.Font> fonts)
        {
            sb.AppendLine("enum FontType {");
            sb.Append("  eUndefinedFont = -2,");
            sb.Append("  eNullFont = -1");
            foreach (AGS.Types.Font font in fonts)
            {
                string fontName = font.ScriptID;
                if (fontName.Length > 0)
                {
                    sb.AppendLine(",");
                    sb.Append("  " + fontName + " = " + font.ID);
                }
            }
            sb.AppendLine();
            sb.AppendLine("};");
        }

        private void AppendAudioClipTypesToHeader(StringBuilder sb, IList<AGS.Types.AudioClipType> clipTypes)
        {
            sb.AppendLine("enum AudioType {");
            bool firstType = true;
            foreach (AGS.Types.AudioClipType clipType in clipTypes)
            {
                string scriptName = clipType.ScriptID;
                if (scriptName.Length > 0)
                {
                    if (!firstType)
                    {
                        sb.AppendLine(",");
                    }
                    sb.Append("  " + scriptName + " = " + clipType.TypeID);
                    firstType = false;
                }
            }
            if (firstType)
            {
                // no clip types, make sure the enum has something in it
                sb.Append("eDummyAudioType__ = 99  // $AUTOCOMPLETEIGNORE$ ");
            }
            sb.AppendLine();
            sb.AppendLine("};");
        }

        /// <summary>
        /// FunctionLocation tells the location of a script function in script.
        /// </summary>
        public struct FunctionLocation
        {
            public string Name;
            public string ScriptName;
            public int LineNumber;

            public FunctionLocation(string name, string scriptName, int lineNumber)
            {
                Name = name;
                ScriptName = scriptName;
                LineNumber = lineNumber;
            }
        }

        /// <summary>
        /// Scans corresponding script module looking for the event functions.
        /// Creates a dictionary of FunctionLocations with event names as keys.
        /// If checkDefaultMatches is true, then also scans for the default event function names,
        /// otherwise only scans for the function names actually assigned to the event.
        /// Returns null on any error.
        /// </summary>
        public Dictionary<string, FunctionLocation> FindEventHandlersForObject(string objectName,
            Dictionary<string, string> scriptFunctions, bool checkDefaultMatches,
            string scriptModule, ScriptAutoCompleteData autoCompleteData = null)
        {
            // We generate default function names for those interactions that *DO NOT* have a function linked.
            var lookupFunctionNames = checkDefaultMatches ?
                scriptFunctions
                    .Select(f => { return new KeyValuePair<string, string>(f.Key, !string.IsNullOrEmpty(f.Value) ? f.Value : $"{objectName}_{f.Key}"); })
                    .ToDictionary(f => f.Key, f => f.Value)
                : scriptFunctions;
            if (autoCompleteData != null)
                return FindEventHandlers(scriptModule, autoCompleteData, lookupFunctionNames);
            else
                return FindEventHandlers(scriptModule, lookupFunctionNames);
        }

        /// <summary>
        /// Scans the script module looking for the list of functions.
        /// Creates a dictionary of FunctionLocations with event names as keys.
        /// Returns null on any error.
        /// <returns></returns>
        public Dictionary<string, FunctionLocation> FindEventHandlers(string scriptName, Dictionary<string, string> functionNames)
        {
            Script script = Factory.AGSEditor.CurrentGame.ScriptsAndHeaders.GetScriptByFilename(scriptName);
            if (script == null || script.AutoCompleteData == null || !script.AutoCompleteData.Populated)
                return null;

            return FindEventHandlers(scriptName, script.AutoCompleteData, functionNames);
        }

        public Dictionary<string, FunctionLocation> FindEventHandlers(string scriptName, ScriptAutoCompleteData scriptData, Dictionary<string, string> functionNames)
        {
            // FIXME: cannot get function line from ScriptToken.StartsAtCharacterIndex here
            // need to either add this to autocomplete, or rescan the file... which is going to be a lot of extra work
            var foundLoc = new Dictionary<string, FunctionLocation>();
            foreach (var fn in functionNames)
            {
                var func = scriptData.FindFunction(fn.Value);
                if (func != null)
                {
                    foundLoc.Add(fn.Key, new FunctionLocation(fn.Value, scriptName, 0));
                }
            }
            return foundLoc;
        }

        /// <summary>
        /// Converts all separate game files which may contain text from one encoding
        /// to another. This is done by loading and resaving them, and may take time
        /// depending on the size of the project.
        /// </summary>
        /// <param name="oldEnc"></param>
        /// <param name="newEnc"></param>
        public void ConvertAllGameTexts(Encoding oldEnc, Encoding newEnc)
        {
            // Convert all scripts
            foreach (var script in Factory.AGSEditor.CurrentGame.ScriptsAndHeaders)
            {
                // TODO: this is ugly, make TextEncoding non-static per script property?
                // or pass into Load/Save method (but some more changes are necessary)
                Script.TextEncoding = oldEnc;
                script.Header.LoadFromDisk();
                script.Script.LoadFromDisk();
                Script.TextEncoding = newEnc;
                script.Header.Modified = true;
                script.Header.SaveToDisk();
                script.Script.Modified = true;
                script.Script.SaveToDisk();
            }
            // Convert all room scripts
            foreach (var room in Factory.AGSEditor.CurrentGame.Rooms)
            {
                Script.TextEncoding = oldEnc;
                room.LoadScript();
                Script.TextEncoding = newEnc;
                room.Script.Modified = true;
                room.Script.SaveToDisk();
                room.UnloadScript();
            }
            // Save game with a new encoding
            if (Factory.GUIController.InvokeRequired)
            {
                Factory.GUIController.Invoke(new Func<bool>(Factory.AGSEditor.SaveGameFiles));
            }
            else
            {
                Factory.AGSEditor.SaveGameFiles();
            }
        }

        /// <summary>
        /// Resizes all GUI from one game resolution to another.
        /// </summary>
        public void ResizeAllGUIs(System.Drawing.Size oldResolution, System.Drawing.Size newResolution)
        {
            int oldWidth = oldResolution.Width;
            int oldHeight = oldResolution.Height;
            int newWidth = newResolution.Width;
            int newHeight = newResolution.Height;

            foreach (GUI gui in Factory.AGSEditor.CurrentGame.RootGUIFolder.AllItemsFlat)
            {
                NormalGUI theGui = gui as NormalGUI;
                if (theGui != null)
                {
                    theGui.Width = Math.Max((theGui.Width * newWidth) / oldWidth, 1);
                    theGui.Height = Math.Max((theGui.Height * newHeight) / oldHeight, 1);
                    theGui.Left = (theGui.Left * newWidth) / oldWidth;
                    theGui.Top = (theGui.Top * newHeight) / oldHeight;

                    foreach (GUIControl control in theGui.Controls)
                    {
                        control.Width = Math.Max((control.Width * newWidth) / oldWidth, 1);
                        control.Height = Math.Max((control.Height * newHeight) / oldHeight, 1);
                        control.Left = (control.Left * newWidth) / oldWidth;
                        control.Top = (control.Top * newHeight) / oldHeight;
                    }
                }
            }
        }
    }
}
