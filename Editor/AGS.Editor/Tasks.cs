using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using AGS.Types;
using AGS.Editor.Preferences;
using AGS.Editor.Components;
using AGS.Editor.Utils;

namespace AGS.Editor
{
    public class Tasks
    {
        public const string AUTO_GENERATED_HEADER_NAME = "_AutoGenerated.ash";

        public delegate void TestGameFinishedHandler(int exitCode);
        public event TestGameFinishedHandler TestGameFinished;
        public delegate void GetFilesForInclusionInTemplateHandler(List<string> fileNames);
        public event GetFilesForInclusionInTemplateHandler GetFilesForInclusionInTemplate;
        // Fired when a new game directory has just been created from a template,
        // but before the game is loaded into AGS.
        public delegate void NewGameFilesExtractedHandler();
        public event NewGameFilesExtractedHandler NewGameFilesExtracted;

        private Process _testGameProcess = null;
        private bool _runningGameWithDebugger = false;

        public void CreateNewGameFromTemplate(string templateFileName, string newGameDirectory)
        {
            Directory.CreateDirectory(newGameDirectory);
            Directory.SetCurrentDirectory(newGameDirectory);
            Utilities.EnsureStandardSubFoldersExist();
            Factory.NativeProxy.ExtractTemplateFiles(templateFileName);

            if (NewGameFilesExtracted != null)
            {
                NewGameFilesExtracted();
            }
        }

        private void ConstructFileListUsingIncludeFile(List<string> filesToInclude, string fileDir, string includeFile)
        {
            using (Stream s = File.OpenRead(includeFile))
            {
                var patterns = 
                    IncludeUtils.CreatePatternList(s, IncludeUtils.MatchOption.CaseInsensitive);
                if (patterns.Length == 0)
                    return;

                string[] files = Utilities.GetDirectoryFileList(fileDir, "*.*", SearchOption.AllDirectories);
                if (files.Length == 0)
                    return;

                for (int i = 0; i < files.Length; ++i)
                {
                    files[i] = files[i].Substring(fileDir.Length + 1);
                }

                files = IncludeUtils.FilterItemList(files, patterns, IncludeUtils.MatchOption.CaseInsensitive);
                filesToInclude.AddRange(files);
            }
        }

        private void ConstructBasicFileListForTemplate(List<string> filesToInclude, List<string> filesToDeleteAfterwards)
        {
            Utilities.AddAllMatchingFiles(filesToInclude, "*.ico");
            Utilities.AddAllMatchingFiles(filesToInclude, AGSEditor.GAME_FILE_NAME);
            Utilities.AddAllMatchingFiles(filesToInclude, AGSEditor.SPRITE_FILE_NAME);
            Utilities.AddAllMatchingFiles(filesToInclude, "preload.pcx");
            Utilities.AddAllMatchingFiles(filesToInclude, AudioComponent.AUDIO_CACHE_DIRECTORY + @"\*.*");
            Utilities.AddAllMatchingFiles(filesToInclude, SpeechComponent.SPEECH_DIRECTORY + @"\*.*");
            Utilities.AddAllMatchingFiles(filesToInclude, "flic*.fl?");
            Utilities.AddAllMatchingFiles(filesToInclude, FontsComponent.FONT_FILES_DIRECTORY, "*.ttf", true);
            Utilities.AddAllMatchingFiles(filesToInclude, FontsComponent.FONT_FILES_DIRECTORY, "*.wfn", true);
            Utilities.AddAllMatchingFiles(filesToInclude, "*.asc");
            Utilities.AddAllMatchingFiles(filesToInclude, "*.ash");
            Utilities.AddAllMatchingFiles(filesToInclude, "*.txt");
            Utilities.AddAllMatchingFiles(filesToInclude, "*.trs");
            Utilities.AddAllMatchingFiles(filesToInclude, "*.pdf");
            Utilities.AddAllMatchingFiles(filesToInclude, "*.ogv");

            // TODO: unfortunately current subfolder pattern is just a room's number,
            // which is impossible to narrow using just wildcards (is it?);
            // figure this problem out later.
            var roomDirs = Utilities.GetDirectoryRelativeDirList(Directory.GetCurrentDirectory(), @"Rooms\*");
            foreach (var dir in roomDirs)
            {
                Utilities.AddAllMatchingFiles(filesToInclude, dir, "data.xml", true);
                Utilities.AddAllMatchingFiles(filesToInclude, dir, "room*.asc", true);
                Utilities.AddAllMatchingFiles(filesToInclude, dir, "background*.png", true);
                Utilities.AddAllMatchingFiles(filesToInclude, dir, "hotspots.png", true);
                Utilities.AddAllMatchingFiles(filesToInclude, dir, "regions.png", true);
                Utilities.AddAllMatchingFiles(filesToInclude, dir, "walkableareas.png", true);
                Utilities.AddAllMatchingFiles(filesToInclude, dir, "walkbehinds.png", true);
            }

            if (GetFilesForInclusionInTemplate != null)
            {
                List<string> extraFiles = new List<string>();

                GetFilesForInclusionInTemplate(extraFiles);

                // FIXME: remind why do we have to copy these files into the current directory?!
                // there has to be a way to avoid doing this!
                foreach (string fullFileName in extraFiles)
                {
                    string baseFileName = Path.GetFileName(fullFileName);
                    if (Path.GetDirectoryName(fullFileName).ToLower() != Directory.GetCurrentDirectory().ToLower())
                    {
                        File.Copy(fullFileName, baseFileName, true);
                        filesToDeleteAfterwards.Add(baseFileName);
                    }
                    filesToInclude.Add(baseFileName);
                }
            }
        }

        public void CreateTemplateFromCurrentGame(string templateFileName)
        {
            List<string> files = new List<string>();
            List<string> filesToDeleteAfterwards = new List<string>();

            string templateIncludeFile = Path.Combine(Factory.AGSEditor.CurrentGame.DirectoryPath, AGSEditor.TEMPLATE_INCLUDE_FILE);
            if (File.Exists(templateIncludeFile))
            {
                ConstructFileListUsingIncludeFile(files, Factory.AGSEditor.CurrentGame.DirectoryPath, templateIncludeFile);
            }
            else
            {
                ConstructBasicFileListForTemplate(files, filesToDeleteAfterwards);
            }

            Utilities.TryDeleteFile(templateFileName);

            Factory.NativeProxy.CreateTemplateFile(templateFileName, files.ToArray());

            foreach (string fileName in filesToDeleteAfterwards)
            {
                Utilities.TryDeleteFile(fileName);
            }
        }

        public bool LoadGameFromDisk(string gameToLoad, bool interactive)
        {
            bool needToSave = false;
            string gameDirectory = Path.GetDirectoryName(gameToLoad);

            CompileMessages errors = new CompileMessages();

            Directory.SetCurrentDirectory(gameDirectory);
            Factory.NativeProxy.NewWorkingDirSet(gameDirectory);
            Game game = null;

            Factory.AGSEditor.LoadGameFile(gameToLoad);
            game = Factory.AGSEditor.CurrentGame;

            if (game == null)
                return false;

            game.DirectoryPath = gameDirectory;
            UpgradeFeatures(game);

            // Run game upgrade process if necessary
            UpgradeGameManager.UpgradeGameResult result;
            if (!UpgradeGameManager.UpgradeWithWizard(game, errors, out result))
                return false;
            needToSave = result.ForceSaveProject;

            Utilities.EnsureStandardSubFoldersExist();

            InitSpritesAfterGameLoad(game, errors);

            // Process after game load operations
            RecentGame recentGame = new RecentGame(game.Settings.GameName, gameDirectory);
            if (Factory.AGSEditor.Settings.RecentGames.Contains(recentGame))
            {
                Factory.AGSEditor.Settings.RecentGames.Remove(recentGame);
            }
            Factory.AGSEditor.Settings.RecentGames.Insert(0, recentGame);

            Factory.Events.OnGamePostLoad(game);

            // WARNING: this is where the "global" Factory.AGSEditor.CurrentGame is set;
            // any tasks and events that expect to reference it must be called after!
            Factory.AGSEditor.RefreshEditorAfterGameLoad(game, errors);
            if (needToSave)
            {
                Factory.AGSEditor.SaveGameFiles();
            }

            Factory.AGSEditor.ReportGameLoad(errors);
            return true;
        }

        /// <summary>
        /// Initializes sprite file after loading a new game.
        /// Tests if the file exists and suggests to recreate if one is missing.
        /// </summary>
        private static void InitSpritesAfterGameLoad(Game game, CompileMessages errors)
        {
            // TODO: could not quickly find a more suitable place for this update...
            // we might do this somewhere in SpriteManagerComponent, for example, but then
            // there's a chance that spritefile will be recreated twice on game import.
            // ...revise this later
            bool colorDepth16bitFixed = false;
            if (game.Settings.ColorDepth == GameColorDepth.HighColor)
            {
                Factory.GUIController.ShowMessage("16-bit games are no longer supported by this version of AGS. Your game will be changed to a 32-bit game.\nAll the sprites and room backgrounds will be converted to match the new color depth.", MessageBoxIconType.Warning);
                // NOTE: sprite reimport from sources below will be using this new color depth
                game.Settings.ColorDepth = GameColorDepth.TrueColor;
                colorDepth16bitFixed = true;
            }

            // Load the sprite file
            bool isNewSpriteFile = false;
            bool isSpriteFileRecreated = false;
            if (!File.Exists(Path.Combine(game.DirectoryPath, AGSEditor.SPRITE_FILE_NAME)))
            {
                if (Factory.GUIController.ShowQuestion(string.Format("Spriteset file ({0}) was not found. Would you like to try reimport sprites from their sources? Otherwise, we'll generate an empty spritefile.\nNOTE: you may always try reimporting sprites later using respective menu commands.", AGSEditor.SPRITE_FILE_NAME), MessageBoxIcon.Warning)
                    == DialogResult.Yes)
                {
                    RecreateSpriteFileFromSources();
                    isSpriteFileRecreated = true;
                }
                else
                {
                    CreateNewSpriteFile();
                    isNewSpriteFile = true;
                }
            }

            if (colorDepth16bitFixed && !isNewSpriteFile && !isSpriteFileRecreated)
            {
                RecreateSpriteFileWithNewGameColorDepth();
            }

            try
            {
                Factory.NativeProxy.LoadNewSpriteFile();
            }
            catch (Exception e)
            {
                errors.Add(new CompileError(e.Message));
                if (!isNewSpriteFile)
                {
                    CreateNewSpriteFile();
                }
            }
        }

        public static void CreateNewSpriteFile()
        {
            string tempFilename = Path.GetTempFileName();
            SpriteTools.WriteDummySpriteFile(tempFilename);
            Factory.NativeProxy.ReplaceSpriteFile(tempFilename);
            File.Delete(tempFilename);
        }

        private class WriteSpriteFileArgs
        {
            public string DestFilename;
            public string SrcSetFilename;
            public string SrcIndexFilename;

            public WriteSpriteFileArgs(string destFilename, string srcSetFilename, string srcIndexFilename)
            {
                DestFilename = destFilename;
                SrcSetFilename = srcSetFilename;
                SrcIndexFilename = srcIndexFilename;
            }
        }

        private delegate void WriteSpriteFileWithProgress(string destFilename,
            string srcSetFilename, string srcIndexFilename, IWorkProgress progress);

        private static void RecreateSpriteFile(WriteSpriteFileWithProgress taskProc)
        {
            string tempFilename;
            try
            {
                tempFilename = Path.GetTempFileName();
                var args = new WriteSpriteFileArgs(tempFilename, AGSEditor.SPRITE_FILE_NAME, AGSEditor.SPRITE_INDEX_FILE_NAME);
                BusyDialog.Show("Please wait while the sprite file is recreated...",
                    new BusyDialog.ProcessingHandler(
                        (IWorkProgress progress, object o) => {
                            WriteSpriteFileArgs writeArgs = (WriteSpriteFileArgs)o;
                            taskProc(writeArgs.DestFilename, writeArgs.SrcSetFilename, writeArgs.SrcIndexFilename, progress);
                            return null;
                        }),
                    args);
            }
            catch (Exception e)
            {
                Factory.GUIController.ShowMessage("The recreation of a sprite file was interrupted by error.\nNO CHANGES were applied to your game.\n\n" + e.Message, MessageBoxIcon.Error);
                return;
            }

            Factory.NativeProxy.ReplaceSpriteFile(tempFilename);
            File.Delete(tempFilename);

            Factory.Events.OnSpritesImported(null);
        }

        public static void RecreateSpriteFileFromSources()
        {
            RecreateSpriteFile(SpriteTools.WriteSpriteFileFromSources);
        }

        public static void RecreateSpriteFileWithNewGameColorDepth()
        {
            RecreateSpriteFile(SpriteTools.WriteSpriteFileWithNewGameColorDepth);
        }

        public static void ExportSprites(SpriteFolder folder, SpriteTools.ExportSpritesOptions options)
        {
            try
            {
                BusyDialog.Show("Please wait while the sprites are exported...",
                    new BusyDialog.ProcessingHandler(
                        (IWorkProgress progress, object o) => { SpriteTools.ExportSprites(folder, options, progress); return null; }), null);
            }
            catch (Exception ex)
            {
                String message = String.Format("There was an error during the export. The error message was: '{0}'", ex.Message);
                Factory.GUIController.ShowMessage(message, MessageBoxIcon.Warning);
            }
        }

        public static void ExportSprites(SpriteTools.ExportSpritesOptions options)
        {
            ExportSprites(Factory.AGSEditor.CurrentGame.RootSpriteFolder, options);
        }

        private void UpgradeFeatures(Game game)
        {
#pragma warning disable 0612, 0618
            // TODO: this may be noticably if upgrading lots of items. Display some kind of
            // progress window to notify user.

            int xmlVersionIndex = 0;
            if (game.SavedXmlVersionIndex.HasValue)
            {
                xmlVersionIndex = game.SavedXmlVersionIndex.Value;
            }

            if (xmlVersionIndex < 2)
            {
                // Upgrade old games to use the Anti-Glide Mode setting
                foreach (Character character in game.RootCharacterFolder.AllItemsFlat)
                {
                    character.MovementLinkedToAnimation = game.Settings.AntiGlideMode;
                }
            }

            if (xmlVersionIndex < 3)
            {
                // Upgrade old games to flatten the dialog scripts
                foreach (Dialog dialog in game.RootDialogFolder.AllItemsFlat)
                {
                    dialog.Script = RemoveAllLeadingSpacesFromLines(dialog.Script);
                }
            }

            if (xmlVersionIndex < 8)
            {
                // GUIListBox Translated property should be false, as they never translated in older games
                foreach (GUI gui in game.GUIs)
                {
                    foreach (GUIControl guic in gui.Controls)
                    {
                        if (guic is GUIListBox)
                            (guic as GUIListBox).Translated = false;
                    }
                }
            }

            if (xmlVersionIndex < 15)
            {
                game.DefaultSetup.SetDefaults();
            }

            if (xmlVersionIndex < 18)
            {
                foreach (Font font in game.Fonts)
                    font.SizeMultiplier = 1;
                // Apply font scaling to each individual font settings.
                // Bitmap fonts save multiplier explicitly, while vector fonts have their size doubled.
                if (game.Settings.HighResolution && !game.Settings.FontsForHiRes)
                {
                    foreach (Font font in game.Fonts)
                    {
                        if (font.PointSize == 0)
                        {
                            font.SizeMultiplier = 2;
                        }
                        else
                        {
                            font.PointSize *= 2;
                        }
                    }
                }
            }

            if (xmlVersionIndex < 18)
            {
                game.Settings.DefaultRoomMaskResolution = 1;
            }

            if (xmlVersionIndex < 19)
            {
                game.Settings.GameFileName = AGSEditor.Instance.BaseGameFileName ??
                    Path.GetFileName(game.DirectoryPath);

                var buildNames = new Dictionary<string, string>();
                foreach (IBuildTarget target in BuildTargetsInfo.GetRegisteredBuildTargets())
                {
                    buildNames[target.Name] = game.Settings.GameFileName;
                }
                game.WorkspaceState.SetLastBuildGameFiles(buildNames);
            }

            if (xmlVersionIndex < 20)
            {
                // Set the alpha channel requests for re-import based on the presence of an alpha channel
                foreach (Sprite sprite in game.RootSpriteFolder.GetAllSpritesFromAllSubFolders())
                {
                    sprite.ImportAlphaChannel = sprite.AlphaChannel;
                }
            }

            if (xmlVersionIndex < 21)
            {
                // Assign audio clip ids to match and solidify their current position in AudioClips array.
                int clipId = 0;
                foreach (AudioClip clip in game.RootAudioClipFolder.GetAllAudioClipsFromAllSubFolders())
                {
                    clip.ID = clipId++;
                }
                game.RootAudioClipFolder.Sort(true);
            }

            if (xmlVersionIndex < 23)
            {
                // Set the import dimensions based on existing sprite dimensions
                foreach (Sprite sprite in game.RootSpriteFolder.GetAllSpritesFromAllSubFolders())
                {
                    sprite.ImportWidth = sprite.Width;
                    sprite.ImportHeight = sprite.Height;
                }
            }

            if (xmlVersionIndex < 24)
            {
                // get all known source images and their largest known size
                // (avoiding System.Drawing / GDI as a dependency to load the project)
                Dictionary<string, Tuple<int, int>> sourceMaxSize = new Dictionary<string, Tuple<int, int>>(StringComparer.OrdinalIgnoreCase);

                foreach (Sprite sprite in game.RootSpriteFolder.GetAllSpritesFromAllSubFolders())
                {
                    if (!string.IsNullOrWhiteSpace(sprite.SourceFile))
                    {
                        int currentX = sprite.OffsetX + sprite.ImportWidth;
                        int currentY = sprite.OffsetY + sprite.ImportHeight;

                        if (sourceMaxSize.ContainsKey(sprite.SourceFile))
                        {
                            int maxX = sourceMaxSize[sprite.SourceFile].Item1;
                            int maxY = sourceMaxSize[sprite.SourceFile].Item2;
                            if (maxX < currentX) maxX = currentX;
                            if (maxY < currentY) maxY = currentY;
                            sourceMaxSize[sprite.SourceFile] = Tuple.Create(maxX, maxY);
                        }
                        else
                        {
                            sourceMaxSize.Add(sprite.SourceFile, Tuple.Create(currentX, currentY));
                        }
                    }
                }

                // Set the tiled image flag for existing imports - the only misdetection would be
                // a single import from a source image that starts at 0,0, but wasn't for the
                // entire image
                foreach (Sprite sprite in game.RootSpriteFolder.GetAllSpritesFromAllSubFolders())
                {
                    if (sprite.OffsetX > 0 || sprite.OffsetY > 0)
                    {
                        sprite.ImportAsTile = true;
                    }
                    else if (sourceMaxSize.ContainsKey(sprite.SourceFile))
                    {
                        int maxX = sourceMaxSize[sprite.SourceFile].Item1;
                        int maxY = sourceMaxSize[sprite.SourceFile].Item2;
                        sprite.ImportAsTile = sprite.ImportWidth < maxX || sprite.ImportHeight < maxY;
                    }
                    else
                    {
                        sprite.ImportAsTile = false;
                    }
                }
            }

            if (xmlVersionIndex >= 21 && xmlVersionIndex <= 25)
            {
                // Remap erroneous volatile clip ID references back to Fixed Index
                Dictionary<int, int> audioIDToIndex = new Dictionary<int, int>();
                foreach (AudioClip clip in game.RootAudioClipFolder.GetAllAudioClipsFromAllSubFolders())
                {
                    audioIDToIndex.Add(clip.ID, clip.Index);
                }

                foreach (Types.View view in game.RootViewFolder.AllItemsFlat)
                {
                    foreach (Types.ViewLoop loop in view.Loops)
                    {
                        foreach (Types.ViewFrame frame in loop.Frames)
                        {
                            if (frame.Sound == AudioClip.IDNoValue)
                            {
                                frame.Sound = AudioClip.FixedIndexNoValue;
                            }
                            else
                            {
                                frame.Sound = RemapAudioClipIDToFixedIndex(frame.Sound, audioIDToIndex);
                            }
                        }
                    }
                }
            }

            if (xmlVersionIndex < 3060000)
            {
                foreach (Character c in game.Characters)
                {
                    c.IdleAnimationDelay = c.AnimationDelay + 5;
                }

                game.Settings.TTFHeightDefinedBy = FontHeightDefinition.NominalHeight;
                game.Settings.TTFMetricsFixup = FontMetricsFixup.SetAscenderToHeight;
                foreach (Font font in game.Fonts)
                {
                    // For scaled-up bitmap fonts outline is xN
                    // NOTE: unfortunately as of now there's no direct way to determine if
                    // this is a bitmap font or TTF
                    if (!File.Exists(font.TTFFileName))
                    {
                        font.AutoOutlineThickness = font.SizeMultiplier;
                    }
                    font.TTFMetricsFixup = FontMetricsFixup.SetAscenderToHeight;
                }
                game.Settings.ClipGUIControls = false;
            }

            if (xmlVersionIndex < 3060020)
            {
                if (game.SavedXmlEncodingCodePage.HasValue &&
                    game.SavedXmlEncodingCodePage.Value == 65001)
                {
                    game.Settings.GameTextEncoding = "UTF-8";
                }
                else
                { // NOTE: use Encoding.GetEncoding(game.SavedXmlEncodingCodePage) if actual codepage is needed
                    game.Settings.GameTextEncoding = "ANSI";
                }

                game.Settings.UseOldKeyboardHandling = true;
            }

            if (xmlVersionIndex < 3060109)
            {
                game.Settings.ScaleCharacterSpriteOffsets = false;
            }

            if (xmlVersionIndex < 3060200 || (xmlVersionIndex > 3999900 && xmlVersionIndex < 4000010))
                {
                game.Settings.UseOldVoiceClipNaming = true;
            }

            if (xmlVersionIndex < 3060206 || (xmlVersionIndex > 3999900 && xmlVersionIndex < 4000014))
            {
                game.Settings.GameFPS = 40; // 40 was historical default FPS
            }

            // Update all the ColourNumber property values in game
            if (xmlVersionIndex < 4000009)
            {
                RemapLegacyColourProperties(game);
            }
            else if (xmlVersionIndex < 4000014)
            {
                RemapOpaqueColourProperties(game);
            }

            // Update ScriptCompiler selection
            if (xmlVersionIndex < 3999900)
            {
                game.Settings.ScriptCompiler = AGSEditor.DEFAULT_LEGACY_SCRIPT_COMPILER;
            }
            else if (xmlVersionIndex < 4000010)
            {
                game.Settings.ScriptCompiler = game.Settings.ExtendedCompiler ?
                    AGSEditor.DEFAULT_SCRIPT_COMPILER : AGSEditor.DEFAULT_LEGACY_SCRIPT_COMPILER;
            }

            // Update viewframes
            if (xmlVersionIndex < 4000012)
            {
                foreach (AGS.Types.View view in game.ViewFlatList)
                {
                    foreach (ViewLoop loop in view.Loops)
                    {
                        foreach (ViewFrame frame in loop.Frames)
                        {
                            frame.Flip = frame.Flipped ? SpriteFlipStyle.Horizontal : SpriteFlipStyle.None;
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(game.Settings.ScriptCompiler))
            {
                var compiler = Factory.NativeProxy.GetEmbeddedScriptCompilers().FirstOrDefault();
                game.Settings.ScriptCompiler = compiler != null ? compiler.GetName() : string.Empty;
            }

            System.Version editorVersion = new System.Version(AGS.Types.Version.AGS_EDITOR_VERSION);
            System.Version projectVersion = game.SavedXmlEditorVersion;
            if (projectVersion == null || projectVersion < editorVersion)
                game.SetScriptAPIForOldProject();
#pragma warning restore 0612, 0618
        }

        private static int RemapAudioClipIDToFixedIndex(int id, Dictionary<int, int> audioIDToIndex)
        {
            int fixedIndex;
            if (audioIDToIndex.TryGetValue(id, out fixedIndex))
                return fixedIndex;
            else
                return AudioClip.FixedIndexNoValue;
        }

        private string RemoveAllLeadingSpacesFromLines(string script)
        {
            StringReader sr = new StringReader(script);
            StringWriter sw = new StringWriter();
            string thisLine;
            while ((thisLine = sr.ReadLine()) != null)
            {
                sw.WriteLine(thisLine.Trim());
            }
            string returnValue = sw.ToString();
            sr.Close();
            sw.Close();
            return returnValue;
        }

        private delegate int RemapColourProperty(int color, bool isBackgroundColor = false);

        /// <summary>
        /// Remaps all color properties in game from old color depth to a new color depth;
        /// for example: from palette mode to 32-bit mode, or other way.
        /// </summary>
        public static void RemapColourPropertiesOnDepthChange(Game game, GameColorDepth oldColorDepth)
        {
            RemapColourProperty remapColor = (color, isBg) => { return ColorMapper.RemapColourNumberToDepth(color, game.Palette, game.Settings.ColorDepth, oldColorDepth); };
            RemapColourProperties(game, remapColor );
        }

        /// <summary>
        /// Remaps color properties in particular Character from old color depth to a new color depth;
        /// for example: from palette mode to 32-bit mode, or other way.
        /// </summary>
        public static void RemapCharacterColours(Character character, Game game, GameColorDepth oldColorDepth)
        {
            RemapColourProperty remapColor = (color, isBg) => { return ColorMapper.RemapColourNumberToDepth(color, game.Palette, game.Settings.ColorDepth, oldColorDepth); };
            RemapColourProperties(character, remapColor);
        }

        /// <summary>
        /// Remaps color properties in particular GUI from old color depth to a new color depth;
        /// for example: from palette mode to 32-bit mode, or other way.
        /// </summary>
        public static void RemapGUIColours(GUI gui, Game game, GameColorDepth oldColorDepth)
        {
            RemapColourProperty remapColor = (color, isBg) => { return ColorMapper.RemapColourNumberToDepth(color, game.Palette, game.Settings.ColorDepth, oldColorDepth); };
            RemapColourProperties(gui, remapColor);
        }

        /// <summary>
        /// Remaps color properties in particular GUI control from old color depth to a new color depth;
        /// for example: from palette mode to 32-bit mode, or other way.
        /// </summary>
        public static void RemapGUIColours(GUIControl guiControl, Game game, GameColorDepth oldColorDepth)
        {
            RemapColourProperty remapColor = (color, isBg) => { return ColorMapper.RemapColourNumberToDepth(color, game.Palette, game.Settings.ColorDepth, oldColorDepth); };
            RemapColourProperties(guiControl, remapColor);
        }

        /// <summary>
        /// Remaps historical 16-bit R6G5B6 values to proper 32-bit ARGB.
        /// </summary>
        private static void RemapLegacyColourProperties(Game game)
        {
            RemapColourProperty remapColor = (color, isBg) => {
                return ColorMapper.RemapFromLegacyColourNumber(color, game.Palette, game.Settings.ColorDepth, isBg);
            };
            RemapColourProperties(game, remapColor);
        }

        /// <summary>
        /// Remaps 32-bit RGB color number to proper 32-bit ARGB.
        /// This method has a nuance: the background colors of value 0 are treated as "transparent",
        /// while foreground colors of value 0 are treated as "black".
        /// </summary>
        private static void RemapOpaqueColourProperties(Game game)
        {
            RemapColourProperty remapColor = (color, isBg) => {
                if (isBg && (color == 0))
                    return 0;
                return ColorMapper.MakeOpaque(color, game.Settings.ColorDepth);
            };
            RemapColourProperties(game, remapColor);
        }

        /// <summary>
        /// Remaps all color properties in game using provided delegate.
        /// </summary>
        private static void RemapColourProperties(Game game, RemapColourProperty remapColor)
        {
            var settings = game.Settings;
            settings.InventoryHotspotMarkerCrosshairColor = remapColor(settings.InventoryHotspotMarkerCrosshairColor);
            settings.InventoryHotspotMarkerDotColor = remapColor(settings.InventoryHotspotMarkerDotColor);

            foreach (var c in game.Characters)
            {
                RemapColourProperties(c, remapColor);
            }

            foreach (var gui in game.GUIs)
            {
                RemapColourProperties(gui, remapColor);
            }
        }

        private static void RemapColourProperties(Character character, RemapColourProperty remapColor)
        {
            character.SpeechColor = remapColor(character.SpeechColor);
        }

        private static void RemapColourProperties(GUI gui, RemapColourProperty remapColor)
        {
            gui.BackgroundColor = remapColor(gui.BackgroundColor, isBackgroundColor: true);
            if (gui is NormalGUI)
            {
                var ngui = gui as NormalGUI;
                ngui.BorderColor = remapColor(ngui.BorderColor, isBackgroundColor: true);
            }
            else if (gui is TextWindowGUI)
            {
                var tw = gui as TextWindowGUI;
                tw.TextColor = remapColor(tw.TextColor);
                // NOTE: TextWindowGUI.BorderColor currently internally maps to TextColor
            }

            foreach (var ctrl in gui.Controls)
            {
                RemapColourProperties(ctrl, remapColor);
            }
        }

        private static void RemapColourProperties(GUIControl guiControl, RemapColourProperty remapColor)
        {
            if (guiControl is GUIButton)
            {
                GUIButton but = guiControl as GUIButton;
                but.TextColor = remapColor(but.TextColor);
            }
            else if (guiControl is GUILabel)
            {
                GUILabel lab = guiControl as GUILabel;
                lab.TextColor = remapColor(lab.TextColor);
            }
            else if (guiControl is GUIListBox)
            {
                GUIListBox list = guiControl as GUIListBox;
                list.TextColor = remapColor(list.TextColor);
                list.SelectedTextColor = remapColor(list.SelectedTextColor);
                list.SelectedBackgroundColor = remapColor(list.SelectedBackgroundColor, isBackgroundColor: true);
            }
            else if (guiControl is GUITextBox)
            {
                GUITextBox textbox = guiControl as GUITextBox;
                textbox.TextColor = remapColor(textbox.TextColor);
            }
        }

        public void RunGameSetup()
        {
            RunGameEXE("--setup", false);
        }

        public void TestGame(bool withDebugger)
        {
            string exePath = Path.Combine(AGSEditor.DEBUG_OUTPUT_DIRECTORY, Factory.AGSEditor.BaseGameFileName + ".exe");
            string parameter = string.Empty;
                        
            if (withDebugger)
            {
                string logDebugger = Factory.ComponentController.FindComponent<DebugLogComponent>()?.GetCmdLineLogGroupsAndLevels();
                // debugger connection params
                parameter = logDebugger + " --enabledebugger " + Factory.AGSEditor.Debugger.InstanceIdentifier;
            }
            else if (Factory.AGSEditor.Settings.TestGameWindowStyle == TestGameWindowStyle.Windowed)
            {
                parameter = "--windowed";
            }
            else if (Factory.AGSEditor.Settings.TestGameWindowStyle == TestGameWindowStyle.FullScreen)
            {
                parameter = "--fullscreen";
            }
            _runningGameWithDebugger = withDebugger;
            // Pass both compiled dir and custom game data directories (point to where all supplemental data files are);
            // Command syntax is:
            //    --runfromide <INSTALLDIR> [OPT_PATH1:FILTER[,OPT_PATH2:FILTER[, ...]]]
            //
            // NOTE: OPT_PATHs and FILTERs must be encased in doublequotes, and separated by a single comma (no spaces).
            //
            parameter += " --runfromide" +
                " \"" + Path.Combine(AGSEditor.OUTPUT_DIRECTORY, BuildTargetWindows.WINDOWS_DIRECTORY) + "\" " +
                "\"" + Factory.AGSEditor.GameDirectory + "\":\"\"" + "," +
                "\"" + Path.Combine(Factory.AGSEditor.GameDirectory, FontsComponent.FONT_FILES_DIRECTORY) + "\":\"\"" + "," +
                "\"" + AudioComponent.AUDIO_CACHE_DIRECTORY + "\":\"audio\"" + "," +
                "\"" + SpeechComponent.SPEECH_DIRECTORY + "\":\"voice\"";

            // Explicit path to the file containing main game data,
            // this is to ensure that the engine won't try to scan other places
            parameter += " \"" + exePath + "\"";

            Factory.GUIController.ClearEngineLogMessages();

            RunEXEFile(exePath, parameter, true);

            if (withDebugger)
            {
                Factory.AGSEditor.Debugger.InitializeEngine(Factory.AGSEditor.CurrentGame, Factory.GUIController.TopLevelWindowHandle);
            }

        }

        private void RunGameEXE(string parameter, bool raiseEventOnExit)
        {
            string gameDirectory = Directory.GetCurrentDirectory();
            try
            {
                string exeName = Factory.AGSEditor.BaseGameFileName + ".exe";
                string exeDir = Path.Combine(AGSEditor.OUTPUT_DIRECTORY, BuildTargetWindows.WINDOWS_DIRECTORY);
                Directory.CreateDirectory(exeDir); // creates Windows directory if it does not exist
                Directory.SetCurrentDirectory(exeDir); // change into Windows directory to run setup

                RunEXEFile(exeName, parameter, raiseEventOnExit);
            }
            finally
            {
                Directory.SetCurrentDirectory(gameDirectory);
            }
        }

        private void RunEXEFile(string exeName, string parameter, bool raiseEventOnExit)
        {
            try
            {
                if (!File.Exists(exeName))
                {
                    throw new FileNotFoundException("Game EXE '" + exeName + "' has not been built. Use the Build EXE command and then try again.");
                }

                _testGameProcess = new Process();
                _testGameProcess.StartInfo.UseShellExecute = false;
                _testGameProcess.StartInfo.FileName = exeName;
                _testGameProcess.StartInfo.Arguments = parameter;
                if (raiseEventOnExit)
                {
                    _testGameProcess.EnableRaisingEvents = true;
                    _testGameProcess.Exited += _testGameProcess_Exited;
                }
                _testGameProcess.Start();
            }
            catch (Exception ex)
            {
                if (raiseEventOnExit)
                {
                    _testGameProcess_Exited(null, null);
                }
                throw ex;
            }
        }

        private void _testGameProcess_Exited(object sender, EventArgs e)
        {
            if (_runningGameWithDebugger)
            {
                Factory.AGSEditor.Debugger.EngineHasExited();
                _runningGameWithDebugger = false;
            }

            if (TestGameFinished != null)
            {
                int exitCode = -1;
                try
                {
                    // the ExitCode property will throw an exception
                    // if the process didn't start, in which case
                    // we use -1 as the exit code
                    exitCode = _testGameProcess.ExitCode;
                }
                catch (InvalidOperationException) { }

                TestGameFinished(exitCode);
            }

            _testGameProcess = null;
        }

        public Script RegenerateScriptHeader(Game game, Room currentRoom)
        {
            StringBuilder sb = new StringBuilder(10000);

            AppendCursorsToHeader(sb, game.Cursors);

            AppendFontsToHeader(sb, game.Fonts);

            AppendCharactersToHeader(sb, game.RootCharacterFolder, game);

            AppendAudioClipTypesToHeader(sb, game.AudioClipTypes);

            AppendAudioClipsToHeader(sb, game.RootAudioClipFolder);

            AppendInventoryToHeader(sb, game.InventoryItems);

            AppendDialogsToHeader(sb, game.Dialogs);

            AppendGUIsToHeader(sb, game.GUIs);

            AppendViewsToHeader(sb, game.RootViewFolder);

            if (currentRoom != null)
            {
                AppendRoomObjectsAndHotspotsToHeader(sb, currentRoom);
            }

            return new Script(AUTO_GENERATED_HEADER_NAME, sb.ToString(), true);
        }

        private void AppendRoomObjectsAndHotspotsToHeader(StringBuilder sb, Room room)
        {
            foreach (RoomObject obj in room.Objects)
            {
                if (obj.Name.Length > 0)
                {
                    sb.AppendLine("import readonly Object *" + obj.Name + ";");
                }
            }

            foreach (RoomHotspot hotspot in room.Hotspots)
            {
                if (hotspot.Name.Length > 0)
                {
                    sb.AppendLine("import readonly Hotspot *" + hotspot.Name + ";");
                }
            }
        }

        private void AppendInventoryToHeader(StringBuilder sb, IList<InventoryItem> items)
        {
            if (items.Count > 0)
            {
                // NOTE: there's always a dummy inv item at index 0
                sb.AppendLine(string.Format("import readonly InventoryItem *inventory[{0}];", items.Count + 1));

                foreach (InventoryItem item in items)
                {
                    if (item.Name.Length > 0)
                    {
                        sb.AppendLine("import readonly InventoryItem *" + item.Name + ";");
                    }
                }
            }
            else
            {
                // Declare a dummy array of 1 null pointer, prevent "undefined symbol" errors
                sb.AppendLine(string.Format("import readonly InventoryItem *inventory[1];"));
            }
        }

        private void AppendDialogsToHeader(StringBuilder sb, IList<Dialog> dialogs)
        {
            if (dialogs.Count > 0)
            {
                sb.AppendLine(string.Format("import readonly Dialog *dialog[{0}];", dialogs.Count));

                foreach (Dialog item in dialogs)
                {
                    if (item.Name.Length > 0)
                    {
                        sb.AppendLine("import readonly Dialog *" + item.Name + ";");
                    }
                }
            }
            else
            {
                // Declare a dummy array of 1 null pointer, prevent "undefined symbol" errors
                sb.AppendLine(string.Format("import readonly Dialog *dialog[1];"));
            }
        }

        private void AppendViewsToHeader(StringBuilder sb, ViewFolder viewFolder)
        {
            foreach (AGS.Types.View view in viewFolder.Views)
            {
                if (view.Name.Length > 0)
                {
                    sb.AppendLine("#define " + view.Name.ToUpperInvariant() + " " + view.ID);
                }
            }

            foreach (ViewFolder subFolder in viewFolder.SubFolders)
            {
                AppendViewsToHeader(sb, subFolder);
            }
        }

        private void AppendGUIsToHeader(StringBuilder sb, IList<GUI> guis)
        {
            if (guis.Count > 0)
            {
                sb.AppendLine(string.Format("import readonly GUI *gui[{0}];", guis.Count));

                foreach (GUI gui in guis)
                {
                    if (gui.Name.Length == 0)
                    {
                        continue;
                    }

                    sb.AppendLine("import readonly GUI *" + gui.Name + ";");

                    if (gui.Name.StartsWith("g"))
                    {
                        string guiMacroName = gui.Name.Substring(1).ToUpperInvariant();
                        sb.AppendLine(string.Format("#define {0} FindGUIID(\"{1}\")", guiMacroName, guiMacroName));
                    }

                    foreach (GUIControl control in gui.Controls)
                    {
                        if (control.Name.Length > 0)
                        {
                            sb.AppendLine("import readonly " + control.ScriptClassType + " *" + control.Name + ";");
                        }
                    }
                }
            }
            else
            {
                // Declare a dummy array of 1 null pointer, prevent "undefined symbol" errors
                sb.AppendLine(string.Format("import readonly GUI *gui[1];"));
            }
        }

        private void AppendAudioClipsToHeader(StringBuilder sb, AudioClipFolder clips)
        {
            foreach (AudioClip clip in clips.AllItemsFlat)
            {
                sb.AppendLine("import AudioClip *" + clip.ScriptName + ";");
            }
        }

        private void AppendCharactersToHeader(StringBuilder sb, CharacterFolder characters, Game game)
        {
            int charactersCount = characters.GetAllItemsCount();
            if (charactersCount > 0)
            {
                sb.AppendLine(string.Format("import readonly Character *character[{0}];", charactersCount));

                foreach (Character character in characters.AllItemsFlat)
                {
                    if (character.ScriptName.StartsWith("c") &&
                        (character.ScriptName.Length > 1))
                    {
                        string macroName = character.ScriptName.Substring(1).ToUpperInvariant();
                        // only create the legacy #define if it doesn't start with 0-9
                        // (eg. c500 would cause error)
                        if (!Char.IsDigit(macroName[0]))
                        {
                            sb.AppendLine("#define " + macroName + " " + character.ID);
                        }
                    }
                    if (character.ScriptName.Length > 0)
                    {
                        sb.AppendLine("import readonly Character *" + character.ScriptName + ";");
                    }
                }
            }
            else
            {
                // Declare a dummy array of 1 null pointer, prevent "undefined symbol" errors
                sb.AppendLine(string.Format("import readonly Character *character[1];"));
            }
        }

        private void AppendCursorsToHeader(StringBuilder sb, IList<MouseCursor> cursors)
        {
            sb.AppendLine("enum CursorMode {");
            bool firstCursor = true;
            foreach (MouseCursor cursor in cursors)
            {
                string cursorName = cursor.ScriptID;
                if (cursorName.Length > 0)
                {
                    if (!firstCursor)
                    {
                        sb.AppendLine(",");
                    }
                    sb.Append("  " + cursorName + " = " + cursor.ID);
                    firstCursor = false;
                }
            }
            if (firstCursor)
            {
                // no cursors, make sure the enum has something in it
                sb.Append("eDummyCursor__ = 99  // $AUTOCOMPLETEIGNORE$ ");
            }
            sb.AppendLine();
            sb.AppendLine("};");
        }

        private void AppendFontsToHeader(StringBuilder sb, IList<AGS.Types.Font> fonts)
        {
            sb.AppendLine("enum FontType {");
            sb.Append("  eNullFont = -1");
            foreach (AGS.Types.Font font in fonts)
            {
                string fontName = font.ScriptID;
                if (fontName.Length > 0)
                {
                    sb.AppendLine(",");
                    sb.Append("  " + fontName + " = " + font.ID);
                }
            }
            sb.AppendLine();
            sb.AppendLine("};");
        }

        private void AppendAudioClipTypesToHeader(StringBuilder sb, IList<AGS.Types.AudioClipType> clipTypes)
        {
            sb.AppendLine("enum AudioType {");
            bool firstType = true;
            foreach (AGS.Types.AudioClipType clipType in clipTypes)
            {
                string scriptName = clipType.ScriptID;
                if (scriptName.Length > 0)
                {
                    if (!firstType)
                    {
                        sb.AppendLine(",");
                    }
                    sb.Append("  " + scriptName + " = " + clipType.TypeID);
                    firstType = false;
                }
            }
            if (firstType)
            {
                // no clip types, make sure the enum has something in it
                sb.Append("eDummyAudioType__ = 99  // $AUTOCOMPLETEIGNORE$ ");
            }
            sb.AppendLine();
            sb.AppendLine("};");
        }

        /// <summary>
        /// FunctionLocation tells the location of a script function in script.
        /// </summary>
        public struct FunctionLocation
        {
            public string Name;
            public string ScriptName;
            public int LineNumber;

            public FunctionLocation(string name, string scriptName, int lineNumber)
            {
                Name = name;
                ScriptName = scriptName;
                LineNumber = lineNumber;
            }
        }

        /// <summary>
        /// Scans corresponding script module looking for the interaction functions.
        /// Creates an array of FunctionLocations, which indexes correspond to interaction indexes.
        /// If checkDefaultMatches is true, then also scans for the default event function names,
        /// otherwise only scans for the function names actually assigned to the interactions.
        /// Returns null on any error.
        /// </summary>
        public FunctionLocation?[] FindInteractionHandlers(string objectName, Interactions interactions, bool checkDefaultMatches)
        {
            if (string.IsNullOrEmpty(interactions.ScriptModule))
                return null;

            // We generate default function names for those interactions that *DO NOT* have a function linked.
            var functionNames = checkDefaultMatches ?
                interactions.ScriptFunctionNames
                    .Select((f, i) => { return !string.IsNullOrEmpty(f) ? f : $"{objectName}_{interactions.FunctionSuffixes[i]}"; })
                    .ToArray()
                : interactions.ScriptFunctionNames;

            return FindEventHandlers(interactions.ScriptModule, functionNames);
        }

        /// <summary>
        /// Scans the script module looking for the list of functions.
        /// Creates an array of FunctionLocations, which indexes correspond to the input function name indexes.
        /// Returns null on any error.
        /// <returns></returns>
        public FunctionLocation?[] FindEventHandlers(string scriptName, string[] functionNames)
        {
            Script script = Factory.AGSEditor.CurrentGame.ScriptsAndHeaders.GetScriptByFilename(scriptName);
            if (script == null || script.AutoCompleteData == null || !script.AutoCompleteData.Populated)
                return null;

            return FindEventHandlers(scriptName, script.AutoCompleteData, functionNames);
        }

        public FunctionLocation?[] FindEventHandlers(string scriptName, ScriptAutoCompleteData scriptData, string[] functionNames)
        {
            // FIXME: cannot get function line from ScriptToken.StartsAtCharacterIndex here
            // need to either add this to autocomplete, or rescan the file... which is going to be a lot of extra work
            return functionNames
                .Select(f => {
                    var func = scriptData.FindFunction(f);
                    return func != null ? new FunctionLocation(f, scriptName, 0) : (FunctionLocation?)null;
                })
                .ToArray();
        }

        /// <summary>
        /// Converts all separate game files which may contain text from one encoding
        /// to another. This is done by loading and resaving them, and may take time
        /// depending on the size of the project.
        /// </summary>
        /// <param name="oldEnc"></param>
        /// <param name="newEnc"></param>
        public void ConvertAllGameTexts(Encoding oldEnc, Encoding newEnc)
        {
            // Convert all scripts
            foreach (var script in Factory.AGSEditor.CurrentGame.ScriptsAndHeaders)
            {
                // TODO: this is ugly, make TextEncoding non-static per script property?
                // or pass into Load/Save method (but some more changes are necessary)
                Script.TextEncoding = oldEnc;
                script.Header.LoadFromDisk();
                script.Script.LoadFromDisk();
                Script.TextEncoding = newEnc;
                script.Header.Modified = true;
                script.Header.SaveToDisk();
                script.Script.Modified = true;
                script.Script.SaveToDisk();
            }
            // Convert all room scripts
            foreach (var room in Factory.AGSEditor.CurrentGame.Rooms)
            {
                Script.TextEncoding = oldEnc;
                room.LoadScript();
                Script.TextEncoding = newEnc;
                room.Script.Modified = true;
                room.Script.SaveToDisk();
                room.UnloadScript();
            }
            // Save game with a new encoding
            if (Factory.GUIController.InvokeRequired)
            {
                Factory.GUIController.Invoke(new Func<bool>(Factory.AGSEditor.SaveGameFiles));
            }
            else
            {
                Factory.AGSEditor.SaveGameFiles();
            }
        }

        /// <summary>
        /// Resizes all GUI from one game resolution to another.
        /// </summary>
        public void ResizeAllGUIs(System.Drawing.Size oldResolution, System.Drawing.Size newResolution)
        {
            int oldWidth = oldResolution.Width;
            int oldHeight = oldResolution.Height;
            int newWidth = newResolution.Width;
            int newHeight = newResolution.Height;

            foreach (GUI gui in Factory.AGSEditor.CurrentGame.RootGUIFolder.AllItemsFlat)
            {
                NormalGUI theGui = gui as NormalGUI;
                if (theGui != null)
                {
                    theGui.Width = Math.Max((theGui.Width * newWidth) / oldWidth, 1);
                    theGui.Height = Math.Max((theGui.Height * newHeight) / oldHeight, 1);
                    theGui.Left = (theGui.Left * newWidth) / oldWidth;
                    theGui.Top = (theGui.Top * newHeight) / oldHeight;

                    foreach (GUIControl control in theGui.Controls)
                    {
                        control.Width = Math.Max((control.Width * newWidth) / oldWidth, 1);
                        control.Height = Math.Max((control.Height * newHeight) / oldHeight, 1);
                        control.Left = (control.Left * newWidth) / oldWidth;
                        control.Top = (control.Top * newHeight) / oldHeight;
                    }
                }
            }
        }
    }
}
