#include <iostream>  
#include <fstream>
#include <string>
#include <map>
#include <fstream>
#include <streambuf>


#include "script/cc_options.h"
#include "gtest/gtest.h"
#include "script/cs_parser.h"
#include "script/cc_symboltable.h"
#include "script/cc_internallist.h"


/* This file is for Bytecode compatibility tests ONLY, i.e. for testing that
   the rewritten parser emits exactly the same Bytecode as the original
   one. Testing for programs that won't compile should be done elsewhere IMHO.
   Reason: Later on, when we trust the rewritten compiler, we'll want
   to extend it in such a way that it emits _different_ codes from the
   original compiler. Then we can simply throw away those tests in this
   file that no longer work.

   1. Head over to a release version that has the old compiler.
   2. Copy a template (search for "PROTOTYPE") to the end of the file.
   3. Change test name and file name in the prototype.
   4. Add in an AGS program that will be tested.
   5. Uncomment the "WriteOutput(" line of the test, run the test.
      The parser should not emit an error (do these tests elsewhere).
   6. A file has now been written. Copy its content immediately above
      the closing brace of the test. This will copy the code that
      is generated by the old compiler, byte-for-byte, into the googletest.
   7. Comment out the "WriteOutput(" line again (important).
   8. Copy the test to the clipboard.
   9. Head over to the version that has the rewritten compiler.
   10. Paste the test from the clipboard to the testfile of this version.
   11. Run the test.
       If the parser emits an error, the test will fail.
       If the parser emits Bytecode that is different in any way,
       the test will point out the first code that is different and fail.

   If a test generates wrong code, often a good way to debug it is as follows:
   - Uncomment the "WriteOutput(" line and run the test; now you have the bytes
     that the _new_ compiler emits in the file. Compare it by hand to the code
     that's in the test. See what the problem is: Has the new compiler left
     opcodes out, or has it added some in? Has it changed a single value somewhere?
   - Find the line with "iii" in cs_compiledscript.cpp and put a breakpoint there.
     (Uncomment that piece of code if it is commented out.)
   - Modify that piece of code so that the debugger will break as soon as the
     compiler generates the last byte that is still correct.
   - Debug test:
     Trace along from the breakpoint and find the point where the logic fails.

   But bear in mind:
   - Sometimes the compiler emits some code, then rips it out and stashes it away,
     then, later on, retrieves it and emits it again.
   - Sometimes the compiler emits some code value (usually 0), then
     patches it afterwards.
   In both cases, the logic will _not_ pass through function write_cmd()
   when the code is touched the second time! These are the hard cases to debug. :)
*/


// NOTE! If any "WriteOutput" lines in this file are uncommented, then the 
//  #define below _must_ be changed to a local writable temp dir. 
// (If you only want to run the tests to see if any tests fail, you do NOT 
// need that dir and you do NOT need any local files whatsoever.)
# define LOCAL_PATH "C:\\TEMP\\"

extern void clear_error();
extern const char *last_seen_cc_error();
extern ccCompiledScript *newScriptFixture();

// from cs_parser_test.cpp, provide "ready-made" code chunks to be included in tests
extern char g_Input_Bool[], g_Input_String[];

std::string Esc(const char ch)
{
    static const char *tohex = "0123456789abcdef";

    if (ch >= ' ' && ch <= 126)
    {
        return std::string(1, ch);
    }

    switch (ch)
    {
    default:
    {
        std::string ret = "\\x";
        ret.push_back(tohex[ch / 16]);
        ret.push_back(tohex[ch % 16]);
        return ret;
    }
    case '\a': return "\\a";
    case '\b': return "\\b";
    case '\f': return "\\f";
    case '\n': return "\\n";
    case '\r': return "\\r";
    case '\v': return "\\v";
    case '\'': return "\\\'";
    case '\"': return "\\\"";
    case '\\': return "\\\\";
    }
}

std::string EscapeString(const char *in)
{
    if (in == nullptr)
        return "0";

    std::string ret = "";
    size_t const in_len = strlen(in);
    for (size_t idx = 0; idx < in_len; idx++)
        ret += Esc(in[idx]);
    return "\"" + ret + "\"";
}

void WriteOutputCode(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t codesize = " << scrip->codesize << ";" << std::endl;
    of << "EXPECT_EQ(codesize, scrip->codesize);" << std::endl << std::endl;

    if (scrip->codesize == 0)
        return;

    of << "intptr_t code[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->codesize; idx++)
    {
        of.width(4);
        of << scrip->code[idx] << ", ";
        if (idx % 8 == 3) of << "        ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " -999 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < codesize; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->codesize) break;" << std::endl;
    of << "     std::string prefix = \"code[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + std::to_string(code[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->code[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;

}

void WriteOutputFixups(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t numfixups = " << scrip->numfixups << ";" << std::endl;
    of << "EXPECT_EQ(numfixups, scrip->numfixups);" << std::endl << std::endl;

    if (scrip->numfixups == 0)
        return;

    of << "intptr_t fixups[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->numfixups; idx++)
    {
        of.width(4);
        of << scrip->fixups[idx] << ", ";
        if (idx % 8 == 3) of << "      ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " -999 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numfixups; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numfixups) break;" << std::endl;
    of << "     std::string prefix = \"fixups[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string   is_val = prefix + std::to_string(fixups[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->fixups[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;

    of << "char fixuptypes[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->numfixups; idx++)
    {
        of.width(3);
        of << static_cast<int>(scrip->fixuptypes[idx]) << ", ";
        if (idx % 8 == 3) of << "   ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " '\\0' " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numfixups; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numfixups) break;" << std::endl;
    of << "     std::string prefix = \"fixuptypes[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string   is_val = prefix + std::to_string(fixuptypes[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputImports(std::ofstream &of, ccCompiledScript *scrip)
{
    // Unfortunately, imports can contain empty strings that
    // mustn't be counted. So we can't just believe numimports,
    // and we can't check against scrip->numimports.
    size_t realNumImports = 0;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
        if (0 != strcmp(scrip->imports[idx], ""))
            ++realNumImports;

    of << "const int numimports = " << realNumImports << ";" << std::endl;

    of << "std::string imports[] = {" << std::endl;

    size_t linelen = 0;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;

        std::string item = EscapeString(scrip->imports[idx]);
        item += ",";
        item += std::string(15 - (item.length() % 15), ' ');
        of << item;
        linelen += item.length();
        if (linelen >= 75)
        {
            linelen = 0;
            of << "// " << idx << std::endl;
        }
    }
    of << " \"[[SENTINEL]]\" " << std::endl << "};" << std::endl << std::endl;

    of << "int idx2 = -1;" << std::endl;
    of << "for (size_t idx = 0; idx < scrip->numimports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (!strcmp(scrip->imports[idx], \"\"))" << std::endl;
    of << "         continue;" << std::endl;
    of << "     idx2++;" << std::endl;
    of << "     ASSERT_LT(idx2, numimports);" << std::endl;
    of << "     std::string prefix = \"imports[\";" << std::endl;
    // Note that the prefix has to be identical for is_val and test_val,
    // or ASSERT_EQ will always fail.
    of << "     prefix += std::to_string(idx2) + \"] == \";" << std::endl;
    of << "     std::string is_val   = prefix + scrip->imports[idx];" << std::endl;
    of << "     std::string test_val = prefix + imports[idx2];" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputExports(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t numexports = " << scrip->numexports << ";" << std::endl;
    of << "EXPECT_EQ(numexports, scrip->numexports);" << std::endl << std::endl;

    if (scrip->numexports == 0)
        return;

    of << "std::string exports[] = {" << std::endl;

    size_t linelen = 0;
    for (size_t idx = 0; idx < scrip->numexports; idx++)
    {
        std::string item = EscapeString(scrip->exports[idx]);
        item += ",";
        item += std::string(6 - (item.length() % 6), ' ');
        of << item;
        linelen += item.length();
        if (linelen >= 50)
        {
            linelen = 0;
            of << "// " << idx << std::endl;
        }
    }
    of << " \"[[SENTINEL]]\" " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numexports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numexports) break;" << std::endl;
    of << "     std::string prefix = \"exports[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + exports[idx];" << std::endl;
    of << "     std::string test_val = prefix + scrip->exports[idx];" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;


    of << "int32_t export_addr[] = {" << std::endl;

    for (size_t idx = 0; idx < scrip->numexports; idx++)
    {
        of.setf(std::ios::hex, std::ios::basefield);
        of.setf(std::ios::showbase);
        of.width(4);
        of << scrip->export_addr[idx] << ", ";
        if (idx % 4 == 1) of << "   ";
        if (idx % 8 == 3)
        {
            of.setf(std::ios::dec, std::ios::basefield);
            of.unsetf(std::ios::showbase);
            of.width(0);
            of << "// " << idx;
            of << std::endl;
        }
    }

    of.setf(std::ios::dec, std::ios::basefield);
    of.unsetf(std::ios::showbase);
    of.width(0);

    of << " 0 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numexports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numexports) break;" << std::endl;
    of << "     std::string prefix = \"export_addr[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val   = prefix + std::to_string(export_addr[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->export_addr[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputStrings(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t stringssize = " << scrip->stringssize << ";" << std::endl;
    of << "EXPECT_EQ(stringssize, scrip->stringssize);" << std::endl << std::endl;

    if (scrip->stringssize == 0)
        return;

    of << "char strings[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->stringssize; idx++)
    {
        std::string out = "";
        if (scrip->strings[idx] == 0)
            out = "  0";
        else
            out += '\'' + Esc(scrip->strings[idx]) + '\'';
        of << out << ",  ";
        if (idx % 8 == 3) of << "        ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << "'\\0'" << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < stringssize; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->stringssize) break;" << std::endl;
    of << "     std::string prefix = \"strings[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + std::to_string(strings[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->strings[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl;

}

void WriteOutput(char *fname, ccCompiledScript *scrip)
{
    std::string path = LOCAL_PATH;
    std::ofstream of;
    of.open(path.append(fname).append(".txt"));

    WriteOutputCode(of, scrip);
    WriteOutputFixups(of, scrip);
    WriteOutputImports(of, scrip);
    WriteOutputExports(of, scrip);
    WriteOutputStrings(of, scrip);

    of.close();
}

void WriteReducedOutput(char *fname, ccCompiledScript *scrip)
{
    std::string path = LOCAL_PATH;
    std::ofstream of;
    of.open(path.append(fname).append(".txt"));

    WriteOutputCode(of, scrip);
    WriteOutputFixups(of, scrip);

    of.close();
}

/*    PROTOTYPE

TEST(Compatibility, P_r_o_t_o_t_y_p_e) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo(int a)      \n\
        {                   \n\
            return a*a;     \n\
        }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("P_r_o_t_o_t_y_p_e", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

}
*/

TEST(Compatibility, SimpleVoidFunction) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void Foo()          \n\
        {                   \n\
            return;         \n\
        }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("SimpleVoidFunction", scrip);
    // hand-checked Bytecode
    const size_t codesize = 11;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,   31,    3,    6,    // 7
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, SimpleIntFunction) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo()      \n\
    {                  \n\
        return 15;     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("SimpleIntFunction", scrip);
    // hand-checked Bytecode
    const size_t codesize = 11;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,   31,    3,    6,    // 7
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IntFunctionLocalV) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo()      \n\
    {                  \n\
        int a = 15;    \n\
        return a;     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    WriteOutput("IntFunctionLocalV", scrip);
    // hand-checked Bytecode
    const size_t codesize = 29;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   51,    4,    7,    // 15
       3,    2,    1,    4,           31,    6,    6,    3,    // 23
       0,    2,    1,    4,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IntFunctionParam) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo(int a) \n\
    {                  \n\
        return a;      \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IntFunctionParam", scrip);
    // hand-checked Bytecode
    const size_t codesize = 12;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   31,    3,    // 7
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IntFunctionGlobalV) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int a = 15;    \n\
        int Foo( )     \n\
    {                  \n\
        return a;      \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IntFunctionGlobalV", scrip);
    // hand-checked Bytecode
    const size_t codesize = 13;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    2,            0,    7,    3,   31,    // 7
       3,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, FloatExpr1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        float a = 15.0;     \n\
        float Foo()         \n\
        {                   \n\
            float f = 3.14; \n\
            return a + f;   \n\
        }                   \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FloatExpr1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 44;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,         1078523331,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    6,    2,    0,    // 15
       7,    3,   29,    3,           51,    8,    7,    3,    // 23
      30,    4,   57,    4,            3,    3,    4,    3,    // 31
       2,    1,    4,   31,            6,    6,    3,    0,    // 39
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      15,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, FloatExpr2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        float a = 15.0;           \n\
        float Foo()               \n\
    {                             \n\
        float b = 22.2;           \n\
        int E1 = (3.14 < 1.34) == 1;         \n\
        short E2 = 0 == (1234.5 > 5.0) && 1; \n\
        long E3 = a <= 44.4;      \n\
        char E4 = 55.5 >= 44.4;   \n\
        int E5 = (((a == b) || (a != b))); \n\
        return a - b * (a / b);   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FloatExpr2", scrip);
    // hand-checked Bytecode 
    const size_t codesize = 270;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,         1102158234,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    6,    3, 1078523331,    // 15
      29,    3,    6,    3,         1068205343,   30,    4,   60,    // 23
       4,    3,    3,    4,            3,   29,    3,    6,    // 31
       3,    1,   30,    4,           15,    4,    3,    3,    // 39
       4,    3,    3,    1,            2,    8,    3,    1,    // 47
       1,    4,    6,    3,            0,   29,    3,    6,    // 55
       3, 1150963712,   29,    3,            6,    3, 1084227584,   30,    // 63
       4,   59,    4,    3,            3,    4,    3,   30,    // 71
       4,   15,    4,    3,            3,    4,    3,   28,    // 79
      13,   29,    3,    6,            3,    1,   30,    4,    // 87
      21,    4,    3,    3,            4,    3,    3,    1,    // 95
       2,   27,    3,    1,            1,    2,    6,    2,    // 103
       0,    7,    3,   29,            3,    6,    3, 1110546842,    // 111
      30,    4,   62,    4,            3,    3,    4,    3,    // 119
       3,    1,    2,    8,            3,    1,    1,    4,    // 127
       6,    3, 1113456640,   29,            3,    6,    3, 1110546842,    // 135
      30,    4,   61,    4,            3,    3,    4,    3,    // 143
       3,    1,    2,   26,            3,    1,    1,    1,    // 151
       6,    2,    0,    7,            3,   29,    3,   51,    // 159
      19,    7,    3,   30,            4,   15,    4,    3,    // 167
       3,    4,    3,   70,           29,   29,    3,    6,    // 175
       2,    0,    7,    3,           29,    3,   51,   23,    // 183
       7,    3,   30,    4,           16,    4,    3,    3,    // 191
       4,    3,   30,    4,           22,    4,    3,    3,    // 199
       4,    3,    3,    1,            2,    8,    3,    1,    // 207
       1,    4,    6,    2,            0,    7,    3,   29,    // 215
       3,   51,   23,    7,            3,   29,    3,    6,    // 223
       2,    0,    7,    3,           29,    3,   51,   31,    // 231
       7,    3,   30,    4,           56,    4,    3,    3,    // 239
       4,    3,   30,    4,           55,    4,    3,    3,    // 247
       4,    3,   30,    4,           58,    4,    3,    3,    // 255
       4,    3,    2,    1,           19,   31,    6,    6,    // 263
       3,    0,    2,    1,           19,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
     104,  154,  177,  212,        225,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IfThenElse1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo()               \n\
    {                       \n\
        int a = 15 - 4 * 2; \n\
        if (a < 5)          \n\
            a >>= 2;        \n\
        else                \n\
            a <<= 3;        \n\
        return a;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfThenElse1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 108;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,   29,    3,    6,    // 7
       3,    4,   29,    3,            6,    3,    2,   30,    // 15
       4,    9,    4,    3,            3,    4,    3,   30,    // 23
       4,   12,    4,    3,            3,    4,    3,    3,    // 31
       1,    2,    8,    3,            1,    1,    4,   51,    // 39
       4,    7,    3,   29,            3,    6,    3,    5,    // 47
      30,    4,   18,    4,            3,    3,    4,    3,    // 55
      28,   18,    6,    3,            2,   29,    3,   51,    // 63
       8,    7,    3,   30,            4,   44,    3,    4,    // 71
       8,    3,   31,   16,            6,    3,    3,   29,    // 79
       3,   51,    8,    7,            3,   30,    4,   43,    // 87
       3,    4,    8,    3,           51,    4,    7,    3,    // 95
       2,    1,    4,   31,            6,    6,    3,    0,    // 103
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, IfThenElse2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo()               \n\
    {                       \n\
        int a = 15 - 4 % 2; \n\
        if (a >= 5) {       \n\
            a -= 2;         \n\
        } else {            \n\
            a += 3;         \n\
        }                   \n\
        return a;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfThenElse2", scrip);
    // hand-checked Bytecode
    const size_t codesize = 108;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,   29,    3,    6,    // 7
       3,    4,   29,    3,            6,    3,    2,   30,    // 15
       4,   40,    4,    3,            3,    4,    3,   30,    // 23
       4,   12,    4,    3,            3,    4,    3,    3,    // 31
       1,    2,    8,    3,            1,    1,    4,   51,    // 39
       4,    7,    3,   29,            3,    6,    3,    5,    // 47
      30,    4,   19,    4,            3,    3,    4,    3,    // 55
      28,   18,    6,    3,            2,   29,    3,   51,    // 63
       8,    7,    3,   30,            4,   12,    3,    4,    // 71
       8,    3,   31,   16,            6,    3,    3,   29,    // 79
       3,   51,    8,    7,            3,   30,    4,   11,    // 87
       3,    4,    8,    3,           51,    4,    7,    3,    // 95
       2,    1,    4,   31,            6,    6,    3,    0,    // 103
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, While) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    char c = 'x';             \n\
    int Foo(int i, float f)   \n\
    {                         \n\
        int sum = 0;          \n\
        while (c >= 0)        \n\
        {                     \n\
            sum += (500 & c); \n\
            c--;              \n\
            if (c == 1) continue; \n\
        }                     \n\
        return sum;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("While", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 116;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    6,    2,    0,    // 15
      24,    3,   29,    3,            6,    3,    0,   30,    // 23
       4,   19,    4,    3,            3,    4,    3,   28,    // 31
      68,    6,    3,  500,           29,    3,    6,    2,    // 39
       0,   24,    3,   30,            4,   13,    4,    3,    // 47
       3,    4,    3,   29,            3,   51,    8,    7,    // 55
       3,   30,    4,   11,            3,    4,    8,    3,    // 63
       6,    2,    0,   24,            3,    2,    3,    1,    // 71
      26,    3,    6,    2,            0,   24,    3,   29,    // 79
       3,    6,    3,    1,           30,    4,   15,    4,    // 87
       3,    3,    4,    3,           28,    5,    6,    3,    // 95
       0,   31,  -86,   31,          -88,   51,    4,    7,    // 103
       3,    2,    1,    4,            5,    6,    3,    0,    // 111
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      15,   40,   66,   76,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}



TEST(Compatibility, DoNCall) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    char c = 'x';             \n\
    int Foo(int i)            \n\
    {                         \n\
        int sum = 0;          \n\
        do                    \n\
        {                     \n\
            sum -= (500 | c); \n\
            c--;              \n\
        }                     \n\
        while (c > 0);        \n\
        return sum;           \n\
    }                         \n\
                              \n\
    int Bar(int x)            \n\
    {                         \n\
        return Foo(x^x);      \n\
    }                         \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("DoNCall", scrip);
    // hand-checked bytecode
    const size_t codesize = 130;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   31,    2,   31,    // 15
      61,    6,    3,  500,           29,    3,    6,    2,    // 23
       0,   24,    3,   30,            4,   14,    4,    3,    // 31
       3,    4,    3,   29,            3,   51,    8,    7,    // 39
       3,   30,    4,   12,            3,    4,    8,    3,    // 47
       6,    2,    0,   24,            3,    2,    3,    1,    // 55
      26,    3,    6,    2,            0,   24,    3,   29,    // 63
       3,    6,    3,    0,           30,    4,   17,    4,    // 71
       3,    3,    4,    3,           70,  -61,   51,    4,    // 79
       7,    3,    2,    1,            4,   31,    6,    6,    // 87
       3,    0,    2,    1,            4,    5,   38,   94,    // 95
      51,    8,    7,    3,           29,    3,   51,   12,    // 103
       7,    3,   30,    4,           41,    4,    3,    3,    // 111
       4,    3,   29,    3,            6,    3,    0,   23,    // 119
       3,    2,    1,    4,           31,    3,    6,    3,    // 127
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      24,   50,   60,  118,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   2,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, DoUnbracedIf) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    void noloopcheck main()   \n\
    {                         \n\
        int sum = 0;          \n\
        do                    \n\
            if (sum < 100)    \n\
                sum += 10;    \n\
            else              \n\
                break;        \n\
        while (sum >= -1);    \n\
    }                         \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("DoUnbracedIf", scrip);
    // hand-checked bytecode 
    const size_t codesize = 86;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   68,    6,            3,    0,    3,    1,    // 7
       2,    8,    3,    1,            1,    4,   31,    2,    // 15
      31,   61,   51,    4,            7,    3,   29,    3,    // 23
       6,    3,  100,   30,            4,   18,    4,    3,    // 31
       3,    4,    3,   28,           18,    6,    3,   10,    // 39
      29,    3,   51,    8,            7,    3,   30,    4,    // 47
      11,    3,    4,    8,            3,   31,    5,    6,    // 55
       3,    0,   31,  -44,           51,    4,    7,    3,    // 63
      29,    3,    6,    3,           -1,   30,    4,   19,    // 71
       4,    3,    3,    4,            3,   70,  -61,    6,    // 79
       3,    0,    2,    1,            4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, For1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int loop;                       \n\
    int Foo(int i, float f)         \n\
    {                               \n\
        for (loop = 0; loop < 10; loop += 3)  \n\
        {                           \n\
            int sum = loop - 4 - 7; \n\
            if (loop == 6) break;   \n\
        }                           \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 128;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    6,    2,    0,    // 7
       8,    3,    6,    2,            0,    7,    3,   29,    // 15
       3,    6,    3,   10,           30,    4,   18,    4,    // 23
       3,    3,    4,    3,           28,   89,    6,    2,    // 31
       0,    7,    3,   29,            3,    6,    3,    4,    // 39
      30,    4,   12,    4,            3,    3,    4,    3,    // 47
      29,    3,    6,    3,            7,   30,    4,   12,    // 55
       4,    3,    3,    4,            3,    3,    1,    2,    // 63
       8,    3,    1,    1,            4,    6,    2,    0,    // 71
       7,    3,   29,    3,            6,    3,    6,   30,    // 79
       4,   15,    4,    3,            3,    4,    3,   28,    // 87
       8,    2,    1,    4,            6,    3,    0,   31,    // 95
     -69,    2,    1,    4,            6,    3,    3,   29,    // 103
       3,    6,    2,    0,            7,    3,   30,    4,    // 111
      11,    3,    4,    8,            3,   31, -109,    6,    // 119
       3,    0,   31,    3,            6,    3,    0,    5,    // 127
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   12,   32,   71,        107,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, For2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)         \n\
    {                               \n\
        int lp, sum;                \n\
        for (; ; lp += 1)           \n\
            sum += lp;              \n\
        for ( ;; )                  \n\
            sum -= lp;              \n\
        for (; lp < 2; lp += 3)     \n\
            sum *= lp;              \n\
        for (; lp < 4; )            \n\
            sum /= lp;              \n\
        for (lp = 5; ; lp += 6)     \n\
            sum /= lp;              \n\
        for (int loop = 7; ; )      \n\
            sum &= loop;            \n\
        for (int loop = 8; loop < 9; )  \n\
            sum |= loop;            \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For2", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 326;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    3,    1,            2,   63,    4,    1,    // 15
       1,    4,    6,    3,            1,   28,   35,   51,    // 23
       8,    7,    3,   29,            3,   51,    8,    7,    // 31
       3,   30,    4,   11,            3,    4,    8,    3,    // 39
       6,    3,    1,   29,            3,   51,   12,    7,    // 47
       3,   30,    4,   11,            3,    4,    8,    3,    // 55
      31,  -40,    6,    3,            1,   28,   19,   51,    // 63
       8,    7,    3,   29,            3,   51,    8,    7,    // 71
       3,   30,    4,   12,            3,    4,    8,    3,    // 79
      31,  -24,   51,    8,            7,    3,   29,    3,    // 87
       6,    3,    2,   30,            4,   18,    4,    3,    // 95
       3,    4,    3,   28,           35,   51,    8,    7,    // 103
       3,   29,    3,   51,            8,    7,    3,   30,    // 111
       4,    9,    3,    4,            8,    3,    6,    3,    // 119
       3,   29,    3,   51,           12,    7,    3,   30,    // 127
       4,   11,    3,    4,            8,    3,   31,  -54,    // 135
      51,    8,    7,    3,           29,    3,    6,    3,    // 143
       4,   30,    4,   18,            4,    3,    3,    4,    // 151
       3,   28,   19,   51,            8,    7,    3,   29,    // 159
       3,   51,    8,    7,            3,   30,    4,   10,    // 167
       3,    4,    8,    3,           31,  -38,    6,    3,    // 175
       5,   51,    8,    8,            3,    6,    3,    1,    // 183
      28,   35,   51,    8,            7,    3,   29,    3,    // 191
      51,    8,    7,    3,           30,    4,   10,    3,    // 199
       4,    8,    3,    6,            3,    6,   29,    3,    // 207
      51,   12,    7,    3,           30,    4,   11,    3,    // 215
       4,    8,    3,   31,          -40,    6,    3,    7,    // 223
       3,    1,    2,    8,            3,    1,    1,    4,    // 231
       6,    3,    1,   28,           19,   51,    4,    7,    // 239
       3,   29,    3,   51,           12,    7,    3,   30,    // 247
       4,   13,    3,    4,            8,    3,   31,  -24,    // 255
       2,    1,    4,    6,            3,    8,    3,    1,    // 263
       2,    8,    3,    1,            1,    4,   51,    4,    // 271
       7,    3,   29,    3,            6,    3,    9,   30,    // 279
       4,   18,    4,    3,            3,    4,    3,   28,    // 287
      19,   51,    4,    7,            3,   29,    3,   51,    // 295
      12,    7,    3,   30,            4,   14,    3,    4,    // 303
       8,    3,   31,  -38,            2,    1,    4,    6,    // 311
       3,    0,    2,    1,            8,   31,    6,    6,    // 319
       3,    0,    2,    1,            8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, For3) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct           \n\
    {                               \n\
        float Payload[1];           \n\
    };                              \n\
    Struct *S;                      \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        for (Struct *loop; ;)       \n\
        {                           \n\
            return ((loop == S));   \n\
        }                           \n\
        return -7;                  \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For3", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 63;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    6,    3,            1,   28,   33,   51,    // 15
       4,   48,    3,   29,            3,    6,    2,    0,    // 23
      48,    3,   30,    4,           15,    4,    3,    3,    // 31
       4,    3,   29,    3,           51,    8,   49,   30,    // 39
       3,    2,    1,    4,           31,   16,   31,  -38,    // 47
      51,    4,   49,    2,            1,    4,    6,    3,    // 55
      -7,   31,    3,    6,            3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      23,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, For4) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    void main()                     \n\
    {                               \n\
        for (int loop = 0; loop < 10; loop++)  \n\
            if (loop == 5)          \n\
                continue;           \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For4", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 83;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   51,    4,    7,    // 15
       3,   29,    3,    6,            3,   10,   30,    4,    // 23
      18,    4,    3,    3,            4,    3,   28,   44,    // 31
      51,    4,    7,    3,           29,    3,    6,    3,    // 39
       5,   30,    4,   15,            4,    3,    3,    4,    // 47
       3,   28,   14,   51,            4,    7,    3,    1,    // 55
       3,    1,    8,    3,            6,    3,    0,   31,    // 63
     -52,   51,    4,    7,            3,    1,    3,    1,    // 71
       8,    3,   31,  -63,            2,    1,    4,    6,    // 79
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, For5) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Start()                     \n\
        {                               \n\
            return 1;                   \n\
        }                               \n\
        int Check()                     \n\
        {                               \n\
            return 10;                  \n\
        }                               \n\
        int Cont(int x)                 \n\
        {                               \n\
            return x+1;                 \n\
        }                               \n\
                                        \n\
        void main()                     \n\
        {                               \n\
            for(int i = Start(); i < Check(); i = Cont(i))   \n\
                if (i >= 0)             \n\
                    continue;           \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For5", scrip);
    // hand-checked Bytecode
    const size_t codesize = 152;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            1,   31,    3,    6,    // 7
       3,    0,    5,   38,           11,    6,    3,   10,    // 15
      31,    3,    6,    3,            0,    5,   38,   22,    // 23
      51,    8,    7,    3,           29,    3,    6,    3,    // 31
       1,   30,    4,   11,            4,    3,    3,    4,    // 39
       3,   31,    3,    6,            3,    0,    5,   38,    // 47
      47,    6,    3,    0,           23,    3,    3,    1,    // 55
       2,    8,    3,    1,            1,    4,   51,    4,    // 63
       7,    3,   29,    3,            6,    3,   11,   23,    // 71
       3,   30,    4,   18,            4,    3,    3,    4,    // 79
       3,   28,   62,   51,            4,    7,    3,   29,    // 87
       3,    6,    3,    0,           30,    4,   19,    4,    // 95
       3,    3,    4,    3,           28,   23,   51,    4,    // 103
       7,    3,   29,    3,            6,    3,   22,   23,    // 111
       3,    2,    1,    4,           51,    4,    8,    3,    // 119
       6,    3,    0,   31,          -63,   51,    4,    7,    // 127
       3,   29,    3,    6,            3,   22,   23,    3,    // 135
       2,    1,    4,   51,            4,    8,    3,   31,    // 143
     -83,    2,    1,    4,            6,    3,    0,    5,    // 151
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      51,   70,  110,  133,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   2,   2,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);
}

TEST(Compatibility, For6) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void main()                     \n\
        {                               \n\
            for(int i = Start(); i < Check(); i = Cont(i))   \n\
                if (i >= 0)             \n\
                    continue;           \n\
        }                               \n\
        int Start()                     \n\
        {                               \n\
            return 1;                   \n\
        }                               \n\
        int Check()                     \n\
        {                               \n\
            return 10;                  \n\
        }                               \n\
        int Cont(int x)                 \n\
        {                               \n\
            return x + 1;               \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For6", scrip);
    // hand-checked Bytecode
    const size_t codesize = 152;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,          105,   23,    3,    3,    // 7
       1,    2,    8,    3,            1,    1,    4,   51,    // 15
       4,    7,    3,   29,            3,    6,    3,  116,    // 23
      23,    3,   30,    4,           18,    4,    3,    3,    // 31
       4,    3,   28,   62,           51,    4,    7,    3,    // 39
      29,    3,    6,    3,            0,   30,    4,   19,    // 47
       4,    3,    3,    4,            3,   28,   23,   51,    // 55
       4,    7,    3,   29,            3,    6,    3,  127,    // 63
      23,    3,    2,    1,            4,   51,    4,    8,    // 71
       3,    6,    3,    0,           31,  -63,   51,    4,    // 79
       7,    3,   29,    3,            6,    3,  127,   23,    // 87
       3,    2,    1,    4,           51,    4,    8,    3,    // 95
      31,  -83,    2,    1,            4,    6,    3,    0,    // 103
       5,   38,  105,    6,            3,    1,   31,    3,    // 111
       6,    3,    0,    5,           38,  116,    6,    3,    // 119
      10,   31,    3,    6,            3,    0,    5,   38,    // 127
     127,   51,    8,    7,            3,   29,    3,    6,    // 135
       3,    1,   30,    4,           11,    4,    3,    3,    // 143
       4,    3,   31,    3,            6,    3,    0,    5,    // 151
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,   23,   63,   86,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   2,   2,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, For7) {
    ccCompiledScript *scrip = newScriptFixture();

    // Initializer and iterator of a for() need not be assignments,
    // they can be func calls.

    char *inpl = "\
        int i;                          \n\
        void main()                     \n\
        {                               \n\
            for(Start(); Check(); Cont())   \n\
                if (i >= 5)             \n\
                    i = 100 - i;        \n\
        }                               \n\
        short Start()                   \n\
        {                               \n\
            i = 1;                      \n\
            return -77;                 \n\
        }                               \n\
        int Check()                     \n\
        {                               \n\
            return i < 10;              \n\
        }                               \n\
        void Cont()                     \n\
        {                               \n\
            i++;                        \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For7", scrip);
    // hand-checked Bytecode
    const size_t codesize = 129;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           68,   23,    3,    6,    // 7
       3,   87,   23,    3,           28,   50,    6,    2,    // 15
       0,    7,    3,   29,            3,    6,    3,    5,    // 23
      30,    4,   19,    4,            3,    3,    4,    3,    // 31
      28,   23,    6,    3,          100,   29,    3,    6,    // 39
       2,    0,    7,    3,           30,    4,   12,    4,    // 47
       3,    3,    4,    3,            6,    2,    0,    8,    // 55
       3,    6,    3,  113,           23,    3,   31,  -57,    // 63
       6,    3,    0,    5,           38,   68,    6,    3,    // 71
       1,    6,    2,    0,            8,    3,    6,    3,    // 79
     -77,   31,    3,    6,            3,    0,    5,   38,    // 87
      87,    6,    2,    0,            7,    3,   29,    3,    // 95
       6,    3,   10,   30,            4,   18,    4,    3,    // 103
       3,    4,    3,   31,            3,    6,    3,    0,    // 111
       5,   38,  113,    6,            2,    0,    7,    3,    // 119
       1,    3,    1,    8,            3,    6,    3,    0,    // 127
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 9;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,    9,   16,   41,         54,   59,   75,   91,    // 7
     117,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   1,   1,      1,   2,   1,   1,    // 7
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, IfDoWhile) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)                      \n\
    {                                            \n\
        int five = 5, sum, loop = -2;            \n\
        if (five < 10)                           \n\
            for (loop = 0; loop < 10; loop += 3) \n\
            {                                    \n\
                sum += loop;                     \n\
                if (loop == 6) return loop;      \n\
            }                                    \n\
        else                                     \n\
            do { loop += 1; } while (loop < 100);   \n\
        return 0;                                \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfDoWhile", scrip);
    // hand-checked Bytecode
    const size_t codesize = 196;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    3,    1,    2,    // 15
      63,    4,    1,    1,            4,    6,    3,   -2,    // 23
       3,    1,    2,    8,            3,    1,    1,    4,    // 31
      51,   12,    7,    3,           29,    3,    6,    3,    // 39
      10,   30,    4,   18,            4,    3,    3,    4,    // 47
       3,   28,   91,    6,            3,    0,   51,    4,    // 55
       8,    3,   51,    4,            7,    3,   29,    3,    // 63
       6,    3,   10,   30,            4,   18,    4,    3,    // 71
       3,    4,    3,   28,           63,   51,    4,    7,    // 79
       3,   29,    3,   51,           12,    7,    3,   30,    // 87
       4,   11,    3,    4,            8,    3,   51,    4,    // 95
       7,    3,   29,    3,            6,    3,    6,   30,    // 103
       4,   15,    4,    3,            3,    4,    3,   28,    // 111
       9,   51,    4,    7,            3,    2,    1,   12,    // 119
      31,   73,    6,    3,            3,   29,    3,   51,    // 127
       8,    7,    3,   30,            4,   11,    3,    4,    // 135
       8,    3,   31,  -82,           31,   39,   31,    2,    // 143
      31,   35,    6,    3,            1,   29,    3,   51,    // 151
       8,    7,    3,   30,            4,   11,    3,    4,    // 159
       8,    3,   51,    4,            7,    3,   29,    3,    // 167
       6,    3,  100,   30,            4,   18,    4,    3,    // 175
       3,    4,    3,   70,          -35,    6,    3,    0,    // 183
       2,    1,   12,   31,            6,    6,    3,    0,    // 191
       2,    1,   12,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Switch01) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)         \n\
    {                               \n\
        switch (i * i)              \n\
        {                           \n\
        case 2: return 10; break;   \n\
        default: i *= 2; return i;  \n\
        case 3:                     \n\
        case 4: i = 0;              \n\
        case 5: i += 5 - i - 4;  break; \n\
        }                           \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Switch01", scrip);
    // hand-checked Bytecode
    const size_t codesize = 170;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   12,    7,    3,           30,    4,    9,    4,    // 15
       3,    3,    4,    3,            3,    3,    4,   31,    // 23
      87,   31,  135,    6,            3,   10,    5,    6,    // 31
       3,    0,   31,  -11,            6,    3,    2,   29,    // 39
       3,   51,   12,    7,            3,   30,    4,    9,    // 47
       3,    4,    8,    3,           51,    8,    7,    3,    // 55
       5,    6,    3,    0,           51,    8,    8,    3,    // 63
       6,    3,    5,   29,            3,   51,   12,    7,    // 71
       3,   30,    4,   12,            4,    3,    3,    4,    // 79
       3,   29,    3,    6,            3,    4,   30,    4,    // 87
      12,    4,    3,    3,            4,    3,   29,    3,    // 95
      51,   12,    7,    3,           30,    4,   11,    3,    // 103
       4,    8,    3,    6,            3,    0,   31,   50,    // 111
      29,    4,    6,    3,            2,   30,    4,   16,    // 119
       3,    4,   28,  -97,           29,    4,    6,    3,    // 127
       3,   30,    4,   16,            3,    4,   28,  -79,    // 135
      29,    4,    6,    3,            4,   30,    4,   16,    // 143
       3,    4,   28,  -91,           29,    4,    6,    3,    // 151
       5,   30,    4,   16,            3,    4,   28,  -96,    // 159
      31, -126,    6,    3,            0,    5,    6,    3,    // 167
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, FreeLocalPtr) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct S                  \n\
    {                                 \n\
        int i;                        \n\
    };                                \n\
                                      \n\
    int foo()                         \n\
    {                                 \n\
        S *sptr = new S;              \n\
                                      \n\
        for (int i = 0; i < 10; i++)  \n\
            sptr = new S;             \n\
    }                                 \n\
    ";
    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FreeLocalPtr", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 78;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   73,    3,            4,    3,    1,    2,    // 7
      50,    3,    1,    1,            4,    6,    3,    0,    // 15
       3,    1,    2,    8,            3,    1,    1,    4,    // 23
      51,    4,    7,    3,           29,    3,    6,    3,    // 31
      10,   30,    4,   18,            4,    3,    3,    4,    // 39
       3,   28,   18,   73,            3,    4,   51,    8,    // 47
      47,    3,   51,    4,            7,    3,    1,    3,    // 55
       1,    8,    3,   31,          -37,    2,    1,    4,    // 63
       6,    3,    0,   29,            3,   51,    8,   49,    // 71
      30,    3,    2,    1,            4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Strings1) {
    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        string GLOBAL; \
\
        string MyFunction(int a)\
        {\
            string x;\
            return GLOBAL;\
        }\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Strings1", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 32;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            5,    1,    1,  200,    // 7
       3,    1,    2,    8,            5,    1,    1,    4,    // 15
       6,    2,  200,    7,            3,    2,    1,  204,    // 23
       5,    6,    3,    0,            2,    1,  204,    5,    // 31
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
     200,   18,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      5,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Strings2) {

    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void sub(const string s) \n\
        {                       \n\
            return;             \n\
        }                       \n\
                                \n\
        void main()             \n\
        {                       \n\
            sub(\"Foo\");       \n\
        }                       \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Strings2", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 29;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    5,    6,    3,    // 7
       0,    5,   38,   10,            6,    3,    0,   29,    // 15
       3,    6,    3,    0,           23,    3,    2,    1,    // 23
       4,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      14,   19,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      3,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 4;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'F',  'o',  'o',    0,          '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }

}

TEST(Compatibility, Struct01) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct               \n\
    {                               \n\
        float Float;                \n\
        import int[] Func(int i);   \n\
    };                              \n\
                                    \n\
    int Ret[];                      \n\
                                    \n\
    int[] Struct::Func(int i)       \n\
    {                               \n\
        this.Float = 0.0;           \n\
        Ret = new int[5];           \n\
        return Ret;                 \n\
    }                               \n\
                                    \n\
    void main()                     \n\
    {                               \n\
        Struct S;                   \n\
        S.Func(-1);                 \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct01", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 90;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,    6,            3,    0,    3,    6,    // 15
       2,   52,    8,    3,            6,    3,    5,   72,    // 23
       3,    4,    0,    6,            2,    0,   47,    3,    // 31
       6,    2,    0,   48,            3,    2,    1,    4,    // 39
       5,    6,    3,    0,            2,    1,    4,    5,    // 47
      38,   48,    3,    1,            2,   63,    4,    1,    // 55
       1,    4,   51,    4,           29,    6,   29,    2,    // 63
       6,    3,   -1,   30,            2,   29,    3,   45,    // 71
       2,    6,    3,    0,           23,    3,    2,    1,    // 79
       4,   30,    6,    6,            3,    0,    2,    1,    // 87
       4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      29,   34,   75,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Struct02) {
    ccCompiledScript *scrip = newScriptFixture();

    // test arrays; arrays in structs;
    // whether the namespace in structs is independent of the global namespace

    char *inpl = "\
    struct Struct1                  \n\
    {                               \n\
        int Array[17], Ix;          \n\
    };                              \n\
                                    \n\
    Struct1 S;                      \n\
    int Array[5];                   \n\
                                    \n\
    void main()                     \n\
    {                               \n\
        S.Ix = 5;                   \n\
        Array[2] = 3;               \n\
        S.Array[Array[2]] = 42;     \n\
        S.Array[S.Ix] = 19;         \n\
        return;                     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct02", scrip);
    // hand-checked Bytecode
    const size_t codesize = 106;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    6,    2,   68,    // 7
       8,    3,    6,    3,            3,   29,    3,    6,    // 15
       3,    2,   46,    3,            5,    6,    2,   72,    // 23
      32,    3,    4,   11,            2,    3,   30,    3,    // 31
       8,    3,    6,    3,           42,   29,    3,    6,    // 39
       3,    2,   46,    3,            5,    6,    2,   72,    // 47
      32,    3,    4,   11,            2,    3,    7,    3,    // 55
      46,    3,   17,    6,            2,    0,   32,    3,    // 63
       4,   11,    2,    3,           30,    3,    8,    3,    // 71
       6,    3,   19,   29,            3,    6,    2,   68,    // 79
       7,    3,   46,    3,           17,    6,    2,    0,    // 87
      32,    3,    4,   11,            2,    3,   30,    3,    // 95
       8,    3,    6,    3,            0,    5,    6,    3,    // 103
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 6;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   23,   47,   61,         79,   87,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Struct03) {
    ccCompiledScript *scrip = newScriptFixture();

    // test arrays; arrays in structs;
    // whether the namespace in structs is independent of the global namespace

    char *inpl = "\
    struct Struct1                  \n\
    {                               \n\
        int Array[17], Ix;          \n\
    } S;                            \n\
    int Array[5];                   \n\
                                    \n\
    void main()                     \n\
    {                               \n\
        S.Ix = 5;                   \n\
        Array[2] = 3;               \n\
        S.Array[Array[2]] = 42;     \n\
        S.Array[S.Ix] = 19;         \n\
        return;                     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct03", scrip);
    // hand-checked Bytecode
    const size_t codesize = 106;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    6,    2,   68,    // 7
       8,    3,    6,    3,            3,   29,    3,    6,    // 15
       3,    2,   46,    3,            5,    6,    2,   72,    // 23
      32,    3,    4,   11,            2,    3,   30,    3,    // 31
       8,    3,    6,    3,           42,   29,    3,    6,    // 39
       3,    2,   46,    3,            5,    6,    2,   72,    // 47
      32,    3,    4,   11,            2,    3,    7,    3,    // 55
      46,    3,   17,    6,            2,    0,   32,    3,    // 63
       4,   11,    2,    3,           30,    3,    8,    3,    // 71
       6,    3,   19,   29,            3,    6,    2,   68,    // 79
       7,    3,   46,    3,           17,    6,    2,    0,    // 87
      32,    3,    4,   11,            2,    3,   30,    3,    // 95
       8,    3,    6,    3,            0,    5,    6,    3,    // 103
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 6;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   23,   47,   61,         79,   87,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Struct04) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        managed struct StructI                               \n\
        {                                                    \n\
            int k;                                           \n\
        };                                                   \n\
                                                             \n\
        struct StructO                                       \n\
        {                                                    \n\
            StructI *SI;                                     \n\
            StructI *SJ[3];                                  \n\
        };                                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
            StructO SO;                                      \n\
            SO.SI = new StructI;                             \n\
            SO.SI.k = 12345;                                 \n\
            StructO SOA[3];                                  \n\
            SOA[2].SI = new StructI;                         \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    WriteOutput("Struct04", scrip);
    // hand-checked Bytecode
    const size_t codesize = 128;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,   16,    1,    // 7
       1,   16,   73,    3,            4,   51,   16,   47,    // 15
       3,    6,    3, 12345,           29,    3,   51,   20,    // 23
      52,   48,    2,   30,            3,    8,    3,    3,    // 31
       1,    2,   63,   48,            1,    1,   48,   73,    // 39
       3,    4,   29,    3,            6,    3,    2,   46,    // 47
       3,    3,   51,   52,           32,    3,   16,   11,    // 55
       2,    3,   30,    3,           47,    3,    6,    3,    // 63
       0,   29,    3,   51,           68,   49,    1,    2,    // 71
       4,    6,    3,    3,           49,    1,    2,    4,    // 79
       2,    3,    1,   70,           -9,   51,   52,    6,    // 87
       3,    3,   29,    2,           29,    3,   49,    1,    // 95
       2,    4,    6,    3,            3,   49,    1,    2,    // 103
       4,    2,    3,    1,           70,   -9,   30,    3,    // 111
      30,    2,    1,    2,           16,    2,    3,    1,    // 119
      70,  -32,   30,    3,            2,    1,   64,    5,    // 127
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);
}


TEST(Compatibility, Struct05) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct StructO                                       \n\
        {                                                    \n\
            static import int StInt(int i);                  \n\
        };                                                   \n\
        StructO        S1;                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
             StructO        S2;                              \n\
             return S1.StInt(S2.StInt(7));                   \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct05", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 37;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    0,    6,    // 7
       3,    7,   34,    3,           39,    1,    6,    3,    // 15
       0,   33,    3,   35,            1,   34,    3,   39,    // 23
       1,    6,    3,    0,           33,    3,   35,    1,    // 31
       5,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,   27,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "StructO::StInt^1",            "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Struct06) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        managed struct Struct0;                              \n\
                                                             \n\
        struct Struct1                                       \n\
        {                                                    \n\
            Struct0 *Array[];                                \n\
        };                                                   \n\
                                                             \n\
        managed struct Struct0                               \n\
        {                                                    \n\
            int Payload;                                     \n\
        };                                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
             Struct1 S;                                      \n\
                                                             \n\
             S.Array = new Struct0[5];                       \n\
             S.Array[3].Payload ++;                          \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    WriteOutput("Struct06", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 72;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    6,    3,            5,   72,    3,    4,    // 15
       1,   51,    4,   29,            2,   30,    2,   47,    // 23
       3,    6,    3,    3,            3,    3,    7,   51,    // 31
       4,   32,    7,    4,           48,    2,   52,   71,    // 39
       7,   11,    2,    7,           29,    2,   30,    2,    // 47
      48,    3,   29,    3,           30,    2,   52,    7,    // 55
       3,    1,    3,    1,            8,    3,    6,    3,    // 63
       0,   51,    4,   49,            2,    1,    4,    5,    // 71
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Struct07) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct1                                       \n\
        {                                                    \n\
            int IPayload;                                    \n\
            char CPayload[3];                                \n\
        };                                                   \n\
                                                             \n\
        Struct1 S1[3];                                       \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
            S1[1].IPayload = 0;                              \n\
            S1[1].CPayload[0] = 'A';                         \n\
            S1[1].CPayload[1] = S1[1].CPayload[0] - 'A';     \n\
            S1[1].CPayload[0] --;                            \n\
            return 0;                                        \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct07", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 218;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,   29,    3,    6,    // 7
       3,    1,   46,    3,            3,   32,    3,    8,    // 15
       3,    3,    5,   30,            3,    6,    2,    0,    // 23
      11,    2,    5,    8,            3,    6,    3,   65,    // 31
      29,    3,    6,    3,            1,   46,    3,    3,    // 39
      32,    3,    8,    3,            3,    5,   30,    3,    // 47
      29,    3,   29,    5,            6,    3,    0,   46,    // 55
       3,    3,   32,    3,            1,   30,    5,   11,    // 63
       5,    3,   30,    3,            6,    2,    4,   11,    // 71
       2,    5,   26,    3,            6,    3,    1,   46,    // 79
       3,    3,   32,    3,            8,    3,    3,    5,    // 87
      29,    5,    6,    3,            0,   46,    3,    3,    // 95
      32,    3,    1,   30,            5,   11,    5,    3,    // 103
       6,    2,    4,   11,            2,    5,   24,    3,    // 111
      29,    3,    6,    3,           65,   30,    4,   12,    // 119
       4,    3,    3,    4,            3,   29,    3,    6,    // 127
       3,    1,   46,    3,            3,   32,    3,    8,    // 135
       3,    3,    5,   30,            3,   29,    3,   29,    // 143
       5,    6,    3,    1,           46,    3,    3,   32,    // 151
       3,    1,   30,    5,           11,    5,    3,   30,    // 159
       3,    6,    2,    4,           11,    2,    5,   26,    // 167
       3,    6,    3,    1,           46,    3,    3,   32,    // 175
       3,    8,    3,    3,            5,   29,    5,    6,    // 183
       3,    0,   46,    3,            3,   32,    3,    1,    // 191
      30,    5,   11,    5,            3,    6,    2,    4,    // 199
      11,    2,    5,   24,            3,    2,    3,    1,    // 207
      26,    3,    6,    3,            0,    5,    6,    3,    // 215
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      23,   70,  106,  163,        199,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Struct08) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct                                        \n\
        {                                                    \n\
            int k;                                           \n\
        };                                                   \n\
                                                             \n\
        struct Sub extends Struct                            \n\
        {                                                    \n\
            int l;                                           \n\
        };                                                   \n\
                                                             \n\
        int Func(this Sub *, int i, int j)                   \n\
        {                                                    \n\
            return !i || !(j) && this.k || (0 != this.l);    \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct08", scrip);
    // run the test, comment out the previous line 
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 100;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   51,           12,    7,    3,   42,    // 15
       3,   70,   35,   29,            3,   51,   20,    7,    // 23
       3,   42,    3,   28,           17,   29,    3,   29,    // 31
       6,   30,    2,   52,            7,    3,   30,    4,    // 39
      21,    4,    3,    3,            4,    3,   30,    4,    // 47
      22,    4,    3,    3,            4,    3,   70,   33,    // 55
      29,    3,    6,    3,            0,   29,    3,   29,    // 63
       6,   30,    2,   52,            1,    2,    4,    7,    // 71
       3,   30,    4,   16,            4,    3,    3,    4,    // 79
       3,   30,    4,   22,            4,    3,    3,    4,    // 87
       3,    2,    1,    4,            5,    6,    3,    0,    // 95
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Func01) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func01", scrip);
    // hand-checked Bytecode
    const size_t codesize = 83;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    3,    1,            2,   63,    4,    1,    // 15
       1,    4,   51,    4,           48,    3,   34,    3,    // 23
      51,    8,   48,    3,           34,    3,   39,    2,    // 31
       6,    3,    0,   33,            3,   35,    2,    3,    // 39
       1,    2,    8,    3,            1,    1,    4,   51,    // 47
       4,    7,    3,   29,            3,   51,   16,   49,    // 55
      51,   12,   49,   30,            3,    2,    1,   12,    // 63
      31,   16,    6,    3,            0,   29,    3,   51,    // 71
      16,   49,   51,   12,           49,   30,    3,    2,    // 79
       1,   12,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      34,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func02) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    WriteOutput("Func02", scrip);
    // hand-checked Bytecode
    const size_t codesize = 83;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,    3,    1,            2,   63,    4,    1,    // 15
       1,    4,   51,    4,           48,    3,   34,    3,    // 23
      51,    8,   48,    3,           34,    3,   39,    2,    // 31
       6,    3,    0,   33,            3,   35,    2,    3,    // 39
       1,    2,    8,    3,            1,    1,    4,   51,    // 47
       4,    7,    3,   29,            3,   51,   16,   49,    // 55
      51,   12,   49,   30,            3,    2,    1,   12,    // 63
      31,   16,    6,    3,            0,   29,    3,   51,    // 71
      16,   49,   51,   12,           49,   30,    3,    2,    // 79
       1,   12,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      34,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };
}

TEST(Compatibility, Func03) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
                                    \n\
    int Func(Struct1 *S1, Struct2 *S2)  \n\
    {                               \n\
        return 0;                   \n\
    }                               \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
   ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func03", scrip);
    // hand-checked Bytecode
    const size_t codesize = 125;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   50,    3,    // 7
      51,   12,    7,    3,           50,    3,    6,    3,    // 15
       0,   29,    3,   51,           12,   49,   51,   16,    // 23
      49,   30,    3,   31,           13,    6,    3,    0,    // 31
      29,    3,   51,   12,           49,   51,   16,   49,    // 39
      30,    3,    5,   38,           43,    3,    1,    2,    // 47
      63,    4,    1,    1,            4,    3,    1,    2,    // 55
      63,    4,    1,    1,            4,   51,    4,   48,    // 63
       3,   29,    3,   51,           12,   48,    3,   29,    // 71
       3,    6,    3,    0,           23,    3,    2,    1,    // 79
       8,    3,    1,    2,            8,    3,    1,    1,    // 87
       4,   51,    4,    7,            3,   29,    3,   51,    // 95
      16,   49,   51,   12,           49,   30,    3,    2,    // 103
       1,   12,   31,   16,            6,    3,    0,   29,    // 111
       3,   51,   16,   49,           51,   12,   49,   30,    // 119
       3,    2,    1,   12,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      75,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func04) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1 = Func(5);     \n\
        return -1;                  \n\
    }                               \n\
                                    \n\
    Struct1 *Func(int Int)          \n\
    {                               \n\
        return new Struct1;         \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func04", scrip);
    // hand-checked Bytecode
    const size_t codesize = 81;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,   29,    3,    6,    // 7
       3,   52,   23,    3,            2,    1,    4,    3,    // 15
       1,    2,   50,    3,            1,    1,    4,    6,    // 23
       3,   -1,   29,    3,           51,    8,   49,   30,    // 31
       3,    2,    1,    4,           31,   13,    6,    3,    // 39
       0,   29,    3,   51,            8,   49,   30,    3,    // 47
       2,    1,    4,    5,           38,   52,   73,    3,    // 55
       4,    3,    1,    2,           50,    3,    3,    1,    // 63
       2,   69,   31,   12,            6,    3,    0,    3,    // 71
       1,    2,   50,    3,            3,    1,    2,   69,    // 79
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       9,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Func05) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        int Func(int P1, int P2)     \n\
        {                            \n\
            return P1 + P2;          \n\
        }                            \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int = Func(4);       \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func05", scrip);
    // hand-checked Bytecode
    const size_t codesize = 61;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   11,    4,    // 15
       3,    3,    4,    3,           31,    3,    6,    3,    // 23
       0,    5,   38,   26,            6,    3,    5,   29,    // 31
       3,    6,    3,    4,           29,    3,    6,    3,    // 39
       0,   23,    3,    2,            1,    8,    3,    1,    // 47
       2,    8,    3,    1,            1,    4,    6,    3,    // 55
       0,    2,    1,    4,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      40,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func06) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func06", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 63;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,   34,    3,    6,    // 7
       3,    4,   34,    3,           39,    2,    6,    3,    // 15
       0,   33,    3,   35,            2,    3,    1,    2,    // 23
       8,    3,    1,    1,            4,    6,    3,    1,    // 31
      34,    3,    6,    3,            4,   34,    3,   39,    // 39
       2,    6,    3,    0,           33,    3,   35,    2,    // 47
       3,    1,    2,    8,            3,    1,    1,    4,    // 55
       6,    3,    0,    2,            1,    8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,   43,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func07) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
                                     \n\
        import int Func(int, int = 5); \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func07", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 63;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,   34,    3,    6,    // 7
       3,    4,   34,    3,           39,    2,    6,    3,    // 15
       0,   33,    3,   35,            2,    3,    1,    2,    // 23
       8,    3,    1,    1,            4,    6,    3,    1,    // 31
      34,    3,    6,    3,            4,   34,    3,   39,    // 39
       2,    6,    3,    0,           33,    3,   35,    2,    // 47
       3,    1,    2,    8,            3,    1,    1,    4,    // 55
       6,    3,    0,    2,            1,    8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,   43,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func08) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int f, int = 5); \n\
        import int Func(int, int = 5); \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func08", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 63;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,   34,    3,    6,    // 7
       3,    4,   34,    3,           39,    2,    6,    3,    // 15
       0,   33,    3,   35,            2,    3,    1,    2,    // 23
       8,    3,    1,    1,            4,    6,    3,    1,    // 31
      34,    3,    6,    3,            4,   34,    3,   39,    // 39
       2,    6,    3,    0,           33,    3,   35,    2,    // 47
       3,    1,    2,    8,            3,    1,    1,    4,    // 55
       6,    3,    0,    2,            1,    8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,   43,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Func09) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        int Func(int P1, int P2)     \n\
        {                            \n\
            return P1 + P2;          \n\
        }                            \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int = Func(4,-99);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func09", scrip);
    // hand-checked Bytecode

    const size_t codesize = 61;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   11,    4,    // 15
       3,    3,    4,    3,           31,    3,    6,    3,    // 23
       0,    5,   38,   26,            6,    3,  -99,   29,    // 31
       3,    6,    3,    4,           29,    3,    6,    3,    // 39
       0,   23,    3,    2,            1,    8,    3,    1,    // 47
       2,    8,    3,    1,            1,    4,    6,    3,    // 55
       0,    2,    1,    4,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      40,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Func10) {
    ccCompiledScript *scrip = newScriptFixture();

    // Note that currently, the compiler will add an empty local pointer variable
    // for the "this" pointer to each non-static struct function. This seems to be
    // in line with the former code but does not serve any useful function AFAICS.

    char *inpl = "\
    struct Struct                   \n\
    {                               \n\
        float Float;                \n\
        int Func();                 \n\
    };                              \n\
                                    \n\
    int Struct::Func()              \n\
    {                               \n\
        return 5;                   \n\
    }                               \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct s;                   \n\
        int Int = s.Func() % 3;     \n\
        return Int;                 \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func10", scrip);
    // hand-checked Bytecode
    const size_t codesize = 86;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,    6,            3,    5,    2,    1,    // 15
       4,   31,    6,    6,            3,    0,    2,    1,    // 23
       4,    5,   38,   26,            3,    1,    2,   63,    // 31
       4,    1,    1,    4,           51,    4,   29,    6,    // 39
      45,    2,    6,    3,            0,   23,    3,   30,    // 47
       6,   29,    3,    6,            3,    3,   30,    4,    // 55
      40,    4,    3,    3,            4,    3,    3,    1,    // 63
       2,    8,    3,    1,            1,    4,   51,    4,    // 71
       7,    3,    2,    1,            8,   31,    6,    6,    // 79
       3,    0,    2,    1,            8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      44,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Export) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    struct Struct                   \n\
    {                               \n\
        float Float;                \n\
        int Int;                    \n\
    };                              \n\
    Struct StructyStructy;          \n\
    export StructyStructy;          \n\
                                    \n\
    int Inty;                       \n\
    float Floaty;                   \n\
    export Floaty, Inty;            \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct s;                   \n\
        s.Int = 3;                  \n\
        s.Float = 1.1 / 2.2;        \n\
        return -2;                  \n\
    }                               \n\
    export main;                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Export", scrip);
    // hand-checked Bytecode
    const size_t codesize = 52;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    8,    1,    // 7
       1,    8,    6,    3,            3,   51,    4,    8,    // 15
       3,    6,    3, 1066192077,           29,    3,    6,    3,    // 23
    1074580685,   30,    4,   56,            4,    3,    3,    4,    // 31
       3,   51,    8,    8,            3,    6,    3,   -2,    // 39
       2,    1,    8,   31,            6,    6,    3,    0,    // 47
       2,    1,    8,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 4;
    EXPECT_EQ(numexports, scrip->numexports);

    std::string exports[] = {
    "StructyStructy", "Floaty",   "Inty",     "main$0",   // 3
     "[[SENTINEL]]"
    };

    for (size_t idx = 0; idx < numexports; idx++)
    {
        if (idx >= scrip->numexports) break;
        std::string prefix = "exports[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + exports[idx];
        std::string test_val = prefix + scrip->exports[idx];
        ASSERT_EQ(is_val, test_val);
    }

    int32_t export_addr[] = {
    0x2000000, 0x200000c,    0x2000008, 0x1000000, // 3
     0
    };

    for (size_t idx = 0; idx < numexports; idx++)
    {
        if (idx >= scrip->numexports) break;
        std::string prefix = "export_addr[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(export_addr[idx]);
        std::string test_val = prefix + std::to_string(scrip->export_addr[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, ArrayOfPointers1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        float Float;                     \n\
        protected int Int;               \n\
    };                                   \n\
    Struct *arr[50];                     \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        for (int i = 0; i < 9; i++)       \n\
            arr[i] = new Struct;         \n\
                                         \n\
        int test = (arr[10] == null);    \n\
                                         \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayOfPointers1", scrip);
    // hand checked Bytecode
    const size_t codesize = 116;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   51,    4,    7,    // 15
       3,   29,    3,    6,            3,    9,   30,    4,    // 23
      18,    4,    3,    3,            4,    3,   28,   36,    // 31
      73,    3,    8,   29,            3,   51,    8,    7,    // 39
       3,   46,    3,   50,            6,    2,    0,   32,    // 47
       3,    4,   11,    2,            3,   30,    3,   47,    // 55
       3,   51,    4,    7,            3,    1,    3,    1,    // 63
       8,    3,   31,  -55,            2,    1,    4,    6,    // 71
       3,   10,   46,    3,           50,    6,    2,    0,    // 79
      32,    3,    4,   11,            2,    3,   48,    3,    // 87
      29,    3,    6,    3,            0,   30,    4,   15,    // 95
       4,    3,    3,    4,            3,    3,    1,    2,    // 103
       8,    3,    1,    1,            4,    6,    3,    0,    // 111
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      46,   79,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, ArrayOfPointers2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        float Float;                     \n\
        protected int Int;               \n\
    };                                   \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        Struct *arr2[50];                \n\
        for (int i = 0; i < 20; i++) {   \n\
                arr2[i] = new Struct;    \n\
        }                                \n\
        arr2[5].Float = 2.2 - 0.0 * 3.3; \n\
        arr2[4] = null;                  \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayOfPointers2", scrip);
    // hand-checked bytecode
    const size_t codesize = 178;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,  200,    1,    // 7
       1,  200,    6,    3,            0,    3,    1,    2,    // 15
       8,    3,    1,    1,            4,   51,    4,    7,    // 23
       3,   29,    3,    6,            3,   20,   30,    4,    // 31
      18,    4,    3,    3,            4,    3,   28,   35,    // 39
      73,    3,    8,   29,            3,   51,    8,    7,    // 47
       3,   46,    3,   50,           51,  208,   32,    3,    // 55
       4,   11,    2,    3,           30,    3,   47,    3,    // 63
      51,    4,    7,    3,            1,    3,    1,    8,    // 71
       3,   31,  -54,    2,            1,    4,    6,    3,    // 79
    1074580685,   29,    3,    6,            3,    0,   29,    3,    // 87
       6,    3, 1079194419,   30,            4,   55,    4,    3,    // 95
       3,    4,    3,   30,            4,   58,    4,    3,    // 103
       3,    4,    3,   29,            3,    6,    3,    5,    // 111
      46,    3,   50,   51,          204,   32,    3,    4,    // 119
      11,    2,    3,   52,           48,    2,   30,    3,    // 127
       8,    3,    6,    3,            0,   29,    3,    6,    // 135
       3,    4,   46,    3,           50,   51,  204,   32,    // 143
       3,    4,   11,    2,            3,   30,    3,   47,    // 151
       3,    6,    3,    0,           29,    3,   51,  204,    // 159
       6,    3,   50,   49,            1,    2,    4,    2,    // 167
       3,    1,   70,   -9,           30,    3,    2,    1,    // 175
     200,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, ArrayInStruct) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        int Int[10];                     \n\
    };                                   \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        Struct *S = new Struct;          \n\
        S.Int[4] =  1;                   \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayInStruct", scrip);
    // Hand checked new code
    const size_t codesize = 57;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   73,    3,           40,    3,    1,    2,    // 7
      50,    3,    1,    1,            4,    6,    3,    1,    // 15
      29,    3,   51,    8,           52,   48,    2,   29,    // 23
       2,    6,    3,    4,           46,    3,   10,   30,    // 31
       2,   32,    3,    4,           11,    2,    3,   30,    // 39
       3,    8,    3,    6,            3,    0,   29,    3,    // 47
      51,    8,   49,   30,            3,    2,    1,    4,    // 55
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Compatibility, Func11) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Func(int I, ...)                 \n\
    {                                    \n\
        return I + I / I;                \n\
    }                                    \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        return 0;                        \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func11", scrip);
    // hand-checked Bytecode
    const size_t codesize = 51;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   12,    7,    3,           29,    3,   51,   16,    // 15
       7,    3,   30,    4,           10,    4,    3,    3,    // 23
       4,    3,   30,    4,           11,    4,    3,    3,    // 31
       4,    3,   31,    3,            6,    3,    0,    5,    // 39
      38,   40,    6,    3,            0,   31,    3,    6,    // 47
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Writeprotected) {
    ccCompiledScript *scrip = newScriptFixture();

    // Directly taken from the doc on writeprotected, simplified.
    char *inpl = "\
        struct Weapon {                         \n\
            short Beauty;                       \n\
            writeprotected int Damage;          \n\
            import int SetDamage(int damage);   \n\
        } wp;                                   \n\
                                                \n\
        int  Weapon::SetDamage(int damage)      \n\
        {                                       \n\
            this.Damage = damage;               \n\
            return 0;                           \n\
        }                                       \n\
                                                \n\
        int main()                              \n\
        {                                       \n\
            return wp.Damage;                   \n\
        }                                       \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    WriteOutput("Writeprotected", scrip);
    // hand-checked Bytecode
    const size_t codesize = 50;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   51,           12,    7,    3,    3,    // 15
       6,    2,   52,    1,            2,    2,    8,    3,    // 23
       6,    3,    0,    2,            1,    4,    5,    6,    // 31
       3,    0,    2,    1,            4,    5,   38,   38,    // 39
       6,    2,    2,    7,            3,    5,    6,    3,    // 47
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      42,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Protected1) {
    ccCompiledScript *scrip = newScriptFixture();

    // Directly taken from the doc on protected, simplified.
    char *inpl = "\
        struct Weapon {                        \n\
            protected int Damage;              \n\
            import int SetDamage(int damage);  \n\
        };                                     \n\
                                               \n\
        Weapon wp;                             \n\
                                               \n\
        int  Weapon::SetDamage(int damage)     \n\
        {                                      \n\
            this.Damage = damage;              \n\
            return 0;                          \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Protected1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 36;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   51,           12,    7,    3,    3,    // 15
       6,    2,   52,    8,            3,    6,    3,    0,    // 23
       2,    1,    4,   31,            6,    6,    3,    0,    // 31
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Static1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Weapon {                        \n\
            import static int CalcDamage(      \n\
                 int Lifepoints, int Hitpoints = 5);   \n\
        };                                     \n\
                                               \n\
        static int Weapon::CalcDamage(int Lifepoints, int Hitpoints)  \n\
        {                                      \n\
            return Lifepoints - Hitpoints;     \n\
        }                                      \n\
                                               \n\
        int main()                             \n\
        {                                      \n\
            int hp = Weapon.CalcDamage(9) + Weapon.CalcDamage(9, 40);  \n\
            return hp + Weapon.CalcDamage(100);  \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Static1", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 124;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   12,    4,    // 15
       3,    3,    4,    3,            5,    6,    3,    0,    // 23
       5,   38,   25,    6,            3,    5,   29,    3,    // 31
       6,    3,    9,   29,            3,    6,    3,    0,    // 39
      23,    3,    2,    1,            8,   29,    3,    6,    // 47
       3,   40,   29,    3,            6,    3,    9,   29,    // 55
       3,    6,    3,    0,           23,    3,    2,    1,    // 63
       8,   30,    4,   11,            4,    3,    3,    4,    // 71
       3,    3,    1,    2,            8,    3,    1,    1,    // 79
       4,   51,    4,    7,            3,   29,    3,    6,    // 87
       3,    5,   29,    3,            6,    3,  100,   29,    // 95
       3,    6,    3,    0,           23,    3,    2,    1,    // 103
       8,   30,    4,   11,            4,    3,    3,    4,    // 111
       3,    2,    1,    4,            5,    6,    3,    0,    // 119
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      39,   59,   99,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Static2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Weapon {                        \n\
        };                                     \n\
                                               \n\
        int CalcDamage(static Weapon, int Lifepoints, int Hitpoints)  \n\
        {                                      \n\
            return Lifepoints - Hitpoints;     \n\
        }                                      \n\
                                               \n\
        int main()                             \n\
        {                                      \n\
            return Weapon.CalcDamage(9, 40);   \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Static2", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 50;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   12,    4,    // 15
       3,    3,    4,    3,            5,    6,    3,    0,    // 23
       5,   38,   25,    6,            3,   40,   29,    3,    // 31
       6,    3,    9,   29,            3,    6,    3,    0,    // 39
      23,    3,    2,    1,            8,    5,    6,    3,    // 47
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      39,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Protected2) {
    ccCompiledScript *scrip = newScriptFixture();

    // In a struct func, a variable that can't be found otherwise
    // should be taken to be out of the current struct.
    // (Note that this will currently compile to slightly more
    // inefficient code than "this.Damage = damage")

    char *inpl = "\
        struct Weapon {                        \n\
            protected int Damage;              \n\
            import int SetDamage(int damage);  \n\
        };                                     \n\
                                               \n\
        Weapon wp;                             \n\
                                               \n\
        int  Weapon::SetDamage(int damage)     \n\
        {                                      \n\
            Damage = damage;                   \n\
            return 0;                          \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Protected2", scrip);
    // hand-checked Bytecode
    const size_t codesize = 40;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,    4,    4,    0,    // 7
       1,    1,    4,   51,           12,    7,    3,   29,    // 15
       3,    3,    6,    2,           52,   30,    3,    8,    // 23
       3,    6,    3,    0,            2,    1,    4,   31,    // 31
       6,    6,    3,    0,            2,    1,    4,    5,    // 39
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, Import) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Weapon;                     \n\
                                               \n\
        int Func(int damage)                   \n\
        {                                      \n\
            int Int = 0;                       \n\
            Weapon = 77;                       \n\
            if (Weapon < 0)                    \n\
                Weapon = damage - (Int - Weapon) / Int; \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Import", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 100;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,    6,    3,   77,    // 15
       6,    2,    0,    8,            3,    6,    2,    0,    // 23
       7,    3,   29,    3,            6,    3,    0,   30,    // 31
       4,   18,    4,    3,            3,    4,    3,   28,    // 39
      52,   51,   12,    7,            3,   29,    3,   51,    // 47
       8,    7,    3,   29,            3,    6,    2,    0,    // 55
       7,    3,   30,    4,           12,    4,    3,    3,    // 63
       4,    3,   29,    3,           51,   12,    7,    3,    // 71
      30,    4,   10,    4,            3,    3,    4,    3,    // 79
      30,    4,   12,    4,            3,    3,    4,    3,    // 87
       6,    2,    0,    8,            3,    6,    3,    0,    // 95
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      18,   23,   55,   90,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,   4,   4,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Weapon",       "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Compatibility, StandardString) {
    ccCompiledScript *scrip = newScriptFixture();

    char inpl[] = "\
        int main()                         \n\
        {                                  \n\
            String s = \"Hello, world!\";  \n\
            if (s != \"Bye\")              \n\
                return 1;                  \n\
            return 0;                      \n\
        }                                  \n\
        ";
    std::string input = "";
    input += g_Input_Bool;
    input += g_Input_String;
    input += inpl;

    clear_error();
    int compileResult = cc_compile(input.c_str(), scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StandardString", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

    const size_t codesize = 68;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,   64,    3,    3,    // 7
       1,    2,   50,    3,            1,    1,    4,   51,    // 15
       4,   29,    2,   30,            2,   48,    3,   29,    // 23
       3,    6,    3,   14,           30,    4,   66,    4,    // 31
       3,    3,    4,    3,           28,   10,    6,    3,    // 39
       1,   51,    4,   69,            2,    1,    4,    5,    // 47
       6,    3,    0,   51,            4,   69,    2,    1,    // 55
       4,    5,    6,    3,            0,   51,    4,   69,    // 63
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,   27,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      3,   3,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 20;
    std::string imports[] = {
    "String::Format^101",         "String::IsNullOrEmpty^1",    "String::Append^1",           // 2
    "String::AppendChar^1",       "String::CompareTo^2",        "String::Contains^1",         // 5
    "String::Copy^0",             "String::EndsWith^2",         "String::IndexOf^1",          // 8
    "String::LowerCase^0",        "String::Replace^3",          "String::ReplaceCharAt^2",    // 11
    "String::StartsWith^2",       "String::Substring^2",        "String::Truncate^1",         // 14
    "String::UpperCase^0",        "String::get_AsFloat",        "String::get_AsInt",          // 17
    "String::geti_Chars",         "String::get_Length",          "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 18;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'H',  'e',  'l',  'l',          'o',  ',',  ' ',  'w',     // 7
    'o',  'r',  'l',  'd',          '!',    0,  'B',  'y',     // 15
    'e',    0,  '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }
}

TEST(Compatibility, Switch02) {
    ccCompiledScript *scrip = newScriptFixture();

    // Last switch clause no "break"
    char *inpl = "\
        void main()                     \n\
        {                               \n\
            int i = 5;                  \n\
            switch(i)                   \n\
            {                           \n\
            default: break;             \n\
            case 5: i = 0;              \n\
            }                           \n\
            return;                     \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Switch02", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code
    const size_t codesize = 66;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    3,    1,    2,    // 7
       8,    3,    1,    1,            4,   51,    4,    7,    // 15
       3,    3,    3,    4,           31,   16,   31,   28,    // 23
       6,    3,    0,   31,           -7,    6,    3,    0,    // 31
      51,    4,    8,    3,           31,   14,   29,    4,    // 39
       6,    3,    5,   30,            4,   16,    3,    4,    // 47
      28,  -21,   31,  -28,            6,    3,    0,    2,    // 55
       1,    4,    5,    6,            3,    0,    2,    1,    // 63
       4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);
}

TEST(Compatibility, Attributes) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        enum bool { false = 0, true = 1 };              \n\
        builtin managed struct ViewFrame {              \n\
            readonly import attribute bool Flipped;     \n\
            import attribute int Graphic;               \n\
            readonly import attribute float AsFloat;    \n\
        };                                              \n\
                                                        \n\
        int main()                                      \n\
        {                                               \n\
            ViewFrame *VF;                              \n\
            if (VF.Flipped)                             \n\
            {                                           \n\
                VF.Graphic = 17;                        \n\
                float f = VF.AsFloat + VF.AsFloat;      \n\
                return VF.Graphic;                      \n\
            }                                           \n\
            return VF.Flipped;                          \n\
        }                                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Attributes", scrip);
    // hand-checked bytecode
    const size_t codesize = 186;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    3,    1,            2,   63,    4,    1,    // 7
       1,    4,   51,    4,           52,   48,    2,   29,    // 15
       6,   45,    2,   39,            0,    6,    3,    0,    // 23
      33,    3,   30,    6,           28,  112,    6,    3,    // 31
      17,   51,    4,   52,           48,    2,   29,    6,    // 39
      34,    3,   45,    2,           39,    1,    6,    3,    // 47
       2,   33,    3,   35,            1,   30,    6,   51,    // 55
       4,   52,   48,    2,           29,    6,   45,    2,    // 63
      39,    0,    6,    3,            3,   33,    3,   30,    // 71
       6,   29,    3,   51,            8,   52,   48,    2,    // 79
      29,    6,   45,    2,           39,    0,    6,    3,    // 87
       3,   33,    3,   30,            6,   30,    4,   57,    // 95
       4,    3,    3,    4,            3,    3,    1,    2,    // 103
       8,    3,    1,    1,            4,   51,    8,   52,    // 111
      48,    2,   29,    6,           45,    2,   39,    0,    // 119
       6,    3,    1,   33,            3,   30,    6,   29,    // 127
       3,   51,   12,   49,           30,    3,    2,    1,    // 135
       8,   31,   46,    2,            1,    4,   51,    4,    // 143
      52,   48,    2,   29,            6,   45,    2,   39,    // 151
       0,    6,    3,    0,           33,    3,   30,    6,    // 159
      29,    3,   51,    8,           49,   30,    3,    2,    // 167
       1,    4,   31,   13,            6,    3,    0,   29,    // 175
       3,   51,    8,   49,           30,    3,    2,    1,    // 183
       4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 6;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      23,   48,   68,   88,        122,  155,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,   4,   4,      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 4;
    std::string imports[] = {
    "ViewFrame::get_Flipped^0",   "ViewFrame::get_Graphic^0",   "ViewFrame::set_Graphic^1",   // 2
    "ViewFrame::get_AsFloat^0",    "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}
