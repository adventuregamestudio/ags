#include <iostream>  
#include <fstream>
#include <string>
#include <map>
#include <fstream>
#include <streambuf>


#include "script/cc_options.h"
#include "gtest/gtest.h"
#include "script/cs_parser.h"
#include "script/cc_symboltable.h"
#include "script/cc_internallist.h"


/* This file is for Bytecode compatibility tests ONLY, i.e. for testing that
   the rewritten parser emits exactly the same Bytecode as the original
   one. Testing for programs that won't compile should be done elsewhere IMHO.
   Reason: Later on, when we trust the rewritten compiler, we'll want
   to extend it in such a way that it emits _different_ codes from the
   original compiler. Then we can simply throw away those tests in this
   file that no longer work.

   1. Head over to a release version that has the old compiler.
   2. Copy a template (search for "PROTOTYPE") to the end of the file.
   3. Change test name and file name in the prototype.
   4. Add in an AGS program that will be tested.
   5. Uncomment the "WriteOutput(" line of the test, run the test.
      The parser should not emit an error (do these tests elsewhere).
   6. A file has now been written. Copy its content immediately above
      the closing brace of the test. This will copy the code that
      is generated by the old compiler, byte-for-byte, into the googletest.
   7. Comment out the "WriteOutput(" line again (important).
   8. Copy the test to the clipboard.
   9. Head over to the version that has the rewritten compiler.
   10. Paste the test from the clipboard to the testfile of this version.
   11. Run the test.
       If the parser emits an error, the test will fail.
       If the parser emits Bytecode that is different in any way,
       the test will point out the first code that is different and fail.

   If a test generates wrong code, often a good way to debug it is as follows:
   - Uncomment the "WriteOutput(" line and run the test; now you have the bytes
     that the _new_ compiler emits in the file. Compare it by hand to the code
     that's in the test. See what the problem is: Has the new compiler left
     opcodes out, or has it added some in? Has it changed a single value somewhere?
   - Find the line with "iii" in cs_compiledscript.cpp and put a breakpoint there.
     (Uncomment that piece of code if it is commented out.)
   - Modify that piece of code so that the debugger will break as soon as the
     compiler generates the last byte that is still correct.
   - Debug test:
     Trace along from the breakpoint and find the point where the logic fails.

   But bear in mind:
   - Sometimes the compiler emits some code, then rips it out and stashes it away,
     then, later on, retrieves it and emits it again.
   - Sometimes the compiler emits some code value (usually 0), then
     patches it afterwards.
   In both cases, the logic will _not_ pass through function write_cmd()
   when the code is touched the second time! These are the hard cases to debug. :)
*/


// NOTE! If any "WriteOutput" lines in this file are uncommented, then the 
//  #define below _must_ be changed to a local writable temp dir. 
// (If you only want to run the tests to see if any tests fail, you do NOT 
// need that dir and you do NOT need any local files whatsoever.)
# define LOCAL_PATH "C:\\TEMP\\"

extern void clear_error();
extern const char *last_seen_cc_error();
extern ccCompiledScript *newScriptFixture();

// from cs_parser_test.cpp, provide "ready-made" code chunks to be included in tests
extern char g_Input_Bool[], g_Input_String[];

std::string Esc(const char ch)
{
    static const char *tohex = "0123456789abcdef";

    if (ch >= ' ' && ch <= 126)
    {
        return std::string(1, ch);
    }

    switch (ch)
    {
    default:
    {
        std::string ret = "\\x";
        ret.push_back(tohex[ch / 16]);
        ret.push_back(tohex[ch % 16]);
        return ret;
    }
    case '\a': return "\\a";
    case '\b': return "\\b";
    case '\f': return "\\f";
    case '\n': return "\\n";
    case '\r': return "\\r";
    case '\v': return "\\v";
    case '\'': return "\\\'";
    case '\"': return "\\\"";
    case '\\': return "\\\\";
    }
}

std::string EscapeString(const char *in)
{
    if (in == nullptr)
        return "0";

    std::string ret = "";
    size_t const in_len = strlen(in);
    for (size_t idx = 0; idx < in_len; idx++)
        ret += Esc(in[idx]);
    return "\"" + ret + "\"";
}

void WriteOutputCode(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t codesize = " << scrip->codesize << ";" << std::endl;
    of << "EXPECT_EQ(codesize, scrip->codesize);" << std::endl << std::endl;

    if (scrip->codesize == 0)
        return;

    of << "intptr_t code[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->codesize; idx++)
    {
        of.width(4);
        of << scrip->code[idx] << ", ";
        if (idx % 8 == 3) of << "        ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " -999 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < codesize; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->codesize) break;" << std::endl;
    of << "     std::string prefix = \"code[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + std::to_string(code[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->code[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;

}

void WriteOutputFixups(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t numfixups = " << scrip->numfixups << ";" << std::endl;
    of << "EXPECT_EQ(numfixups, scrip->numfixups);" << std::endl << std::endl;

    if (scrip->numfixups == 0)
        return;

    of << "intptr_t fixups[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->numfixups; idx++)
    {
        of.width(4);
        of << scrip->fixups[idx] << ", ";
        if (idx % 8 == 3) of << "      ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " -999 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numfixups; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numfixups) break;" << std::endl;
    of << "     std::string prefix = \"fixups[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string   is_val = prefix + std::to_string(fixups[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->fixups[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;

    of << "char fixuptypes[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->numfixups; idx++)
    {
        of.width(3);
        of << static_cast<int>(scrip->fixuptypes[idx]) << ", ";
        if (idx % 8 == 3) of << "   ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << " '\\0' " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numfixups; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numfixups) break;" << std::endl;
    of << "     std::string prefix = \"fixuptypes[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string   is_val = prefix + std::to_string(fixuptypes[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputImports(std::ofstream &of, ccCompiledScript *scrip)
{
    // Unfortunately, imports can contain empty strings that
    // mustn't be counted. So we can't just believe numimports,
    // and we can't check against scrip->numimports.
    size_t realNumImports = 0;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
        if (0 != strcmp(scrip->imports[idx], ""))
            ++realNumImports;

    of << "const int numimports = " << realNumImports << ";" << std::endl;

    of << "std::string imports[] = {" << std::endl;

    size_t linelen = 0;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;

        std::string item = EscapeString(scrip->imports[idx]);
        item += ",";
        item += std::string(15 - (item.length() % 15), ' ');
        of << item;
        linelen += item.length();
        if (linelen >= 75)
        {
            linelen = 0;
            of << "// " << idx << std::endl;
        }
    }
    of << " \"[[SENTINEL]]\" " << std::endl << "};" << std::endl << std::endl;

    of << "int idx2 = -1;" << std::endl;
    of << "for (size_t idx = 0; idx < scrip->numimports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (!strcmp(scrip->imports[idx], \"\"))" << std::endl;
    of << "         continue;" << std::endl;
    of << "     idx2++;" << std::endl;
    of << "     ASSERT_LT(idx2, numimports);" << std::endl;
    of << "     std::string prefix = \"imports[\";" << std::endl;
    // Note that the prefix has to be identical for is_val and test_val,
    // or ASSERT_EQ will always fail.
    of << "     prefix += std::to_string(idx2) + \"] == \";" << std::endl;
    of << "     std::string is_val   = prefix + scrip->imports[idx];" << std::endl;
    of << "     std::string test_val = prefix + imports[idx2];" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputExports(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t numexports = " << scrip->numexports << ";" << std::endl;
    of << "EXPECT_EQ(numexports, scrip->numexports);" << std::endl << std::endl;

    if (scrip->numexports == 0)
        return;

    of << "std::string exports[] = {" << std::endl;

    size_t linelen = 0;
    for (size_t idx = 0; idx < scrip->numexports; idx++)
    {
        std::string item = EscapeString(scrip->exports[idx]);
        item += ",";
        item += std::string(6 - (item.length() % 6), ' ');
        of << item;
        linelen += item.length();
        if (linelen >= 50)
        {
            linelen = 0;
            of << "// " << idx << std::endl;
        }
    }
    of << " \"[[SENTINEL]]\" " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numexports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numexports) break;" << std::endl;
    of << "     std::string prefix = \"exports[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + exports[idx];" << std::endl;
    of << "     std::string test_val = prefix + scrip->exports[idx];" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;


    of << "int32_t export_addr[] = {" << std::endl;

    for (size_t idx = 0; idx < scrip->numexports; idx++)
    {
        of.setf(std::ios::hex, std::ios::basefield);
        of.setf(std::ios::showbase);
        of.width(4);
        of << scrip->export_addr[idx] << ", ";
        if (idx % 4 == 1) of << "   ";
        if (idx % 8 == 3)
        {
            of.setf(std::ios::dec, std::ios::basefield);
            of.unsetf(std::ios::showbase);
            of.width(0);
            of << "// " << idx;
            of << std::endl;
        }
    }

    of.setf(std::ios::dec, std::ios::basefield);
    of.unsetf(std::ios::showbase);
    of.width(0);

    of << " 0 " << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < numexports; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->numexports) break;" << std::endl;
    of << "     std::string prefix = \"export_addr[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val   = prefix + std::to_string(export_addr[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->export_addr[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl << std::endl;
}

void WriteOutputStrings(std::ofstream &of, ccCompiledScript *scrip)
{
    of << "const size_t stringssize = " << scrip->stringssize << ";" << std::endl;
    of << "EXPECT_EQ(stringssize, scrip->stringssize);" << std::endl << std::endl;

    if (scrip->stringssize == 0)
        return;

    of << "char strings[] = {" << std::endl;
    for (size_t idx = 0; idx < scrip->stringssize; idx++)
    {
        std::string out = "";
        if (scrip->strings[idx] == 0)
            out = "  0";
        else
            out += '\'' + Esc(scrip->strings[idx]) + '\'';
        of << out << ",  ";
        if (idx % 8 == 3) of << "        ";
        if (idx % 8 == 7) of << "   // " << idx << std::endl;
    }
    of << "'\\0'" << std::endl << "};" << std::endl << std::endl;

    of << "for (size_t idx = 0; idx < stringssize; idx++)" << std::endl;
    of << "{" << std::endl;
    of << "     if (idx >= scrip->stringssize) break;" << std::endl;
    of << "     std::string prefix = \"strings[\";" << std::endl;
    of << "     prefix += std::to_string(idx) + \"] == \";" << std::endl;
    of << "     std::string is_val = prefix + std::to_string(strings[idx]);" << std::endl;
    of << "     std::string test_val = prefix + std::to_string(scrip->strings[idx]);" << std::endl;
    of << "     ASSERT_EQ(is_val, test_val);" << std::endl;
    of << "}" << std::endl;

}

void WriteOutput(char *fname, ccCompiledScript *scrip)
{
    std::string path = LOCAL_PATH;
    std::ofstream of;
    of.open(path.append(fname).append(".txt"));

    WriteOutputCode(of, scrip);
    WriteOutputFixups(of, scrip);
    WriteOutputImports(of, scrip);
    WriteOutputExports(of, scrip);
    WriteOutputStrings(of, scrip);

    of.close();
}

void WriteReducedOutput(char *fname, ccCompiledScript *scrip)
{
    std::string path = LOCAL_PATH;
    std::ofstream of;
    of.open(path.append(fname).append(".txt"));

    WriteOutputCode(of, scrip);
    WriteOutputFixups(of, scrip);

    of.close();
}

/*    PROTOTYPE

TEST(Bytecode, P_r_o_t_o_t_y_p_e) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo(int a)      \n\
        {                   \n\
            return a*a;     \n\
        }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("P_r_o_t_o_t_y_p_e", scrip);
    // run the test, comment out the previous line
    // and append its output below.
    // Then run the test in earnest after changes have been made to the code

}
*/

TEST(Bytecode, SimpleVoidFunction) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void Foo()          \n\
        {                   \n\
            return;         \n\
        }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("SimpleVoidFunction", scrip);
    // hand-checked Bytecode
    const size_t codesize = 5;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   31,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, SimpleIntFunction) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo()      \n\
    {                  \n\
        return 15;     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("SimpleIntFunction", scrip);
    // hand-checked Bytecode
    const size_t codesize = 11;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           15,   31,    3,    6,    // 7
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, IntFunctionLocalV) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo()      \n\
    {                  \n\
        int a = 15;    \n\
        return a;     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IntFunctionLocalV", scrip);
    // hand-checked Bytecode
    const size_t codesize = 28;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,   15,    // 7
      51,    4,    8,    3,           51,    4,    7,    3,    // 15
       2,    1,    4,   31,            6,    2,    1,    4,    // 23
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, IntFunctionParam) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Foo(int a) \n\
    {                  \n\
        return a;      \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IntFunctionParam", scrip);
    // hand-checked Bytecode
    const size_t codesize = 12;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   31,    3,    // 7
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, IntFunctionGlobalV) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int a = 15;    \n\
        int Foo( )     \n\
    {                  \n\
        return a;      \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IntFunctionGlobalV", scrip);
    // hand-checked Bytecode
    const size_t codesize = 13;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    2,            0,    7,    3,   31,    // 7
       3,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, FloatExpr1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        float a = 15.0;     \n\
        float Foo()         \n\
        {                   \n\
            float f = 3.14; \n\
            return a + f;   \n\
        }                   \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FloatExpr1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 43;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3, 1078523331,    // 7
      51,    4,    8,    3,            6,    2,    0,    7,    // 15
       3,   29,    3,   51,            8,    7,    3,   30,    // 23
       4,   57,    4,    3,            3,    4,    3,    2,    // 31
       1,    4,   31,    6,            2,    1,    4,    6,    // 39
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      14,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, FloatExpr2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        float a = 15.0;           \n\
        float Foo()               \n\
    {                             \n\
        float b = 22.2;           \n\
        int E1 = (3.14 < 1.34) == 1;         \n\
        short E2 = 0 == (1234.5 > 5.0) && 1; \n\
        long E3 = a <= 44.4;      \n\
        char E4 = 55.5 >= 44.4;   \n\
        int E5 = (((a == b) || (a != b))); \n\
        return a - b * (a / b);   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FloatExpr2", scrip);
    // hand-checked Bytecode 
    const size_t codesize = 264;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3, 1102158234,    // 7
      51,    4,    8,    3,            1,    1,    4,    6,    // 15
       3, 1078523331,   29,    3,            6,    3, 1068205343,   30,    // 23
       4,   60,    4,    3,            3,    4,    3,   29,    // 31
       3,    6,    3,    1,           30,    4,   15,    4,    // 39
       3,    3,    4,    3,           51,    4,    8,    3,    // 47
       1,    1,    2,    6,            3,    0,   29,    3,    // 55
       6,    3, 1150963712,   29,            3,    6,    3, 1084227584,    // 63
      30,    4,   59,    4,            3,    3,    4,    3,    // 71
      30,    4,   15,    4,            3,    3,    4,    3,    // 79
      28,   13,   29,    3,            6,    3,    1,   30,    // 87
       4,   21,    4,    3,            3,    4,    3,   51,    // 95
       2,   27,    3,    1,            1,    4,    6,    2,    // 103
       0,    7,    3,   29,            3,    6,    3, 1110546842,    // 111
      30,    4,   62,    4,            3,    3,    4,    3,    // 119
      51,    4,    8,    3,            1,    1,    1,    6,    // 127
       3, 1113456640,   29,    3,            6,    3, 1110546842,   30,    // 135
       4,   61,    4,    3,            3,    4,    3,   51,    // 143
       1,   26,    3,    1,            1,    4,    6,    2,    // 151
       0,    7,    3,   29,            3,   51,   23,    7,    // 159
       3,   30,    4,   15,            4,    3,    3,    4,    // 167
       3,   70,   29,   29,            3,    6,    2,    0,    // 175
       7,    3,   29,    3,           51,   27,    7,    3,    // 183
      30,    4,   16,    4,            3,    3,    4,    3,    // 191
      30,    4,   22,    4,            3,    3,    4,    3,    // 199
      51,    4,    8,    3,            6,    2,    0,    7,    // 207
       3,   29,    3,   51,           23,    7,    3,   29,    // 215
       3,    6,    2,    0,            7,    3,   29,    3,    // 223
      51,   31,    7,    3,           30,    4,   56,    4,    // 231
       3,    3,    4,    3,           30,    4,   55,    4,    // 239
       3,    3,    4,    3,           30,    4,   58,    4,    // 247
       3,    3,    4,    3,            2,    1,   19,   31,    // 255
       6,    2,    1,   19,            6,    3,    0,    5,    // 263
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
     104,  152,  175,  206,        219,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, IfThenElse1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo()               \n\
    {                       \n\
        int a = 15 - 4 * 2; \n\
        if (a < 5)          \n\
            a >>= 2;        \n\
        else                \n\
            a <<= 3;        \n\
        return a;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfThenElse1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 107;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,   15,    // 7
      29,    3,    6,    3,            4,   29,    3,    6,    // 15
       3,    2,   30,    4,            9,    4,    3,    3,    // 23
       4,    3,   30,    4,           12,    4,    3,    3,    // 31
       4,    3,   51,    4,            8,    3,   51,    4,    // 39
       7,    3,   29,    3,            6,    3,    5,   30,    // 47
       4,   18,    4,    3,            3,    4,    3,   28,    // 55
      18,    6,    3,    2,           29,    3,   51,    8,    // 63
       7,    3,   30,    4,           44,    3,    4,    8,    // 71
       3,   31,   16,    6,            3,    3,   29,    3,    // 79
      51,    8,    7,    3,           30,    4,   43,    3,    // 87
       4,    8,    3,   51,            4,    7,    3,    2,    // 95
       1,    4,   31,    6,            2,    1,    4,    6,    // 103
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, IfThenElse2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo()               \n\
    {                       \n\
        int a = 15 - 4 % 2; \n\
        if (a >= 5) {       \n\
            a -= 2;         \n\
        } else {            \n\
            a += 3;         \n\
        }                   \n\
        return a;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfThenElse2", scrip);
    // hand-checked Bytecode
    const size_t codesize = 107;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,   15,    // 7
      29,    3,    6,    3,            4,   29,    3,    6,    // 15
       3,    2,   30,    4,           40,    4,    3,    3,    // 23
       4,    3,   30,    4,           12,    4,    3,    3,    // 31
       4,    3,   51,    4,            8,    3,   51,    4,    // 39
       7,    3,   29,    3,            6,    3,    5,   30,    // 47
       4,   19,    4,    3,            3,    4,    3,   28,    // 55
      18,    6,    3,    2,           29,    3,   51,    8,    // 63
       7,    3,   30,    4,           12,    3,    4,    8,    // 71
       3,   31,   16,    6,            3,    3,   29,    3,    // 79
      51,    8,    7,    3,           30,    4,   11,    3,    // 87
       4,    8,    3,   51,            4,    7,    3,    2,    // 95
       1,    4,   31,    6,            2,    1,    4,    6,    // 103
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, While) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    char c = 'x';             \n\
    int Foo(int i, float f)   \n\
    {                         \n\
        int sum = 0;          \n\
        while (c >= 0)        \n\
        {                     \n\
            sum += (500 & c); \n\
            c--;              \n\
            if (c == 1) continue; \n\
        }                     \n\
        return sum;           \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("While", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 116;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    0,    // 7
      51,    4,    8,    3,            6,    2,    0,   24,    // 15
       3,   29,    3,    6,            3,    0,   30,    4,    // 23
      19,    4,    3,    3,            4,    3,   28,   68,    // 31
       6,    3,  500,   29,            3,    6,    2,    0,    // 39
      24,    3,   30,    4,           13,    4,    3,    3,    // 47
       4,    3,   29,    3,           51,    8,    7,    3,    // 55
      30,    4,   11,    3,            4,    8,    3,    6,    // 63
       2,    0,   24,    3,            2,    3,    1,   26,    // 71
       3,    6,    2,    0,           24,    3,   29,    3,    // 79
       6,    3,    1,   30,            4,   15,    4,    3,    // 87
       3,    4,    3,   28,            5,    6,    3,    0,    // 95
      31,  -86,   31,  -88,           51,    4,    7,    3,    // 103
       2,    1,    4,   31,            6,    2,    1,    4,    // 111
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      14,   39,   65,   75,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}



TEST(Bytecode, DoNCall) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    char c = 'x';             \n\
    int Foo(int i)            \n\
    {                         \n\
        int sum = 0;          \n\
        do                    \n\
        {                     \n\
            sum -= (500 | c); \n\
            c--;              \n\
        }                     \n\
        while (c > 0);        \n\
        return sum;           \n\
    }                         \n\
                              \n\
    int Bar(int x)            \n\
    {                         \n\
        return Foo(x^x);      \n\
    }                         \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("DoNCall", scrip);
    // hand-checked bytecode
    const size_t codesize = 129;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    0,    // 7
      51,    4,    8,    3,           31,    2,   31,   61,    // 15
       6,    3,  500,   29,            3,    6,    2,    0,    // 23
      24,    3,   30,    4,           14,    4,    3,    3,    // 31
       4,    3,   29,    3,           51,    8,    7,    3,    // 39
      30,    4,   12,    3,            4,    8,    3,    6,    // 47
       2,    0,   24,    3,            2,    3,    1,   26,    // 55
       3,    6,    2,    0,           24,    3,   29,    3,    // 63
       6,    3,    0,   30,            4,   17,    4,    3,    // 71
       3,    4,    3,   70,          -61,   51,    4,    7,    // 79
       3,    2,    1,    4,           31,    6,    2,    1,    // 87
       4,    6,    3,    0,            5,   38,   93,   51,    // 95
       8,    7,    3,   29,            3,   51,   12,    7,    // 103
       3,   30,    4,   41,            4,    3,    3,    4,    // 111
       3,   29,    3,    6,            3,    0,   23,    3,    // 119
       2,    1,    4,   31,            3,    6,    3,    0,    // 127
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      23,   49,   59,  117,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   2,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, DoUnbracedIf) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    void noloopcheck main()   \n\
    {                         \n\
        int sum = 0;          \n\
        do                    \n\
            if (sum < 100)    \n\
                sum += 10;    \n\
            else              \n\
                break;        \n\
        while (sum >= -1);    \n\
    }                         \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("DoUnbracedIf", scrip);
    // hand-checked bytecode 
    const size_t codesize = 82;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   68,    1,            1,    4,    6,    3,    // 7
       0,   51,    4,    8,            3,   31,    2,   31,    // 15
      61,   51,    4,    7,            3,   29,    3,    6,    // 23
       3,  100,   30,    4,           18,    4,    3,    3,    // 31
       4,    3,   28,   18,            6,    3,   10,   29,    // 39
       3,   51,    8,    7,            3,   30,    4,   11,    // 47
       3,    4,    8,    3,           31,    5,    6,    3,    // 55
       0,   31,  -44,   51,            4,    7,    3,   29,    // 63
       3,    6,    3,   -1,           30,    4,   19,    4,    // 71
       3,    3,    4,    3,           70,  -61,    2,    1,    // 79
       4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Bytecode, For1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int loop;                       \n\
    int Foo(int i, float f)         \n\
    {                               \n\
        for (loop = 0; loop < 10; loop += 3)  \n\
        {                           \n\
            int sum = loop - 4 - 7; \n\
            if (loop == 6) break;   \n\
        }                           \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 127;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,    6,    2,    0,    // 7
       8,    3,    6,    2,            0,    7,    3,   29,    // 15
       3,    6,    3,   10,           30,    4,   18,    4,    // 23
       3,    3,    4,    3,           28,   88,    1,    1,    // 31
       4,    6,    2,    0,            7,    3,   29,    3,    // 39
       6,    3,    4,   30,            4,   12,    4,    3,    // 47
       3,    4,    3,   29,            3,    6,    3,    7,    // 55
      30,    4,   12,    4,            3,    3,    4,    3,    // 63
      51,    4,    8,    3,            6,    2,    0,    7,    // 71
       3,   29,    3,    6,            3,    6,   30,    4,    // 79
      15,    4,    3,    3,            4,    3,   28,    8,    // 87
       2,    1,    4,    6,            3,    0,   31,  -68,    // 95
       2,    1,    4,    6,            3,    3,   29,    3,    // 103
       6,    2,    0,    7,            3,   30,    4,   11,    // 111
       3,    4,    8,    3,           31, -108,    6,    3,    // 119
       0,   31,    3,    6,            3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   12,   35,   70,        106,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, For2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)         \n\
    {                               \n\
        int lp, sum;                \n\
        for (; ; lp += 1)           \n\
            sum += lp;              \n\
        for ( ;; )                  \n\
            sum -= lp;              \n\
        for (; lp < 2; lp += 3)     \n\
            sum *= lp;              \n\
        for (; lp < 4; )            \n\
            sum /= lp;              \n\
        for (lp = 5; ; lp += 6)     \n\
            sum /= lp;              \n\
        for (int loop = 7; ; )      \n\
            sum &= loop;            \n\
        for (int loop = 8; loop < 9; )  \n\
            sum |= loop;            \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For2", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 322;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,   51,    0,   63,            4,    1,    1,    4,    // 15
       6,    3,    1,   28,           35,   51,    8,    7,    // 23
       3,   29,    3,   51,            8,    7,    3,   30,    // 31
       4,   11,    3,    4,            8,    3,    6,    3,    // 39
       1,   29,    3,   51,           12,    7,    3,   30,    // 47
       4,   11,    3,    4,            8,    3,   31,  -40,    // 55
       6,    3,    1,   28,           19,   51,    8,    7,    // 63
       3,   29,    3,   51,            8,    7,    3,   30,    // 71
       4,   12,    3,    4,            8,    3,   31,  -24,    // 79
      51,    8,    7,    3,           29,    3,    6,    3,    // 87
       2,   30,    4,   18,            4,    3,    3,    4,    // 95
       3,   28,   35,   51,            8,    7,    3,   29,    // 103
       3,   51,    8,    7,            3,   30,    4,    9,    // 111
       3,    4,    8,    3,            6,    3,    3,   29,    // 119
       3,   51,   12,    7,            3,   30,    4,   11,    // 127
       3,    4,    8,    3,           31,  -54,   51,    8,    // 135
       7,    3,   29,    3,            6,    3,    4,   30,    // 143
       4,   18,    4,    3,            3,    4,    3,   28,    // 151
      19,   51,    8,    7,            3,   29,    3,   51,    // 159
       8,    7,    3,   30,            4,   10,    3,    4,    // 167
       8,    3,   31,  -38,            6,    3,    5,   51,    // 175
       8,    8,    3,    6,            3,    1,   28,   35,    // 183
      51,    8,    7,    3,           29,    3,   51,    8,    // 191
       7,    3,   30,    4,           10,    3,    4,    8,    // 199
       3,    6,    3,    6,           29,    3,   51,   12,    // 207
       7,    3,   30,    4,           11,    3,    4,    8,    // 215
       3,   31,  -40,    1,            1,    4,    6,    3,    // 223
       7,   51,    4,    8,            3,    6,    3,    1,    // 231
      28,   19,   51,    4,            7,    3,   29,    3,    // 239
      51,   12,    7,    3,           30,    4,   13,    3,    // 247
       4,    8,    3,   31,          -24,    2,    1,    4,    // 255
       1,    1,    4,    6,            3,    8,   51,    4,    // 263
       8,    3,   51,    4,            7,    3,   29,    3,    // 271
       6,    3,    9,   30,            4,   18,    4,    3,    // 279
       3,    4,    3,   28,           19,   51,    4,    7,    // 287
       3,   29,    3,   51,           12,    7,    3,   30,    // 295
       4,   14,    3,    4,            8,    3,   31,  -38,    // 303
       2,    1,    4,    6,            3,    0,    2,    1,    // 311
       8,   31,    6,    2,            1,    8,    6,    3,    // 319
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, For3) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct           \n\
    {                               \n\
        float Payload[1];           \n\
    };                              \n\
    Struct *S;                      \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        for (Struct *loop; ;)       \n\
        {                           \n\
            return ((loop == S));   \n\
        }                           \n\
        return -7;                  \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For3", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 58;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,    6,    3,    1,           28,   29,   51,    4,    // 15
      48,    3,   29,    3,            6,    2,    0,   48,    // 23
       3,   30,    4,   15,            4,    3,    3,    4,    // 31
       3,   51,    4,   49,            2,    1,    4,   31,    // 39
      16,   31,  -34,   51,            4,   49,    2,    1,    // 47
       4,    6,    3,   -7,           31,    3,    6,    3,    // 55
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      22,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, For4) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    void main()                     \n\
    {                               \n\
        for (int loop = 0; loop < 10; loop++)  \n\
            if (loop == 5)          \n\
                continue;           \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For4", scrip);
    // hand-checked Bytecode
    const size_t codesize = 79;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    0,    // 7
      51,    4,    8,    3,           51,    4,    7,    3,    // 15
      29,    3,    6,    3,           10,   30,    4,   18,    // 23
       4,    3,    3,    4,            3,   28,   44,   51,    // 31
       4,    7,    3,   29,            3,    6,    3,    5,    // 39
      30,    4,   15,    4,            3,    3,    4,    3,    // 47
      28,   14,   51,    4,            7,    3,    1,    3,    // 55
       1,    8,    3,    6,            3,    0,   31,  -52,    // 63
      51,    4,    7,    3,            1,    3,    1,    8,    // 71
       3,   31,  -63,    2,            1,    4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, For5) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Start()                     \n\
        {                               \n\
            return 1;                   \n\
        }                               \n\
        int Check()                     \n\
        {                               \n\
            return 10;                  \n\
        }                               \n\
        int Cont(int x)                 \n\
        {                               \n\
            return x+1;                 \n\
        }                               \n\
                                        \n\
        void main()                     \n\
        {                               \n\
            for(int i = Start(); i < Check(); i = Cont(i))   \n\
                if (i >= 0)             \n\
                    continue;           \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For5", scrip);
    // hand-checked Bytecode
    const size_t codesize = 148;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            1,   31,    3,    6,    // 7
       3,    0,    5,   38,           11,    6,    3,   10,    // 15
      31,    3,    6,    3,            0,    5,   38,   22,    // 23
      51,    8,    7,    3,           29,    3,    6,    3,    // 31
       1,   30,    4,   11,            4,    3,    3,    4,    // 39
       3,   31,    3,    6,            3,    0,    5,   38,    // 47
      47,    1,    1,    4,            6,    3,    0,   23,    // 55
       3,   51,    4,    8,            3,   51,    4,    7,    // 63
       3,   29,    3,    6,            3,   11,   23,    3,    // 71
      30,    4,   18,    4,            3,    3,    4,    3,    // 79
      28,   62,   51,    4,            7,    3,   29,    3,    // 87
       6,    3,    0,   30,            4,   19,    4,    3,    // 95
       3,    4,    3,   28,           23,   51,    4,    7,    // 103
       3,   29,    3,    6,            3,   22,   23,    3,    // 111
       2,    1,    4,   51,            4,    8,    3,    6,    // 119
       3,    0,   31,  -63,           51,    4,    7,    3,    // 127
      29,    3,    6,    3,           22,   23,    3,    2,    // 135
       1,    4,   51,    4,            8,    3,   31,  -83,    // 143
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      54,   69,  109,  132,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   2,   2,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, For6) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void main()                     \n\
        {                               \n\
            for(int i = Start(); i < Check(); i = Cont(i))   \n\
                if (i >= 0)             \n\
                    continue;           \n\
        }                               \n\
        int Start()                     \n\
        {                               \n\
            return 1;                   \n\
        }                               \n\
        int Check()                     \n\
        {                               \n\
            return 10;                  \n\
        }                               \n\
        int Cont(int x)                 \n\
        {                               \n\
            return x + 1;               \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For6", scrip);
    // hand-checked Bytecode
    const size_t codesize = 148;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,  101,    // 7
      23,    3,   51,    4,            8,    3,   51,    4,    // 15
       7,    3,   29,    3,            6,    3,  112,   23,    // 23
       3,   30,    4,   18,            4,    3,    3,    4,    // 31
       3,   28,   62,   51,            4,    7,    3,   29,    // 39
       3,    6,    3,    0,           30,    4,   19,    4,    // 47
       3,    3,    4,    3,           28,   23,   51,    4,    // 55
       7,    3,   29,    3,            6,    3,  123,   23,    // 63
       3,    2,    1,    4,           51,    4,    8,    3,    // 71
       6,    3,    0,   31,          -63,   51,    4,    7,    // 79
       3,   29,    3,    6,            3,  123,   23,    3,    // 87
       2,    1,    4,   51,            4,    8,    3,   31,    // 95
     -83,    2,    1,    4,            5,   38,  101,    6,    // 103
       3,    1,   31,    3,            6,    3,    0,    5,    // 111
      38,  112,    6,    3,           10,   31,    3,    6,    // 119
       3,    0,    5,   38,          123,   51,    8,    7,    // 127
       3,   29,    3,    6,            3,    1,   30,    4,    // 135
      11,    4,    3,    3,            4,    3,   31,    3,    // 143
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   22,   62,   85,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   2,   2,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, For7) {
    ccCompiledScript *scrip = newScriptFixture();

    // Initializer and iterator of a for() need not be assignments,
    // they can be func calls.

    char *inpl = "\
        int i;                          \n\
        void main()                     \n\
        {                               \n\
            for(Start(); Check(); Cont())   \n\
                if (i >= 5)             \n\
                    i = 100 - i;        \n\
        }                               \n\
        short Start()                   \n\
        {                               \n\
            i = 1;                      \n\
            return -77;                 \n\
        }                               \n\
        int Check()                     \n\
        {                               \n\
            return i < 10;              \n\
        }                               \n\
        void Cont()                     \n\
        {                               \n\
            i++;                        \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("For7", scrip);
    // hand-checked Bytecode
    const size_t codesize = 123;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           65,   23,    3,    6,    // 7
       3,   84,   23,    3,           28,   50,    6,    2,    // 15
       0,    7,    3,   29,            3,    6,    3,    5,    // 23
      30,    4,   19,    4,            3,    3,    4,    3,    // 31
      28,   23,    6,    3,          100,   29,    3,    6,    // 39
       2,    0,    7,    3,           30,    4,   12,    4,    // 47
       3,    3,    4,    3,            6,    2,    0,    8,    // 55
       3,    6,    3,  110,           23,    3,   31,  -57,    // 63
       5,   38,   65,    6,            3,    1,    6,    2,    // 71
       0,    8,    3,    6,            3,  -77,   31,    3,    // 79
       6,    3,    0,    5,           38,   84,    6,    2,    // 87
       0,    7,    3,   29,            3,    6,    3,   10,    // 95
      30,    4,   18,    4,            3,    3,    4,    3,    // 103
      31,    3,    6,    3,            0,    5,   38,  110,    // 111
       6,    2,    0,    7,            3,    1,    3,    1,    // 119
       8,    3,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 9;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,    9,   16,   41,         54,   59,   72,   88,    // 7
     114,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   1,   1,      1,   2,   1,   1,    // 7
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, IfDoWhile) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)                      \n\
    {                                            \n\
        int five = 5, sum, loop = -2;            \n\
        if (five < 10)                           \n\
            for (loop = 0; loop < 10; loop += 3) \n\
            {                                    \n\
                sum += loop;                     \n\
                if (loop == 6) return loop;      \n\
            }                                    \n\
        else                                     \n\
            do { loop += 1; } while (loop < 100);   \n\
        return 0;                                \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("IfDoWhile", scrip);
    // hand-checked Bytecode
    const size_t codesize = 193;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    5,    // 7
      51,    4,    8,    3,           51,    0,   63,    4,    // 15
       1,    1,    4,    1,            1,    4,    6,    3,    // 23
      -2,   51,    4,    8,            3,   51,   12,    7,    // 31
       3,   29,    3,    6,            3,   10,   30,    4,    // 39
      18,    4,    3,    3,            4,    3,   28,   91,    // 47
       6,    3,    0,   51,            4,    8,    3,   51,    // 55
       4,    7,    3,   29,            3,    6,    3,   10,    // 63
      30,    4,   18,    4,            3,    3,    4,    3,    // 71
      28,   63,   51,    4,            7,    3,   29,    3,    // 79
      51,   12,    7,    3,           30,    4,   11,    3,    // 87
       4,    8,    3,   51,            4,    7,    3,   29,    // 95
       3,    6,    3,    6,           30,    4,   15,    4,    // 103
       3,    3,    4,    3,           28,    9,   51,    4,    // 111
       7,    3,    2,    1,           12,   31,   73,    6,    // 119
       3,    3,   29,    3,           51,    8,    7,    3,    // 127
      30,    4,   11,    3,            4,    8,    3,   31,    // 135
     -82,   31,   39,   31,            2,   31,   35,    6,    // 143
       3,    1,   29,    3,           51,    8,    7,    3,    // 151
      30,    4,   11,    3,            4,    8,    3,   51,    // 159
       4,    7,    3,   29,            3,    6,    3,  100,    // 167
      30,    4,   18,    4,            3,    3,    4,    3,    // 175
      70,  -35,    6,    3,            0,    2,    1,   12,    // 183
      31,    6,    2,    1,           12,    6,    3,    0,    // 191
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Switch01) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Foo(int i, float f)         \n\
    {                               \n\
        switch (i * i)              \n\
        {                           \n\
        case 2: return 10; break;   \n\
        default: i *= 2; return i;  \n\
        case 3:                     \n\
        case 4: i = 0;              \n\
        case 5: i += 5 - i - 4;  break; \n\
        }                           \n\
        return 0;                   \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Switch01", scrip);
    // hand-checked Bytecode
    const size_t codesize = 173;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   12,    7,    3,           30,    4,    9,    4,    // 15
       3,    3,    4,    3,            3,    3,    4,   31,    // 23
      89,   31,  137,    6,            3,   10,   31,  140,    // 31
       6,    3,    0,   31,          -12,    6,    3,    2,    // 39
      29,    3,   51,   12,            7,    3,   30,    4,    // 47
       9,    3,    4,    8,            3,   51,    8,    7,    // 55
       3,   31,  113,    6,            3,    0,   51,    8,    // 63
       8,    3,    6,    3,            5,   29,    3,   51,    // 71
      12,    7,    3,   30,            4,   12,    4,    3,    // 79
       3,    4,    3,   29,            3,    6,    3,    4,    // 87
      30,    4,   12,    4,            3,    3,    4,    3,    // 95
      29,    3,   51,   12,            7,    3,   30,    4,    // 103
      11,    3,    4,    8,            3,    6,    3,    0,    // 111
      31,   50,   29,    4,            6,    3,    2,   30,    // 119
       4,   16,    3,    4,           28,  -99,   29,    4,    // 127
       6,    3,    3,   30,            4,   16,    3,    4,    // 135
      28,  -79,   29,    4,            6,    3,    4,   30,    // 143
       4,   16,    3,    4,           28,  -91,   29,    4,    // 151
       6,    3,    5,   30,            4,   16,    3,    4,    // 159
      28,  -96,   31, -127,            6,    3,    0,   31,    // 167
       3,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, FreeLocalPtr) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct S                  \n\
    {                                 \n\
        int i;                        \n\
    };                                \n\
                                      \n\
    int foo()                         \n\
    {                                 \n\
        S *sptr = new S;              \n\
                                      \n\
        for (int i = 0; i < 10; i++)  \n\
            sptr = new S;             \n\
    }                                 \n\
    ";
    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("FreeLocalPtr", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 76;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,   73,    3,    4,           51,    4,   47,    3,    // 15
       1,    1,    4,    6,            3,    0,   51,    4,    // 23
       8,    3,   51,    4,            7,    3,   29,    3,    // 31
       6,    3,   10,   30,            4,   18,    4,    3,    // 39
       3,    4,    3,   28,           18,   73,    3,    4,    // 47
      51,    8,   47,    3,           51,    4,    7,    3,    // 55
       1,    3,    1,    8,            3,   31,  -37,    2,    // 63
       1,    4,   51,    4,           49,    2,    1,    4,    // 71
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, StringOldstyle01) {
    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Sentinel1;              \n\
        string GLOBAL;              \n\
        int Sentinel2;              \n\
                                    \n\
        string MyFunction(int a)    \n\
        {                           \n\
            string x;               \n\
            char   Sentinel3;       \n\
            return GLOBAL;          \n\
        }                           \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StringOldstyle01", scrip);
    // hand-checked Bytecode
    const size_t codesize = 33;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,  200,    1,    1,    // 7
     200,   51,    0,   63,            1,    1,    1,    1,    // 15
       6,    2,    4,    7,            3,    2,    1,  201,    // 23
      31,    6,    2,    1,          201,    6,    3,    0,    // 31
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      18,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, StringOldstyle02) {

    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int sub(const string s) \n\
        {                       \n\
            return;             \n\
        }                       \n\
                                \n\
        int main()              \n\
        {                       \n\
            sub(\"Foo\");       \n\
        }                       \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StringOldstyle02", scrip);
    // hand-checked Bytecode
    const size_t codesize = 30;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,   31,    3,    6,    // 7
       3,    0,    5,   38,           11,    6,    3,    0,    // 15
      29,    3,    6,    3,            0,   23,    3,    2,    // 23
       1,    4,    6,    3,            0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      15,   20,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      3,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 4;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'F',  'o',  'o',    0,          '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }
}

TEST(Bytecode, Struct01) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct               \n\
    {                               \n\
        float Float;                \n\
        import int[] Func(int i);   \n\
    };                              \n\
                                    \n\
    int Ret[];                      \n\
                                    \n\
    int[] Struct::Func(int i)       \n\
    {                               \n\
        this.Float = 0.0;           \n\
        Ret = new int[5];           \n\
        return Ret;                 \n\
    }                               \n\
                                    \n\
    void main()                     \n\
    {                               \n\
        Struct S;                   \n\
        S.Func(-1);                 \n\
    }                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct01", scrip);
    // Hand-checked Bytecode
    const size_t codesize = 86;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,            4,    4,    0,    1,    // 7
       1,    4,    6,    3,            0,    3,    6,    2,    // 15
      52,    8,    3,    6,            3,    5,   72,    3,    // 23
       4,    0,    6,    2,            0,   47,    3,    6,    // 31
       2,    0,    7,    3,            2,    1,    4,   31,    // 39
       6,    2,    1,    4,            6,    3,    0,    5,    // 47
      38,   48,   51,    0,           63,    4,    1,    1,    // 55
       4,   51,    4,   29,            6,   29,    2,    6,    // 63
       3,   -1,   30,    2,           29,    3,   45,    2,    // 71
       6,    3,    0,   23,            3,    2,    1,    4,    // 79
      30,    6,    2,    1,            4,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      28,   33,   74,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Struct02) {
    ccCompiledScript *scrip = newScriptFixture();

    // test arrays; arrays in structs;
    // whether the namespace in structs is independent of the global namespace

    char *inpl = "\
    struct Struct1                  \n\
    {                               \n\
        int Array[17], Ix;          \n\
    };                              \n\
                                    \n\
    Struct1 S;                      \n\
    int Array[5];                   \n\
                                    \n\
    void main()                     \n\
    {                               \n\
        S.Ix = 5;                   \n\
        Array[2] = 3;               \n\
        S.Array[Array[2]] = 42;     \n\
        S.Array[S.Ix] = 19;         \n\
        return;                     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct02", scrip);
    // hand-checked Bytecode
    const size_t codesize = 101;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    6,    2,   68,    // 7
       8,    3,    6,    3,            3,   29,    3,    6,    // 15
       3,    2,   46,    3,            5,    6,    2,   72,    // 23
      32,    3,    4,   11,            2,    3,   30,    3,    // 31
       8,    3,    6,    3,           42,   29,    3,    6,    // 39
       3,    2,   46,    3,            5,    6,    2,   72,    // 47
      32,    3,    4,   11,            2,    3,    7,    3,    // 55
      46,    3,   17,    6,            2,    0,   32,    3,    // 63
       4,   11,    2,    3,           30,    3,    8,    3,    // 71
       6,    3,   19,   29,            3,    6,    2,   68,    // 79
       7,    3,   46,    3,           17,    6,    2,    0,    // 87
      32,    3,    4,   11,            2,    3,   30,    3,    // 95
       8,    3,   31,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 6;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   23,   47,   61,         79,   87,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Struct03) {
    ccCompiledScript *scrip = newScriptFixture();

    // test arrays; arrays in structs;
    // whether the namespace in structs is independent of the global namespace

    char *inpl = "\
    struct Struct1                  \n\
    {                               \n\
        int Array[17], Ix;          \n\
    } S;                            \n\
    int Array[5];                   \n\
                                    \n\
    void main()                     \n\
    {                               \n\
        S.Ix = 5;                   \n\
        Array[2] = 3;               \n\
        S.Array[Array[2]] = 42;     \n\
        S.Array[S.Ix] = 19;         \n\
        return;                     \n\
    }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct03", scrip);
    // hand-checked Bytecode
    const size_t codesize = 101;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            5,    6,    2,   68,    // 7
       8,    3,    6,    3,            3,   29,    3,    6,    // 15
       3,    2,   46,    3,            5,    6,    2,   72,    // 23
      32,    3,    4,   11,            2,    3,   30,    3,    // 31
       8,    3,    6,    3,           42,   29,    3,    6,    // 39
       3,    2,   46,    3,            5,    6,    2,   72,    // 47
      32,    3,    4,   11,            2,    3,    7,    3,    // 55
      46,    3,   17,    6,            2,    0,   32,    3,    // 63
       4,   11,    2,    3,           30,    3,    8,    3,    // 71
       6,    3,   19,   29,            3,    6,    2,   68,    // 79
       7,    3,   46,    3,           17,    6,    2,    0,    // 87
      32,    3,    4,   11,            2,    3,   30,    3,    // 95
       8,    3,   31,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 6;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   23,   47,   61,         79,   87,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Struct04) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        managed struct StructI                               \n\
        {                                                    \n\
            int k;                                           \n\
        };                                                   \n\
                                                             \n\
        struct StructO                                       \n\
        {                                                    \n\
            StructI *SI;                                     \n\
            StructI *SJ[3];                                  \n\
        };                                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
            StructO SO;                                      \n\
            SO.SI = new StructI;                             \n\
            SO.SI.k = 12345;                                 \n\
            StructO SOA[3];                                  \n\
            SOA[2].SI = new StructI;                         \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct04", scrip);
    // hand-checked Bytecode
    const size_t codesize = 120;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,   16,    1,    1,    // 7
      16,   73,    3,    4,           51,   16,   47,    3,    // 15
       6,    3, 12345,   29,            3,   51,   20,   52,    // 23
      48,    2,   30,    3,            8,    3,   51,    0,    // 31
      63,   48,    1,    1,           48,   73,    3,    4,    // 39
      29,    3,    6,    3,            2,   46,    3,    3,    // 47
      51,   52,   32,    3,           16,   11,    2,    3,    // 55
      30,    3,   47,    3,           29,    3,   51,   68,    // 63
      49,    1,    2,    4,           49,    1,    2,    4,    // 71
      49,    1,    2,    4,           49,   51,   52,    6,    // 79
       3,    3,   29,    2,           29,    3,   49,    1,    // 87
       2,    4,   49,    1,            2,    4,   49,    1,    // 95
       2,    4,   49,   30,            3,   30,    2,    1,    // 103
       2,   16,    2,    3,            1,   70,  -29,   30,    // 111
       3,    2,    1,   64,            6,    3,    0,    5,    // 119
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Struct05) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct StructO                                       \n\
        {                                                    \n\
            static import int StInt(int i);                  \n\
        };                                                   \n\
        StructO        S1;                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
             StructO        S2;                              \n\
             return S1.StInt(S2.StInt(7));                   \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct05", scrip);
    // hand-checked Bytecode
    const size_t codesize = 40;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    0,    1,    1,    // 7
       0,    6,    3,    7,           34,    3,   39,    1,    // 15
       6,    3,    0,   33,            3,   35,    1,   34,    // 23
       3,   39,    1,    6,            3,    0,   33,    3,    // 31
      35,    1,   31,    3,            6,    3,    0,    5,    // 39
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      18,   29,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "StructO::StInt^1",            "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Struct06) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        managed struct Struct0;                              \n\
                                                             \n\
        struct Struct1                                       \n\
        {                                                    \n\
            Struct0 *Array[];                                \n\
        };                                                   \n\
                                                             \n\
        managed struct Struct0                               \n\
        {                                                    \n\
            int Payload;                                     \n\
        };                                                   \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
             Struct1 S;                                      \n\
                                                             \n\
             S.Array = new Struct0[5];                       \n\
             S.Array[3].Payload ++;                          \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    WriteOutput("Struct06", scrip);
    // hand-checked Bytecode
    const size_t codesize = 60;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,    6,    3,    5,           72,    3,    4,    1,    // 15
      51,    4,   47,    3,           51,    4,   52,   48,    // 23
       2,   29,    2,    6,            3,    3,   71,    3,    // 31
      30,    2,   32,    3,            4,   11,    2,    3,    // 39
      52,   48,    2,    7,            3,    1,    3,    1,    // 47
       8,    3,   51,    4,           49,    2,    1,    4,    // 55
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);
}


TEST(Bytecode, Struct07) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct1                                       \n\
        {                                                    \n\
            int IPayload;                                    \n\
            char CPayload[3];                                \n\
        };                                                   \n\
                                                             \n\
        Struct1 S1[3];                                       \n\
                                                             \n\
        int main()                                           \n\
        {                                                    \n\
            S1[1].IPayload = 0;                              \n\
            S1[1].CPayload[0] = 'A';                         \n\
            S1[1].CPayload[1] = S1[1].CPayload[0] - 'A';     \n\
            S1[1].CPayload[0] --;                            \n\
            return 0;                                        \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct07", scrip);
    // hand-checked Bytecode
    const size_t codesize = 196;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,   29,    3,    6,    // 7
       3,    1,   46,    3,            3,    6,    2,    0,    // 15
      32,    3,    8,   11,            2,    3,   30,    3,    // 23
       8,    3,    6,    3,           65,   29,    3,    6,    // 31
       3,    1,   46,    3,            3,    6,    2,    0,    // 39
      32,    3,    8,   11,            2,    3,   29,    2,    // 47
       6,    3,    0,   46,            3,    3,   30,    2,    // 55
       1,    2,    4,   11,            2,    3,   30,    3,    // 63
      26,    3,    6,    3,            1,   46,    3,    3,    // 71
       6,    2,    0,   32,            3,    8,   11,    2,    // 79
       3,   29,    2,    6,            3,    0,   46,    3,    // 87
       3,   30,    2,    1,            2,    4,   11,    2,    // 95
       3,   24,    3,   29,            3,    6,    3,   65,    // 103
      30,    4,   12,    4,            3,    3,    4,    3,    // 111
      29,    3,    6,    3,            1,   46,    3,    3,    // 119
       6,    2,    0,   32,            3,    8,   11,    2,    // 127
       3,   29,    2,    6,            3,    1,   46,    3,    // 135
       3,   30,    2,    1,            2,    4,   11,    2,    // 143
       3,   30,    3,   26,            3,    6,    3,    1,    // 151
      46,    3,    3,    6,            2,    0,   32,    3,    // 159
       8,   11,    2,    3,           29,    2,    6,    3,    // 167
       0,   46,    3,    3,           30,    2,    1,    2,    // 175
       4,   11,    2,    3,           24,    3,    2,    3,    // 183
       1,   26,    3,    6,            3,    0,   31,    3,    // 191
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      15,   39,   74,  122,        157,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,   1,   1,      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Bytecode, Struct08) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Struct                                        \n\
        {                                                    \n\
            int k;                                           \n\
        };                                                   \n\
                                                             \n\
        struct Sub extends Struct                            \n\
        {                                                    \n\
            int l;                                           \n\
        };                                                   \n\
                                                             \n\
        int Func(this Sub *, int i, int j)                   \n\
        {                                                    \n\
            return !i || !(j) && this.k || (0 != this.l);    \n\
        }                                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Struct08", scrip);
    // hand-checked Bytecode
    const size_t codesize = 98;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,            4,    4,    0,    1,    // 7
       1,    4,   51,   12,            7,    3,   42,    3,    // 15
      70,   34,   29,    3,           51,   20,    7,    3,    // 23
      42,    3,   28,   16,           29,    3,    3,    6,    // 31
       2,   52,    7,    3,           30,    4,   21,    4,    // 39
       3,    3,    4,    3,           30,    4,   22,    4,    // 47
       3,    3,    4,    3,           70,   32,   29,    3,    // 55
       6,    3,    0,   29,            3,    3,    6,    2,    // 63
      52,    1,    2,    4,            7,    3,   30,    4,    // 71
      16,    4,    3,    3,            4,    3,   30,    4,    // 79
      22,    4,    3,    3,            4,    3,    2,    1,    // 87
       4,   31,    6,    2,            1,    4,    6,    3,    // 95
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func01) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func01", scrip);
    // hand-checked Bytecode
    const size_t codesize = 72;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,   51,    0,   63,            4,    1,    1,    4,    // 15
       1,    1,    4,   51,            8,   48,    3,   34,    // 23
       3,   51,   12,   48,            3,   34,    3,   39,    // 31
       2,    6,    3,    0,           33,    3,   35,    2,    // 39
      51,    4,    8,    3,           51,    4,    7,    3,    // 47
      51,   12,   49,   51,            8,   49,    2,    1,    // 55
      12,   31,   12,   51,           12,   49,   51,    8,    // 63
      49,    2,    1,   12,            6,    3,    0,    5,    // 71
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      35,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func02) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func02", scrip);
    // hand-checked Bytecode
    const size_t codesize = 72;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,   51,    0,   63,            4,    1,    1,    4,    // 15
       1,    1,    4,   51,            8,   48,    3,   34,    // 23
       3,   51,   12,   48,            3,   34,    3,   39,    // 31
       2,    6,    3,    0,           33,    3,   35,    2,    // 39
      51,    4,    8,    3,           51,    4,    7,    3,    // 47
      51,   12,   49,   51,            8,   49,    2,    1,    // 55
      12,   31,   12,   51,           12,   49,   51,    8,    // 63
      49,    2,    1,   12,            6,    3,    0,    5,    // 71
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      35,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func03) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
    managed struct Struct2          \n\
    {                               \n\
        char Payload2;              \n\
    };                              \n\
                                    \n\
    import int Func(Struct1 *S1, Struct2 *S2);  \n\
                                    \n\
    int Func(Struct1 *S1, Struct2 *S2)  \n\
    {                               \n\
        return 0;                   \n\
    }                               \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1;               \n\
        Struct2 *SS2;               \n\
        int Ret = Func(SS1, SS2);   \n\
        return Ret;                 \n\
    }                               \n\
   ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func03", scrip);
    // hand-checked Bytecode
    const size_t codesize = 106;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   50,    3,    // 7
      51,   12,    7,    3,           50,    3,    6,    3,    // 15
       0,   51,    8,   49,           51,   12,   49,   31,    // 23
       9,   51,    8,   49,           51,   12,   49,    6,    // 31
       3,    0,    5,   38,           35,   51,    0,   63,    // 39
       4,    1,    1,    4,           51,    0,   63,    4,    // 47
       1,    1,    4,    1,            1,    4,   51,    8,    // 55
      48,    3,   29,    3,           51,   16,   48,    3,    // 63
      29,    3,    6,    3,            0,   23,    3,    2,    // 71
       1,    8,   51,    4,            8,    3,   51,    4,    // 79
       7,    3,   51,   12,           49,   51,    8,   49,    // 87
       2,    1,   12,   31,           12,   51,   12,   49,    // 95
      51,    8,   49,    2,            1,   12,    6,    3,    // 103
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      68,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func04) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct1          \n\
    {                               \n\
        float Payload1;             \n\
    };                              \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct1 *SS1 = Func(5);     \n\
        return -1;                  \n\
    }                               \n\
                                    \n\
    Struct1 *Func(int Int)          \n\
    {                               \n\
        return new Struct1;         \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func04", scrip);
    // hand-checked Bytecode
    const size_t codesize = 58;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,    6,    3,    5,           29,    3,    6,    3,    // 15
      47,   23,    3,    2,            1,    4,   51,    4,    // 23
      47,    3,    6,    3,           -1,   51,    4,   49,    // 31
       2,    1,    4,   31,            9,   51,    4,   49,    // 39
       2,    1,    4,    6,            3,    0,    5,   38,    // 47
      47,   73,    3,    4,           31,    3,    6,    3,    // 55
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      16,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func05) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        int Func(int P1, int P2)     \n\
        {                            \n\
            return P1 + P2;          \n\
        }                            \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int = Func(4);       \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func05", scrip);
    // hand-checked Bytecode
    const size_t codesize = 57;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   11,    4,    // 15
       3,    3,    4,    3,           31,    3,    6,    3,    // 23
       0,    5,   38,   26,            1,    1,    4,    6,    // 31
       3,    5,   29,    3,            6,    3,    4,   29,    // 39
       3,    6,    3,    0,           23,    3,    2,    1,    // 47
       8,   51,    4,    8,            3,    2,    1,    4,    // 55
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      43,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func06) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func06", scrip);
    // hand-checked Bytecode
    const size_t codesize = 58;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    5,    // 7
      34,    3,    6,    3,            4,   34,    3,   39,    // 15
       2,    6,    3,    0,           33,    3,   35,    2,    // 23
      51,    4,    8,    3,            1,    1,    4,    6,    // 31
       3,    1,   34,    3,            6,    3,    4,   34,    // 39
       3,   39,    2,    6,            3,    0,   33,    3,    // 47
      35,    2,   51,    4,            8,    3,    2,    1,    // 55
       8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      19,   45,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func07) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
                                     \n\
        import int Func(int, int = 5); \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func07", scrip);
    // hand-checked Bytecode
    const size_t codesize = 58;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    5,    // 7
      34,    3,    6,    3,            4,   34,    3,   39,    // 15
       2,    6,    3,    0,           33,    3,   35,    2,    // 23
      51,    4,    8,    3,            1,    1,    4,    6,    // 31
       3,    1,   34,    3,            6,    3,    4,   34,    // 39
       3,   39,    2,    6,            3,    0,   33,    3,    // 47
      35,    2,   51,    4,            8,    3,    2,    1,    // 55
       8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      19,   45,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func08) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int f, int = 5); \n\
        import int Func(int, int = 5); \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int1 = Func(4);      \n\
            int Int2 = Func(4, 1);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func08", scrip);
    // hand-checked Bytecode
    const size_t codesize = 58;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    5,    // 7
      34,    3,    6,    3,            4,   34,    3,   39,    // 15
       2,    6,    3,    0,           33,    3,   35,    2,    // 23
      51,    4,    8,    3,            1,    1,    4,    6,    // 31
       3,    1,   34,    3,            6,    3,    4,   34,    // 39
       3,   39,    2,    6,            3,    0,   33,    3,    // 47
      35,    2,   51,    4,            8,    3,    2,    1,    // 55
       8,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      19,   45,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Func",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Bytecode, Func09) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Func(int, int = 5); \n\
                                     \n\
        int Func(int P1, int P2)     \n\
        {                            \n\
            return P1 + P2;          \n\
        }                            \n\
                                     \n\
        void main()                  \n\
        {                            \n\
            int Int = Func(4,-99);   \n\
        }                            \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func09", scrip);
    // hand-checked Bytecode
    const size_t codesize = 57;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   11,    4,    // 15
       3,    3,    4,    3,           31,    3,    6,    3,    // 23
       0,    5,   38,   26,            1,    1,    4,    6,    // 31
       3,  -99,   29,    3,            6,    3,    4,   29,    // 39
       3,    6,    3,    0,           23,    3,    2,    1,    // 47
       8,   51,    4,    8,            3,    2,    1,    4,    // 55
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      43,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Func10) {
    ccCompiledScript *scrip = newScriptFixture();

    // Note that currently, the compiler will add an empty local pointer variable
    // for the "this" pointer to each non-static struct function. This seems to be
    // in line with the former code but does not serve any useful function AFAICS.

    char *inpl = "\
    struct Struct                   \n\
    {                               \n\
        float Float;                \n\
        int Func();                 \n\
    };                              \n\
                                    \n\
    int Struct::Func()              \n\
    {                               \n\
        return 5;                   \n\
    }                               \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct s;                   \n\
        int Int = s.Func() % 3;     \n\
        return Int;                 \n\
    }                               \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func10", scrip);
    // hand-checked Bytecode
    const size_t codesize = 83;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,            4,    4,    0,    1,    // 7
       1,    4,    6,    3,            5,    2,    1,    4,    // 15
      31,    6,    2,    1,            4,    6,    3,    0,    // 23
       5,   38,   25,   51,            0,   63,    4,    1,    // 31
       1,    4,    1,    1,            4,   51,    8,   29,    // 39
       6,   45,    2,    6,            3,    0,   23,    3,    // 47
      30,    6,   29,    3,            6,    3,    3,   30,    // 55
       4,   40,    4,    3,            3,    4,    3,   51,    // 63
       4,    8,    3,   51,            4,    7,    3,    2,    // 71
       1,    8,   31,    6,            2,    1,    8,    6,    // 79
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      45,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Export) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    struct Struct                   \n\
    {                               \n\
        float Float;                \n\
        int Int;                    \n\
    };                              \n\
    Struct StructyStructy;          \n\
    export StructyStructy;          \n\
                                    \n\
    int Inty;                       \n\
    float Floaty;                   \n\
    export Floaty, Inty;            \n\
                                    \n\
    int main()                      \n\
    {                               \n\
        Struct s;                   \n\
        s.Int = 3;                  \n\
        s.Float = 1.1 / 2.2;        \n\
        return -2;                  \n\
    }                               \n\
    export main;                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Export", scrip);
    // hand-checked Bytecode
    const size_t codesize = 51;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    8,    1,    1,    // 7
       8,    6,    3,    3,           51,    4,    8,    3,    // 15
       6,    3, 1066192077,   29,            3,    6,    3, 1074580685,    // 23
      30,    4,   56,    4,            3,    3,    4,    3,    // 31
      51,    8,    8,    3,            6,    3,   -2,    2,    // 39
       1,    8,   31,    6,            2,    1,    8,    6,    // 47
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 4;
    EXPECT_EQ(numexports, scrip->numexports);

    std::string exports[] = {
    "StructyStructy", "Floaty",   "Inty",     "main$0",   // 3
     "[[SENTINEL]]"
    };

    for (size_t idx = 0; idx < numexports; idx++)
    {
        if (idx >= scrip->numexports) break;
        std::string prefix = "exports[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + exports[idx];
        std::string test_val = prefix + scrip->exports[idx];
        ASSERT_EQ(is_val, test_val);
    }

    int32_t export_addr[] = {
    0x2000000, 0x200000c,    0x2000008, 0x1000000, // 3
     0
    };

    for (size_t idx = 0; idx < numexports; idx++)
    {
        if (idx >= scrip->numexports) break;
        std::string prefix = "export_addr[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(export_addr[idx]);
        std::string test_val = prefix + std::to_string(scrip->export_addr[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, ArrayOfPointers1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        float Float;                     \n\
        protected int Int;               \n\
    };                                   \n\
    Struct *arr[50];                     \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        for (int i = 0; i < 9; i++)      \n\
            arr[i] = new Struct;         \n\
                                         \n\
        int test = (arr[10] == null);    \n\
    }                                    \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayOfPointers1", scrip);
    // hand checked Bytecode
    const size_t codesize = 114;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    0,    // 7
      51,    4,    8,    3,           51,    4,    7,    3,    // 15
      29,    3,    6,    3,            9,   30,    4,   18,    // 23
       4,    3,    3,    4,            3,   28,   36,   73,    // 31
       3,    8,   29,    3,           51,    8,    7,    3,    // 39
      46,    3,   50,    6,            2,    0,   32,    3,    // 47
       4,   11,    2,    3,           30,    3,   47,    3,    // 55
      51,    4,    7,    3,            1,    3,    1,    8,    // 63
       3,   31,  -55,    2,            1,    4,    1,    1,    // 71
       4,    6,    3,   10,           46,    3,   50,    6,    // 79
       2,    0,   32,    3,            4,   11,    2,    3,    // 87
      48,    3,   29,    3,            6,    3,    0,   30,    // 95
       4,   15,    4,    3,            3,    4,    3,   51,    // 103
       4,    8,    3,    2,            1,    4,    6,    3,    // 111
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      45,   81,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Bytecode, ArrayOfPointers2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        float Float;                     \n\
        protected int Int;               \n\
    };                                   \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        Struct *arr2[50];                \n\
        for (int i = 0; i < 20; i++) {   \n\
                arr2[i] = new Struct;    \n\
        }                                \n\
        arr2[5].Float = 2.2 - 0.0 * 3.3; \n\
        arr2[4] = null;                  \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayOfPointers2", scrip);
    // hand-checked bytecode
    const size_t codesize = 176;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,  200,    1,    1,    // 7
     200,    1,    1,    4,            6,    3,    0,   51,    // 15
       4,    8,    3,   51,            4,    7,    3,   29,    // 23
       3,    6,    3,   20,           30,    4,   18,    4,    // 31
       3,    3,    4,    3,           28,   35,   73,    3,    // 39
       8,   29,    3,   51,            8,    7,    3,   46,    // 47
       3,   50,   51,  208,           32,    3,    4,   11,    // 55
       2,    3,   30,    3,           47,    3,   51,    4,    // 63
       7,    3,    1,    3,            1,    8,    3,   31,    // 71
     -54,    2,    1,    4,            6,    3, 1074580685,   29,    // 79
       3,    6,    3,    0,           29,    3,    6,    3,    // 87
    1079194419,   30,    4,   55,            4,    3,    3,    4,    // 95
       3,   30,    4,   58,            4,    3,    3,    4,    // 103
       3,   29,    3,    6,            3,    5,   46,    3,    // 111
      50,   51,  204,   32,            3,    4,   11,    2,    // 119
       3,   52,   48,    2,           30,    3,    8,    3,    // 127
       6,    3,    0,   29,            3,    6,    3,    4,    // 135
      46,    3,   50,   51,          204,   32,    3,    4,    // 143
      11,    2,    3,   30,            3,   47,    3,   29,    // 151
       3,   51,  204,    6,            3,   50,   49,    1,    // 159
       2,    4,    2,    3,            1,   70,   -9,   30,    // 167
       3,    2,    1,  200,            6,    3,    0,    5,    // 175
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, ArrayInStruct) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    managed struct Struct                \n\
    {                                    \n\
        int Int[10];                     \n\
    };                                   \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        Struct *S = new Struct;          \n\
        S.Int[4] =  1;                   \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("ArrayInStruct", scrip);
    // hand checked Bytecode
    const size_t codesize = 56;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,   73,    3,   40,           51,    4,   47,    3,    // 15
       6,    3,    1,   29,            3,   51,    8,   52,    // 23
      48,    2,   29,    2,            6,    3,    4,   46,    // 31
       3,   10,   30,    2,           32,    3,    4,   11,    // 39
       2,    3,   30,    3,            8,    3,   51,    4,    // 47
      49,    2,    1,    4,            6,    3,    0,    5,    // 55
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}


TEST(Bytecode, Func11) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
    int Func(int I, ...)                 \n\
    {                                    \n\
        return I + I / I;                \n\
    }                                    \n\
                                         \n\
    int main()                           \n\
    {                                    \n\
        return 0;                        \n\
    }                                    \n\
    ";


    clear_error();
    int compileResult = cc_compile(inpl, scrip);
    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Func11", scrip);
    // hand-checked Bytecode
    const size_t codesize = 51;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   12,    7,    3,           29,    3,   51,   16,    // 15
       7,    3,   30,    4,           10,    4,    3,    3,    // 23
       4,    3,   30,    4,           11,    4,    3,    3,    // 31
       4,    3,   31,    3,            6,    3,    0,    5,    // 39
      38,   40,    6,    3,            0,   31,    3,    6,    // 47
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Writeprotected) {
    ccCompiledScript *scrip = newScriptFixture();

    // Directly taken from the doc on writeprotected, simplified.
    char *inpl = "\
        struct Weapon {                         \n\
            short Beauty;                       \n\
            writeprotected int Damage;          \n\
            import int SetDamage(int damage);   \n\
        } wp;                                   \n\
                                                \n\
        int  Weapon::SetDamage(int damage)      \n\
        {                                       \n\
            this.Damage = damage;               \n\
            return 0;                           \n\
        }                                       \n\
                                                \n\
        int main()                              \n\
        {                                       \n\
            return wp.Damage;                   \n\
        }                                       \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Writeprotected", scrip);
    // hand-checked Bytecode
    const size_t codesize = 51;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,            4,    4,    0,    1,    // 7
       1,    4,   51,   12,            7,    3,    3,    6,    // 15
       2,   52,    1,    2,            2,    8,    3,    6,    // 23
       3,    0,    2,    1,            4,   31,    6,    2,    // 31
       1,    4,    6,    3,            0,    5,   38,   38,    // 39
       6,    2,    2,    7,            3,   31,    3,    6,    // 47
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      42,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Protected1) {
    ccCompiledScript *scrip = newScriptFixture();

    // Directly taken from the doc on protected, simplified.
    char *inpl = "\
        struct Weapon {                        \n\
            protected int Damage;              \n\
            import int SetDamage(int damage);  \n\
        };                                     \n\
                                               \n\
        Weapon wp;                             \n\
                                               \n\
        int  Weapon::SetDamage(int damage)     \n\
        {                                      \n\
            this.Damage = damage;              \n\
            return 0;                          \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Protected1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 35;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,            4,    4,    0,    1,    // 7
       1,    4,   51,   12,            7,    3,    3,    6,    // 15
       2,   52,    8,    3,            6,    3,    0,    2,    // 23
       1,    4,   31,    6,            2,    1,    4,    6,    // 31
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Static1) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Weapon {                        \n\
            import static int CalcDamage(      \n\
                 int Lifepoints, int Hitpoints = 5);   \n\
        };                                     \n\
                                               \n\
        static int Weapon::CalcDamage(int Lifepoints, int Hitpoints)  \n\
        {                                      \n\
            return Lifepoints - Hitpoints;     \n\
        }                                      \n\
                                               \n\
        int main()                             \n\
        {                                      \n\
            int hp = Weapon.CalcDamage(9) + Weapon.CalcDamage(9, 40);  \n\
            return hp + Weapon.CalcDamage(100);  \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Static1", scrip);
    // hand-checked Bytecode
    const size_t codesize = 125;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   12,    4,    // 15
       3,    3,    4,    3,           31,    3,    6,    3,    // 23
       0,    5,   38,   26,            1,    1,    4,    6,    // 31
       3,    5,   29,    3,            6,    3,    9,   29,    // 39
       3,    6,    3,    0,           23,    3,    2,    1,    // 47
       8,   29,    3,    6,            3,   40,   29,    3,    // 55
       6,    3,    9,   29,            3,    6,    3,    0,    // 63
      23,    3,    2,    1,            8,   30,    4,   11,    // 71
       4,    3,    3,    4,            3,   51,    4,    8,    // 79
       3,   51,    4,    7,            3,   29,    3,    6,    // 87
       3,    5,   29,    3,            6,    3,  100,   29,    // 95
       3,    6,    3,    0,           23,    3,    2,    1,    // 103
       8,   30,    4,   11,            4,    3,    3,    4,    // 111
       3,    2,    1,    4,           31,    6,    2,    1,    // 119
       4,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      43,   63,   99,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Static2) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        struct Weapon {                        \n\
        };                                     \n\
                                               \n\
        int CalcDamage(static Weapon, int Lifepoints, int Hitpoints)  \n\
        {                                      \n\
            return Lifepoints - Hitpoints;     \n\
        }                                      \n\
                                               \n\
        int main()                             \n\
        {                                      \n\
            return Weapon.CalcDamage(9, 40);   \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Static2", scrip);
    // hand-checked Bytecode

    const size_t codesize = 52;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    8,            7,    3,   29,    3,    // 7
      51,   16,    7,    3,           30,    4,   12,    4,    // 15
       3,    3,    4,    3,           31,    3,    6,    3,    // 23
       0,    5,   38,   26,            6,    3,   40,   29,    // 31
       3,    6,    3,    9,           29,    3,    6,    3,    // 39
       0,   23,    3,    2,            1,    8,   31,    3,    // 47
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      40,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Protected2) {
    ccCompiledScript *scrip = newScriptFixture();

    // In a struct func, a variable that can't be found otherwise
    // should be taken to be out of the current struct.
    // (Note that this will currently compile to slightly more
    // inefficient code than "this.Damage = damage")

    char *inpl = "\
        struct Weapon {                        \n\
            protected int Damage;              \n\
            import int SetDamage(int damage);  \n\
        };                                     \n\
                                               \n\
        Weapon wp;                             \n\
                                               \n\
        int  Weapon::SetDamage(int damage)     \n\
        {                                      \n\
            Damage = damage;                   \n\
            return 0;                          \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Protected2", scrip);
    // hand-checked Bytecode
    const size_t codesize = 39;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,            4,    4,    0,    1,    // 7
       1,    4,   51,   12,            7,    3,   29,    3,    // 15
       3,    6,    2,   52,           30,    3,    8,    3,    // 23
       6,    3,    0,    2,            1,    4,   31,    6,    // 31
       2,    1,    4,    6,            3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Import) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        import int Weapon;                     \n\
                                               \n\
        int Func(int damage)                   \n\
        {                                      \n\
            int Int = 0;                       \n\
            Weapon = 77;                       \n\
            if (Weapon < 0)                    \n\
                Weapon = damage - (Int - Weapon) / Int; \n\
        }                                      \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Import", scrip);
    // hand-checked Bytecode
    const size_t codesize = 99;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    0,    // 7
      51,    4,    8,    3,            6,    3,   77,    6,    // 15
       2,    0,    8,    3,            6,    2,    0,    7,    // 23
       3,   29,    3,    6,            3,    0,   30,    4,    // 31
      18,    4,    3,    3,            4,    3,   28,   52,    // 39
      51,   12,    7,    3,           29,    3,   51,    8,    // 47
       7,    3,   29,    3,            6,    2,    0,    7,    // 55
       3,   30,    4,   12,            4,    3,    3,    4,    // 63
       3,   29,    3,   51,           12,    7,    3,   30,    // 71
       4,   10,    4,    3,            3,    4,    3,   30,    // 79
       4,   12,    4,    3,            3,    4,    3,    6,    // 87
       2,    0,    8,    3,            2,    1,    4,    6,    // 95
       3,    0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      17,   22,   54,   89,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,   4,   4,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Weapon",       "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Switch02) {
    ccCompiledScript *scrip = newScriptFixture();

    // Last switch clause no "break"
    char *inpl = "\
        void main()                     \n\
        {                               \n\
            int i = 5;                  \n\
            switch(i)                   \n\
            {                           \n\
            default: break;             \n\
            case 5: i = 0;              \n\
            }                           \n\
            return;                     \n\
        }                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Switch02", scrip);
    // hand-checked Bytecode
    const size_t codesize = 60;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,            4,    6,    3,    5,    // 7
      51,    4,    8,    3,           51,    4,    7,    3,    // 15
       3,    3,    4,   31,           16,   31,   28,    6,    // 23
       3,    0,   31,   -7,            6,    3,    0,   51,    // 31
       4,    8,    3,   31,           14,   29,    4,    6,    // 39
       3,    5,   30,    4,           16,    3,    4,   28,    // 47
     -21,   31,  -28,    2,            1,    4,   31,    3,    // 55
       2,    1,    4,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 0;
    EXPECT_EQ(numfixups, scrip->numfixups);

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Attributes01) {
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        enum bool { false = 0, true = 1 };              \n\
        builtin managed struct ViewFrame {              \n\
            readonly import attribute bool Flipped;     \n\
            import attribute int Graphic;               \n\
            readonly import attribute float AsFloat;    \n\
        };                                              \n\
                                                        \n\
        int main()                                      \n\
        {                                               \n\
            ViewFrame *VF;                              \n\
            if (VF.Flipped)                             \n\
            {                                           \n\
                VF.Graphic = 17;                        \n\
                float f = VF.AsFloat + VF.AsFloat;      \n\
                return VF.Graphic;                      \n\
            }                                           \n\
            return VF.Flipped;                          \n\
        }                                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Attributes01", scrip);
    // hand-checked bytecode
    const size_t codesize = 172;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,   51,    4,   52,           48,    2,   29,    6,    // 15
      45,    2,   39,    0,            6,    3,    0,   33,    // 23
       3,   30,    6,   28,          107,    6,    3,   17,    // 31
      51,    4,   52,   48,            2,   29,    6,   34,    // 39
       3,   45,    2,   39,            1,    6,    3,    2,    // 47
      33,    3,   35,    1,           30,    6,    1,    1,    // 55
       4,   51,    8,   52,           48,    2,   29,    6,    // 63
      45,    2,   39,    0,            6,    3,    3,   33,    // 71
       3,   30,    6,   29,            3,   51,   12,   52,    // 79
      48,    2,   29,    6,           45,    2,   39,    0,    // 87
       6,    3,    3,   33,            3,   30,    6,   30,    // 95
       4,   57,    4,    3,            3,    4,    3,   51,    // 103
       4,    8,    3,   51,            8,   52,   48,    2,    // 111
      29,    6,   45,    2,           39,    0,    6,    3,    // 119
       1,   33,    3,   30,            6,   51,    8,   49,    // 127
       2,    1,    8,   31,           38,    2,    1,    4,    // 135
      51,    4,   52,   48,            2,   29,    6,   45,    // 143
       2,   39,    0,    6,            3,    0,   33,    3,    // 151
      30,    6,   51,    4,           49,    2,    1,    4,    // 159
      31,    9,   51,    4,           49,    2,    1,    4,    // 167
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 6;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      22,   47,   70,   90,        120,  149,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,   4,   4,      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 4;
    std::string imports[] = {
    "ViewFrame::get_Flipped^0",   "ViewFrame::get_Graphic^0",   "ViewFrame::set_Graphic^1",   // 2
    "ViewFrame::get_AsFloat^0",    "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Attributes02) {
    ccCompiledScript *scrip = newScriptFixture();

    // The getter and setter functions are defined locally, so
    // they ought to be exported instead of imported.
    // Assigning the attribute should generate the same call
    // as calling the setter; reading the same as calling the getter.
    // Armor:: functions should be allowed to access _damage.

    char *inpl = "\
        managed struct Armor {                          \n\
            attribute int Damage;                       \n\
            writeprotected short _aura;                 \n\
            protected int _damage;                      \n\
        };                                              \n\
                                                        \n\
        int main()                                      \n\
        {                                               \n\
            Armor *armor = new Armor;                   \n\
            armor.Damage = 17;                          \n\
            return (armor.Damage > 10);                 \n\
        }                                               \n\
                                                        \n\
        void Armor::set_Damage(int damage)              \n\
        {                                               \n\
            if (damage >= 0)                            \n\
                _damage = damage;                       \n\
        }                                               \n\
                                                        \n\
        int Armor::get_Damage()                         \n\
        {                                               \n\
            return _damage;                             \n\
        }                                               \n\
        ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Attributes02", scrip);
    // hand-checked bytecode
    const size_t codesize = 168;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,   73,    3,    8,           51,    4,   47,    3,    // 15
       6,    3,   17,   51,            4,   52,   48,    2,    // 23
      29,    6,   29,    3,           45,    2,    6,    3,    // 31
      87,   23,    3,    2,            1,    4,   30,    6,    // 39
      51,    4,   52,   48,            2,   29,    6,   45,    // 47
       2,    6,    3,  137,           23,    3,   30,    6,    // 55
      29,    3,    6,    3,           10,   30,    4,   17,    // 63
       4,    3,    3,    4,            3,   51,    4,   49,    // 71
       2,    1,    4,   31,            9,   51,    4,   49,    // 79
       2,    1,    4,    6,            3,    0,    5,   38,    // 87
      87,   51,    0,    4,            4,    0,    1,    1,    // 95
       4,   51,   12,    7,            3,   29,    3,    6,    // 103
       3,    0,   30,    4,           19,    4,    3,    3,    // 111
       4,    3,   28,   17,           51,   12,    7,    3,    // 119
      29,    3,    3,    6,            2,   52,    1,    2,    // 127
       2,   30,    3,    8,            3,    2,    1,    4,    // 135
       5,   38,  137,   51,            0,    4,    4,    0,    // 143
       1,    1,    4,    3,            6,    2,   52,    1,    // 151
       2,    2,    7,    3,            2,    1,    4,   31,    // 159
       6,    2,    1,    4,            6,    3,    0,    5,    // 167
     -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      32,   51,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      2,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Attributes03) {
    ccCompiledScript *scrip = newScriptFixture();

    // The getters and setters are NOT defined locally, so
    // import decls should be generated for them.
    // The getters and setters should be called as import funcs.

    char *inpl = "\
        managed struct Armor {                          \n\
            attribute int Damage;                       \n\
            writeprotected short _aura;                 \n\
            protected int _damage;                      \n\
        };                                              \n\
                                                        \n\
        int main()                                      \n\
        {                                               \n\
            Armor *armor = new Armor;                   \n\
            armor.Damage = 17;                          \n\
            return (armor.Damage > 10);                 \n\
        }";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("Attributes03", scrip);
    // hand-checked bytecode
    const size_t codesize = 90;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,   73,    3,    8,           51,    4,   47,    3,    // 15
       6,    3,   17,   51,            4,   52,   48,    2,    // 23
      29,    6,   34,    3,           45,    2,   39,    1,    // 31
       6,    3,    1,   33,            3,   35,    1,   30,    // 39
       6,   51,    4,   52,           48,    2,   29,    6,    // 47
      45,    2,   39,    0,            6,    3,    0,   33,    // 55
       3,   30,    6,   29,            3,    6,    3,   10,    // 63
      30,    4,   17,    4,            3,    3,    4,    3,    // 71
      51,    4,   49,    2,            1,    4,   31,    9,    // 79
      51,    4,   49,    2,            1,    4,    6,    3,    // 87
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      34,   54,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 2;
    std::string imports[] = {
    "Armor::get_Damage^0",        "Armor::set_Damage^1",         "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, StringStandard01) {
    ccCompiledScript *scrip = newScriptFixture();

    char inpl[] = "\
        int main()                         \n\
        {                                  \n\
            String s = \"Hello, world!\";  \n\
            if (s != \"Bye\")              \n\
                return 1;                  \n\
            return 0;                      \n\
        }                                  \n\
        ";
    std::string input = "";
    input += g_Input_Bool;
    input += g_Input_String;
    input += inpl;

    clear_error();
    int compileResult = cc_compile(input.c_str(), scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StringStandard01", scrip);
    // hand-checked Bytecode
    const size_t codesize = 69;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   51,    0,           63,    4,    1,    1,    // 7
       4,    6,    3,    0,           51,    4,   64,    3,    // 15
      47,    3,   51,    4,           48,    3,   29,    3,    // 23
       6,    3,   14,   30,            4,   66,    4,    3,    // 31
       3,    4,    3,   28,           11,    6,    3,    1,    // 39
      51,    4,   49,    2,            1,    4,   31,   20,    // 47
       6,    3,    0,   51,            4,   49,    2,    1,    // 55
       4,   31,    9,   51,            4,   49,    2,    1,    // 63
       4,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
      11,   26,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      3,   3,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 20;
    std::string imports[] = {
    "String::Format^101",         "String::IsNullOrEmpty^1",    "String::Append^1",           // 2
    "String::AppendChar^1",       "String::CompareTo^2",        "String::Contains^1",         // 5
    "String::Copy^0",             "String::EndsWith^2",         "String::IndexOf^1",          // 8
    "String::LowerCase^0",        "String::Replace^3",          "String::ReplaceCharAt^2",    // 11
    "String::StartsWith^2",       "String::Substring^2",        "String::Truncate^1",         // 14
    "String::UpperCase^0",        "String::get_AsFloat^0",      "String::get_AsInt^0",        // 17
    "String::get_Chars^0",        "String::get_Length^0",        "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 18;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'H',  'e',  'l',  'l',          'o',  ',',  ' ',  'w',     // 7
    'o',  'r',  'l',  'd',          '!',    0,  'B',  'y',     // 15
    'e',    0,  '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }
}

TEST(Bytecode, StringOldstyle03) {
    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Sentinel1;                  \n\
        string Global;                  \n\
        int Sentinel2;                  \n\
                                        \n\
        void ModifyString(string Parm)  \n\
        {                               \n\
            Parm = \"Parameter\";       \n\
        }                               \n\
                                        \n\
        int main()                      \n\
        {                               \n\
            ModifyString(Global);       \n\
        }                               \n\
        ";
    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StringOldstyle03", scrip);
    // hand-checked Bytecode
    const size_t codesize = 66;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,            0,   51,    8,    3,    // 7
       3,    5,    3,    2,            4,    6,    7,  199,    // 15
       3,    4,    2,    7,            3,    3,    5,    2,    // 23
       8,    3,   28,   16,            1,    4,    1,    1,    // 31
       5,    1,    2,    7,            1,    3,    7,    3,    // 39
      28,    2,   31,  -28,            5,   38,   45,    6,    // 47
       2,    4,    7,    3,           29,    3,    6,    3,    // 55
       0,   23,    3,    2,            1,    4,    6,    3,    // 63
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,   49,   56,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      3,   1,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 10;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'P',  'a',  'r',  'a',          'm',  'e',  't',  'e',     // 7
    'r',    0,  '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }
}

TEST(Bytecode, StringOldstyle04) {
    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char *inpl = "\
        int Sentinel;                   \n\
        string Global;                  \n\
        int main()                      \n\
        {                               \n\
            string Local = Func(Global); \n\
        }                               \n\
        string Func(string Param)       \n\
        {                               \n\
            return Param;               \n\
        }                               \n\
        ";
    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StringOldstyle04", scrip);
    // hand-checked Bytecode
    const size_t codesize = 78;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    1,    1,          200,    6,    2,    4,    // 7
       7,    3,   29,    3,            6,    3,   66,   23,    // 15
       3,    2,    1,    4,           51,  200,    3,    3,    // 23
       5,    3,    2,    4,            6,    7,  199,    3,    // 31
       4,    2,    7,    3,            3,    5,    2,    8,    // 39
       3,   28,   16,    1,            4,    1,    1,    5,    // 47
       1,    2,    7,    1,            3,    7,    3,   28,    // 55
       2,   31,  -28,    2,            1,  200,    6,    3,    // 63
       0,    5,   38,   66,           51,    8,    7,    3,    // 71
      31,    3,    6,    3,            0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 2;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       7,   14,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 0;
    std::string imports[] = {
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, StringStandard02) {
    ccCompiledScript *scrip = newScriptFixture();

    char inpl[] = "\
        String S;                           \n\
        import String I;                    \n\
        String Func1()                      \n\
        {                                   \n\
            return S;                       \n\
        }                                   \n\
        String Func2(String P)              \n\
        {                                   \n\
            return P;                       \n\
        }                                   \n\
        String Func3()                      \n\
        {                                   \n\
            String L = \"Hello!\";          \n\
            return L;                       \n\
        }                                   \n\
        String Func4()                      \n\
        {                                   \n\
            return \"Hello!\";              \n\
        }                                   \n\
        ";
    std::string input = "";
    input += g_Input_Bool;
    input += g_Input_String;
    input += inpl;

    clear_error();
    int compileResult = cc_compile(input.c_str(), scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StringStandard02", scrip);
    // hand-checked Bytecode
    const size_t codesize = 116;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    2,            0,   48,    3,   31,    // 7
       3,    6,    3,    0,            5,   38,   13,   51,    // 15
       8,    7,    3,   50,            3,   51,    8,   48,    // 23
       3,   29,    3,   51,            4,   50,    3,   51,    // 31
      12,   49,   51,    4,           48,    3,   69,   30,    // 39
       4,   31,    6,   51,            8,   49,    6,    3,    // 47
       0,    5,   38,   50,           51,    0,   63,    4,    // 55
       1,    1,    4,    6,            3,    7,   51,    4,    // 63
      64,    3,   47,    3,           51,    4,   48,    3,    // 71
      29,    3,   51,    4,           50,    3,   51,    8,    // 79
      49,   51,    4,   48,            3,   69,   30,    4,    // 87
       2,    1,    4,   31,            9,   51,    4,   49,    // 95
       2,    1,    4,    6,            3,    0,    5,   38,    // 103
     103,    6,    3,    7,           64,    3,   31,    3,    // 111
       6,    3,    0,    5,          -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,   61,  107,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   3,   3,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 21;
    std::string imports[] = {
    "String::Format^101",         "String::IsNullOrEmpty^1",    "String::Append^1",           // 2
    "String::AppendChar^1",       "String::CompareTo^2",        "String::Contains^1",         // 5
    "String::Copy^0",             "String::EndsWith^2",         "String::IndexOf^1",          // 8
    "String::LowerCase^0",        "String::Replace^3",          "String::ReplaceCharAt^2",    // 11
    "String::StartsWith^2",       "String::Substring^2",        "String::Truncate^1",         // 14
    "String::UpperCase^0",        "String::get_AsFloat^0",      "String::get_AsInt^0",        // 17
    "String::get_Chars^0",        "String::get_Length^0",       "I",           // 20
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 14;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'H',  'e',  'l',  'l',          'o',  '!',    0,  'H',     // 7
    'e',  'l',  'l',  'o',          '!',    0,  '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }
}

TEST(Bytecode, StringStandardOldstyle) {
    ccSetOption(SCOPT_OLDSTRINGS, true);
    ccCompiledScript *scrip = newScriptFixture();

    char inpl[] = "\
        string OS;                          \n\
        String Func1()                      \n\
        {                                   \n\
            return OS;                      \n\
        }                                   \n\
        String Func2(String P)              \n\
        {                                   \n\
            return P;                       \n\
        }                                   \n\
        int Func3(const string OP)          \n\
        {                                   \n\
            Func2(\"Hello\");               \n\
        }                                   \n\
        String Func4()                      \n\
        {                                   \n\
            String S = \"Hello\";           \n\
            Func3(S);                       \n\
        }                                   \n\
        ";
    std::string input = "";
    input += g_Input_Bool;
    input += g_Input_String;
    input += inpl;

    clear_error();
    int compileResult = cc_compile(input.c_str(), scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());

    // WriteOutput("StringStandardOldstyle", scrip);
    // hand-checked Bytecode
    const size_t codesize = 117;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    2,            0,    7,    3,   64,    // 7
       3,   31,    3,    6,            3,    0,    5,   38,    // 15
      15,   51,    8,    7,            3,   50,    3,   51,    // 23
       8,   48,    3,   29,            3,   51,    4,   50,    // 31
       3,   51,   12,   49,           51,    4,   48,    3,    // 39
      69,   30,    4,   31,            6,   51,    8,   49,    // 47
       6,    3,    0,    5,           38,   52,    6,    3,    // 55
       6,   64,    3,   29,            3,    6,    3,   15,    // 63
      23,    3,    2,    1,            4,    6,    3,    0,    // 71
       5,   38,   73,   51,            0,   63,    4,    1,    // 79
       1,    4,    6,    3,            6,   51,    4,   64,    // 87
       3,   47,    3,   51,            4,   48,    3,   67,    // 95
       3,   29,    3,    6,            3,   52,   23,    3,    // 103
       2,    1,    4,   51,            4,   49,    2,    1,    // 111
       4,    6,    3,    0,            5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 5;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,   56,   63,   84,        101,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      1,   3,   2,   3,      2,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 20;
    std::string imports[] = {
    "String::Format^101",         "String::IsNullOrEmpty^1",    "String::Append^1",           // 2
    "String::AppendChar^1",       "String::CompareTo^2",        "String::Contains^1",         // 5
    "String::Copy^0",             "String::EndsWith^2",         "String::IndexOf^1",          // 8
    "String::LowerCase^0",        "String::Replace^3",          "String::ReplaceCharAt^2",    // 11
    "String::StartsWith^2",       "String::Substring^2",        "String::Truncate^1",         // 14
    "String::UpperCase^0",        "String::get_AsFloat^0",      "String::get_AsInt^0",        // 17
    "String::get_Chars^0",        "String::get_Length^0",        "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 12;
    EXPECT_EQ(stringssize, scrip->stringssize);

    char strings[] = {
    'H',  'e',  'l',  'l',          'o',    0,  'H',  'e',     // 7
    'l',  'l',  'o',    0,          '\0'
    };

    for (size_t idx = 0; idx < stringssize; idx++)
    {
        if (idx >= scrip->stringssize) break;
        std::string prefix = "strings[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(strings[idx]);
        std::string test_val = prefix + std::to_string(scrip->strings[idx]);
        ASSERT_EQ(is_val, test_val);
    }
}

TEST(Bytecode, AccessStructAsPointer)
{
    ccCompiledScript *scrip = newScriptFixture();

    // You may put a managed struct without using a * provided a struct * is expected
    // The * will be implied

    char *inpl = "\
        builtin managed struct Object {                 \n\
        };                                              \n\
        import Object oCleaningCabinetDoor;             \n\
                                                        \n\
        builtin managed struct Character                \n\
        {                                               \n\
            import int FaceObject(Object *);            \n\
        };                                              \n\
        import readonly Character *player;              \n\
                                                        \n\
        int oCleaningCabinetDoor_Interact()             \n\
        {                                               \n\
            player.FaceObject(oCleaningCabinetDoor);    \n\
        }                                               \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());
    // WriteOutput("AccessStructAsPointer", scrip);
    // hand-checked Bytecode
    const size_t codesize = 41;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    2,            2,   52,   48,    2,    // 7
      29,    6,   29,    2,            6,    2,    0,    3,    // 15
       2,    3,   48,    3,           30,    2,   34,    3,    // 23
      45,    2,   39,    1,            6,    3,    1,   33,    // 31
       3,   35,    1,   30,            6,    6,    3,    0,    // 39
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 3;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       4,   14,   30,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,   4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 3;
    std::string imports[] = {
    "oCleaningCabinetDoor",       "Character::FaceObject^1",    "player",      // 2
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);
}

TEST(Bytecode, Attributes04) {
    ccCompiledScript *scrip = newScriptFixture();

    // Attribute func was not called properly

    char *inpl = "\
        builtin managed struct Character {      \n\
            import attribute int  x;            \n\
        };                                      \n\
        import readonly Character *player;      \n\
                                                \n\
        int LinkattusStoop(int x, int y)        \n\
        {                                       \n\
            player.x += 77;                     \n\
        }                                       \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());
    // WriteOutput("Attributes04", scrip);
    // hand-checked Bytecode
    const size_t codesize = 58;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,    6,    3,           77,   29,    3,    6,    // 7
       2,    2,   52,   48,            2,   29,    6,   45,    // 15
       2,   39,    0,    6,            3,    0,   33,    3,    // 23
      30,    6,   30,    4,           11,    3,    4,    6,    // 31
       2,    2,   52,   48,            2,   29,    6,   34,    // 39
       3,   45,    2,   39,            1,    6,    3,    1,    // 47
      33,    3,   35,    1,           30,    6,    6,    3,    // 55
       0,    5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 4;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       9,   21,   33,   47,        -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,   4,   4,   4,     '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 3;
    std::string imports[] = {
    "Character::get_x^0",         "Character::set_x^1",         "player",      // 2
     "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}

TEST(Bytecode, Attributes05) {
    ccCompiledScript *scrip = newScriptFixture();

    // Test static attribute

    char *inpl = "\
        enum bool                               \n\
        {                                       \n\
            false = 0,                          \n\
            true = 1                            \n\
        };                                      \n\
                                                \n\
        builtin managed struct Game             \n\
        {                                       \n\
            readonly import static attribute    \n\
                bool SkippingCutscene;          \n\
        };                                      \n\
                                                \n\
        void Hook3()                            \n\
        {                                       \n\
            if (Game.SkippingCutscene)          \n\
            {                                   \n\
                int i = 99;                     \n\
            }                                   \n\
        }                                       \n\
    ";

    clear_error();
    int compileResult = cc_compile(inpl, scrip);

    ASSERT_STREQ("Ok", (compileResult >= 0) ? "Ok" : last_seen_cc_error());
    WriteOutput("Attributes05", scrip);
    // hand-checked Bytecode
    const size_t codesize = 25;
    EXPECT_EQ(codesize, scrip->codesize);

    intptr_t code[] = {
      38,    0,   39,    0,            6,    3,    0,   33,    // 7
       3,   28,   13,    1,            1,    4,    6,    3,    // 15
      99,   51,    4,    8,            3,    2,    1,    4,    // 23
       5,  -999
    };

    for (size_t idx = 0; idx < codesize; idx++)
    {
        if (idx >= scrip->codesize) break;
        std::string prefix = "code[";
        prefix += std::to_string(idx) + "] == ";
        std::string is_val = prefix + std::to_string(code[idx]);
        std::string test_val = prefix + std::to_string(scrip->code[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numfixups = 1;
    EXPECT_EQ(numfixups, scrip->numfixups);

    intptr_t fixups[] = {
       6,  -999
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixups[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixups[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixups[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    char fixuptypes[] = {
      4,  '\0'
    };

    for (size_t idx = 0; idx < numfixups; idx++)
    {
        if (idx >= scrip->numfixups) break;
        std::string prefix = "fixuptypes[";
        prefix += std::to_string(idx) + "] == ";
        std::string   is_val = prefix + std::to_string(fixuptypes[idx]);
        std::string test_val = prefix + std::to_string(scrip->fixuptypes[idx]);
        ASSERT_EQ(is_val, test_val);
    }

    const int numimports = 1;
    std::string imports[] = {
    "Game::get_SkippingCutscene^0",               "[[SENTINEL]]"
    };

    int idx2 = -1;
    for (size_t idx = 0; idx < scrip->numimports; idx++)
    {
        if (!strcmp(scrip->imports[idx], ""))
            continue;
        idx2++;
        ASSERT_LT(idx2, numimports);
        std::string prefix = "imports[";
        prefix += std::to_string(idx2) + "] == ";
        std::string is_val = prefix + scrip->imports[idx];
        std::string test_val = prefix + imports[idx2];
        ASSERT_EQ(is_val, test_val);
    }

    const size_t numexports = 0;
    EXPECT_EQ(numexports, scrip->numexports);

    const size_t stringssize = 0;
    EXPECT_EQ(stringssize, scrip->stringssize);

}
