diff -Naur cmake/FileList.cmake cmake/FileList.cmake
--- cmake/FileList.cmake	2011-03-12 01:26:00.000000000 +0100
+++ cmake/FileList.cmake	2012-05-18 07:54:07.366062500 +0200
@@ -334,6 +334,18 @@
         src/psp/pvram.c
         src/psp/pvtable8.c
         )
+		
+set(ALLEGRO_SRC_IOS_FILES
+        src/ios/idrivers.c
+        src/ios/isound.c
+        src/ios/ifile.c
+        src/ios/igfx.c
+        src/ios/ikey.c
+        src/ios/isystem.c
+        src/ios/imouse.c
+        src/ios/itimer.c
+        src/misc/colconv.c
+        )
 
 set(ALLEGRO_INCLUDE_ALLEGRO_FILES
         include/allegro/3d.h
@@ -400,6 +412,7 @@
         include/allegro/platform/aintmac.h
         include/allegro/platform/aintosx.h
         include/allegro/platform/aintpsp.h
+        include/allegro/platform/aintios.h
         include/allegro/platform/aintqnx.h
         include/allegro/platform/aintunix.h
         include/allegro/platform/aintwin.h
@@ -421,6 +434,8 @@
         # include/allegro/platform/alplatf.h.cmake
         include/allegro/platform/alpsp.h
         include/allegro/platform/alpspcfg.h
+        include/allegro/platform/alios.h
+        include/allegro/platform/alioscfg.h
         include/allegro/platform/alqnx.h
         include/allegro/platform/alqnxcfg.h
         include/allegro/platform/alucfg.h
diff -Naur include/allegro/internal/alconfig.h include/allegro/internal/alconfig.h
--- include/allegro/internal/alconfig.h	2008-12-24 02:39:48.000000000 +0100
+++ include/allegro/internal/alconfig.h	2012-05-18 07:54:09.076279700 +0200
@@ -14,7 +14,7 @@
  *
  *      See readme.txt for copyright information.
  */
-
+#define ALLEGRO_IOS
 
 /* which color depths to include? */
 #define ALLEGRO_COLOR8
@@ -62,6 +62,8 @@
       #include "allegro/platform/alucfg.h"
    #elif defined ALLEGRO_PSP
       #include "allegro/platform/alpspcfg.h"
+   #elif defined ALLEGRO_IOS
+      #include "allegro/platform/alioscfg.h"   
    #else
       #error platform not supported
    #endif
diff -Naur include/allegro/platform/aintios.h include/allegro/platform/aintios.h
--- include/allegro/platform/aintios.h	1970-01-01 01:00:00.000000000 +0100
+++ include/allegro/platform/aintios.h	2012-05-18 07:54:09.094782100 +0200
@@ -0,0 +1,26 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Internal header file for the Android Allegro library port.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef AINTIOS_H
+#define AINTIOS_H
+
+void ios_mouse_setup(int left, int right, int top, int bottom, float scaling_x, float scaling_y);
+
+#endif
+
diff -Naur include/allegro/platform/alios.h include/allegro/platform/alios.h
--- include/allegro/platform/alios.h	1970-01-01 01:00:00.000000000 +0100
+++ include/allegro/platform/alios.h	2012-05-18 07:54:09.145788500 +0200
@@ -0,0 +1,65 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Android specific header defines.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALIOS_H
+#define ALIOS_H
+
+#ifndef ALLEGRO_IOS
+   #error bad include
+#endif
+
+#include <stdio.h>
+
+
+/* The Android C library doesn't include stricmp */
+#define stricmp strcasecmp
+
+/* System driver */
+#define SYSTEM_IOS              AL_ID('I','O','S',' ')
+AL_VAR(SYSTEM_DRIVER, system_ios);
+
+/* Timer driver */
+#define TIMER_IOS               AL_ID('I','O','S','T')
+AL_VAR(TIMER_DRIVER, timer_ios);
+
+/* Keyboard driver */
+#define KEYBOARD_IOS            AL_ID('I','O','S','K')
+AL_VAR(KEYBOARD_DRIVER, keyboard_ios);
+
+/* Mouse drivers */
+#define MOUSE_IOS               AL_ID('I','O','S','M')
+AL_VAR(MOUSE_DRIVER, mouse_ios);
+
+/* Gfx driver */
+#define GFX_IOS                 AL_ID('I','O','S','G')
+AL_VAR(GFX_DRIVER, gfx_ios);
+
+/* Digital sound driver */
+#define DIGI_IOS                AL_ID('I','O','S','S')
+AL_VAR(DIGI_DRIVER, digi_ios);
+
+/* Joystick drivers */
+#define JOYSTICK_IOS            AL_ID('I','O','S','J')
+AL_VAR(JOYSTICK_DRIVER, joystick_ios);
+
+
+
+
+
+#endif
diff -Naur include/allegro/platform/alioscfg.h include/allegro/platform/alioscfg.h
--- include/allegro/platform/alioscfg.h	1970-01-01 01:00:00.000000000 +0100
+++ include/allegro/platform/alioscfg.h	2012-05-18 07:54:09.147788800 +0200
@@ -0,0 +1,68 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Android specific header defines.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALIOSCFG_H
+#define ALIOSCFG_H
+
+#define ALLEGRO_EXTRA_HEADER "allegro/platform/alios.h"
+
+#ifndef SCAN_DEPEND
+   #include <fcntl.h>
+   #include <unistd.h>
+#endif
+
+
+#ifndef ALLEGRO_NO_MAGIC_MAIN
+   #define ALLEGRO_MAGIC_MAIN
+   #define main _mangled_main
+   #undef END_OF_MAIN
+   #define END_OF_MAIN() void *_mangled_main_address = (void *) _mangled_main;
+#else
+   #undef END_OF_MAIN
+   #define END_OF_MAIN() void *_mangled_main_address;
+#endif
+
+#include <stdio.h>
+
+#define ALLEGRO_HAVE_DIRENT_H   1
+#define ALLEGRO_HAVE_INTTYPES_H 1
+#define ALLEGRO_HAVE_STDINT_H   1
+#define ALLEGRO_HAVE_SYS_TIME_H 1
+#define ALLEGRO_HAVE_SYS_STAT_H 1
+
+/* Describe this platform */
+#define ALLEGRO_PLATFORM_STR  "iOS"
+#define ALLEGRO_USE_CONSTRUCTOR
+
+#define ALLEGRO_LITTLE_ENDIAN
+
+/* Provide implementations of missing definitions */
+#ifndef O_BINARY
+   #define O_BINARY     0
+#endif
+#define dup(X)	(fcntl(X, F_DUPFD, 0))
+
+/* Exclude ASM */
+#ifndef ALLEGRO_NO_ASM
+   #define ALLEGRO_NO_ASM
+#endif
+
+
+
+#endif
diff -Naur include/allegro/system.h include/allegro/system.h
--- include/allegro/system.h	2011-03-19 00:47:45.000000000 +0100
+++ include/allegro/system.h	2012-05-18 07:54:09.203295800 +0200
@@ -66,6 +66,7 @@
 #define OSTYPE_MACOS       AL_ID('M','A','C',' ')
 #define OSTYPE_MACOSX      AL_ID('M','A','C','X')
 #define OSTYPE_PSP         AL_ID('K','P','S','P')
+#define OSTYPE_IOS         AL_ID('I','O','S',' ')
 
 AL_VAR(int, os_type);
 AL_VAR(int, os_version);
diff -Naur src/digmid.c src/digmid.c
--- src/digmid.c	2007-08-09 22:48:38.000000000 +0200
+++ src/digmid.c	2012-05-18 07:54:09.651852800 +0200
@@ -13,6 +13,8 @@
  *      By Shawn Hargreaves, based on code by Tom Novelli.
  *      Chris Robinson added some optimizations and the digmid_set_pan method.
  *
+ *      Modified for the Adventure Game Studio runtime port by JJS.
+ *
  *      See readme.txt for copyright information.
  */
 
@@ -520,7 +522,7 @@
 {
    PACKFILE *f;
    char dir[1024], file[1024], buf[1024], filename[1024];
-   char todo[256][1024];
+   char* todo[256];
    char *argv[16], *p;
    char tmp[128];
    int argc;
@@ -530,9 +532,12 @@
    int drum_start = 0;
    int type, size;
    int i, j, c;
+   
+   for (i = 0; i < 256; i++)
+      todo[i] = (char*)malloc(1024);
 
    if (!_digmid_find_patches(dir, sizeof(dir), file, sizeof(file)))
-      return -1;
+      goto error_exit;
 
    for (i=0; i<256; i++)
       usetc(todo[i], 0);
@@ -542,7 +547,7 @@
 
    f = pack_fopen(buf, F_READ);
    if (!f)
-      return -1;
+      goto error_exit;
 
    while (pack_fgets(buf, sizeof(buf), f) != 0) {
       argc = parse_string(buf, argv);
@@ -584,7 +589,7 @@
 
 		  if (!patch[patchnum]) {
 		     /* need to load this sample */
-		     ustrzcpy(todo[patchnum], sizeof(todo[patchnum]), argv[1]);
+		     ustrzcpy(todo[patchnum], 1024, argv[1]);
 		  }
 	       }
 	    }
@@ -608,13 +613,13 @@
 
       f = pack_fopen(dir, F_READ_PACKED);
       if (!f)
-	 return -1;
+	 goto error_exit;
 
       if (((ugetc(dir) == '#') && (ustrlen(dir) == 1)) || (!ustrchr(dir, '#'))) {
 	 type = pack_mgetl(f);
 	 if (type != DAT_MAGIC) {
 	    pack_fclose(f);
-	    return -1;
+	    goto error_exit;
 	 }
       }
 
@@ -675,6 +680,7 @@
 	    pack_fseek(f, size+4);
 	 }
       }
+      pack_fclose(f);
    }
    else {
       /* read from regular disk files */
@@ -706,7 +712,16 @@
       }
    }
 
+   for (i = 0; i < 256; i++)
+      free(todo[i]);
+
    return 0;
+
+error_exit:
+
+    for (i = 0; i < 256; i++)
+       free(todo[i]);
+   return -1;
 }
 
 
diff -Naur src/file.c src/file.c
--- src/file.c	2011-03-25 00:18:25.000000000 +0100
+++ src/file.c	2012-05-18 07:54:09.825874900 +0200
@@ -1808,7 +1808,7 @@
  *  it returns NULL and stores an error code in errno. An attempt to read a 
  *  normal file in packed mode will cause errno to be set to EDOM.
  */
-PACKFILE *pack_fopen(AL_CONST char *filename, AL_CONST char *mode)
+PACKFILE *__old_pack_fopen(AL_CONST char *filename, AL_CONST char *mode)
 {
    char tmp[1024];
    int fd;
diff -Naur src/ios/idrivers.c src/ios/idrivers.c
--- src/ios/idrivers.c	1970-01-01 01:00:00.000000000 +0100
+++ src/ios/idrivers.c	2012-05-18 07:54:09.972393500 +0200
@@ -0,0 +1,75 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      List of iOS drivers.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include "allegro.h"
+
+#ifndef ALLEGRO_IOS
+#error Something is wrong with the makefile
+#endif
+
+
+_DRIVER_INFO _system_driver_list[] =
+{
+   { SYSTEM_IOS,              &system_ios,              TRUE  },
+   { SYSTEM_NONE,             &system_none,             FALSE },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _keyboard_driver_list[] =
+{
+   { KEYBOARD_IOS,            &keyboard_ios,            TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _timer_driver_list[] =
+{
+   { TIMER_IOS,               &timer_ios,               TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _mouse_driver_list[] =
+{
+   { MOUSE_IOS,               &mouse_ios,               TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _gfx_driver_list[] =
+{
+   { GFX_IOS,                 &gfx_ios,                 TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _digi_driver_list[] =
+{
+   { DIGI_IOS,                &digi_ios,                TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+BEGIN_MIDI_DRIVER_LIST
+MIDI_DRIVER_DIGMID
+END_MIDI_DRIVER_LIST
+
+BEGIN_JOYSTICK_DRIVER_LIST
+END_JOYSTICK_DRIVER_LIST
diff -Naur src/ios/ifile.c src/ios/ifile.c
--- src/ios/ifile.c	1970-01-01 01:00:00.000000000 +0100
+++ src/ios/ifile.c	2012-05-18 07:54:09.974393800 +0200
@@ -0,0 +1,536 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Helper routines to make file.c work on the Android/iOS platform.
+ *
+ *      By Michael Bukin.
+ *
+ *      Modified for the Adventure Game Studio runtime port by JJS.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+/* libc should use 64-bit for file sizes when possible */
+#define _FILE_OFFSET_BITS 64
+
+#include <stdio.h>
+#include <string.h>
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+
+#ifdef ALLEGRO_HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+
+#ifdef ALLEGRO_HAVE_DIRENT_H
+   #include <sys/types.h>
+   #include <dirent.h>
+   #define NAMLEN(dirent) (strlen((dirent)->d_name))
+#else
+   /* Apparently all new systems have `dirent.h'. */
+   #error ALLEGRO_HAVE_DIRENT_H not defined
+#endif
+
+#ifdef ALLEGRO_HAVE_SYS_TIME_H
+  #include <sys/time.h>
+#endif
+#ifdef ALLEGRO_HAVE_TIME_H
+  #include <time.h>
+#endif
+
+#define PREFIX_I "al-unix INFO: "
+
+#define PREFIX_I "al-unix INFO: "
+
+
+/* _al_file_isok:
+ *  Helper function to check if it is safe to access a file on a floppy
+ *  drive.
+ */
+int _al_file_isok(AL_CONST char *filename)
+{
+   return TRUE;
+}
+
+
+
+/* _al_file_size_ex:
+ *  Measures the size of the specified file.
+ */
+uint64_t _al_file_size_ex(AL_CONST char *filename)
+{
+   struct stat s;
+   char tmp[1024];
+
+   if (stat(uconvert(filename, U_CURRENT, tmp, U_UTF8, sizeof(tmp)), &s) != 0) {
+      *allegro_errno = errno;
+      return 0;
+   }
+
+   return s.st_size;
+}
+
+
+
+/* _al_file_time:
+ *  Returns the timestamp of the specified file.
+ */
+time_t _al_file_time(AL_CONST char *filename)
+{
+   struct stat s;
+   char tmp[1024];
+
+   if (stat(uconvert(filename, U_CURRENT, tmp, U_UTF8, sizeof(tmp)), &s) != 0) {
+      *allegro_errno = errno;
+      return 0;
+   }
+
+   return s.st_mtime;
+}
+
+
+
+/* ff_get_filename:
+ *  When passed a completely specified file path, this returns a pointer
+ *  to the filename portion.
+ */
+static char *ff_get_filename(AL_CONST char *path)
+{
+   char *p = (char*)path + strlen(path);
+
+   while ((p > path) && (*(p - 1) != '/'))
+      p--;
+
+   return p;
+}
+
+
+
+/* ff_put_backslash:
+ *  If the last character of the filename is not a /, this routine will
+ *  concatenate a / on to it.
+ */
+static void ff_put_backslash(char *filename, int size)
+{
+   int len = strlen(filename);
+
+   if ((len > 0) && (len < (size - 1)) && (filename[len - 1] != '/')) {
+      filename[len] = '/';
+      filename[len + 1] = 0;
+   }
+}
+
+
+
+#define FF_MATCH_TRY 0
+#define FF_MATCH_ONE 1
+#define FF_MATCH_ANY 2
+
+
+struct FF_MATCH_DATA
+{
+   int type;
+   AL_CONST char *s1;
+   AL_CONST char *s2;
+};
+
+
+
+/* ff_match:
+ *  Matches two strings ('*' matches any number of characters,
+ *  '?' matches any character).
+ */
+static int ff_match(AL_CONST char *s1, AL_CONST char *s2)
+{
+   static unsigned int size = 0;
+   static struct FF_MATCH_DATA *data = NULL;
+   AL_CONST char *s1end;
+   int index, c1, c2;
+
+   /* handle NULL arguments */
+   if ((!s1) && (!s2)) {
+      if (data) {
+         _AL_FREE(data);
+         data = NULL;
+      }
+
+      return 0;
+   }
+
+   s1end = s1 + strlen(s1);
+
+   /* allocate larger working area if necessary */
+   if (data && (size < strlen(s2))) {
+      _AL_FREE(data);
+      data = NULL;
+   }
+
+   if (!data) {
+      size = strlen(s2);
+      data = _AL_MALLOC(sizeof(struct FF_MATCH_DATA) * size * 2 + 1);
+      if (!data)
+         return 0;
+   }
+
+   index = 0;
+   data[0].s1 = s1;
+   data[0].s2 = s2;
+   data[0].type = FF_MATCH_TRY;
+
+   while (index >= 0) {
+      s1 = data[index].s1;
+      s2 = data[index].s2;
+      c1 = *s1;
+      c2 = *s2;
+
+      switch (data[index].type) {
+
+      case FF_MATCH_TRY:
+         if (c2 == 0) {
+            /* pattern exhausted */
+            if (c1 == 0)
+               return 1;
+            else
+               index--;
+         }
+         else if (c1 == 0) {
+            /* string exhausted */
+            while (*s2 == '*')
+               s2++;
+            if (*s2 == 0)
+               return 1;
+            else
+               index--;
+         }
+         else if (c2 == '*') {
+            /* try to match the rest of pattern with empty string */
+            data[index++].type = FF_MATCH_ANY;
+            data[index].s1 = s1end;
+            data[index].s2 = s2 + 1;
+            data[index].type = FF_MATCH_TRY;
+         }
+         /* do case insensitive matching */
+         else if ((c2 == '?') || (c1 == c2) 
+           || ((c1 <= 90) && (c1 >= 65) && (c2 == c1 + 32)) 
+           || ((c2 <= 90) && (c2 >= 65) && (c1 == c2 + 32))) {
+            /* try to match the rest */
+            data[index++].type = FF_MATCH_ONE;
+            data[index].s1 = s1 + 1;
+            data[index].s2 = s2 + 1;
+            data[index].type = FF_MATCH_TRY;
+         }
+         else
+            index--;
+         break;
+
+      case FF_MATCH_ONE:
+         /* the rest of string did not match, try earlier */
+         index--;
+         break;
+
+      case FF_MATCH_ANY:
+         /* rest of string did not match, try add more chars to string tail */
+         if (--data[index + 1].s1 >= s1) {
+            data[index + 1].type = FF_MATCH_TRY;
+            index++;
+         }
+         else
+            index--;
+         break;
+
+      default:
+         /* this is a bird? This is a plane? No it's a bug!!! */
+         return 0;
+      }
+   }
+
+   return 0;
+}
+
+
+
+/* ff_get_attrib:
+ *  Builds up the attribute list of the file pointed to by name and s.
+ */
+static int ff_get_attrib(AL_CONST char *name, struct stat *s)
+{
+   int attrib = 0;
+/*
+   uid_t euid = geteuid();
+
+   if (euid != 0) {
+      if (s->st_uid == euid) {
+	 if ((s->st_mode & S_IWUSR) == 0)
+	    attrib |= FA_RDONLY;
+      }
+      else if (s->st_gid == getegid()) {
+	 if ((s->st_mode & S_IWGRP) == 0)
+	    attrib |= FA_RDONLY;
+      }
+      else if ((s->st_mode & S_IWOTH) == 0) {
+	 attrib |= FA_RDONLY;
+      }
+   }
+*/
+   if (S_ISDIR(s->st_mode))
+      attrib |= FA_DIREC;
+
+   if ((name[0] == '.') && ((name[1] != '.') || (name[2] != '\0')))
+      attrib |= FA_HIDDEN;
+
+   return attrib;
+}
+
+
+
+/* structure for use by the directory scanning routines */
+#define FF_MAXPATHLEN 1024
+
+struct FF_DATA
+{
+   DIR *dir;
+   char dirname[FF_MAXPATHLEN];
+   char pattern[FF_MAXPATHLEN];
+   int attrib;
+   uint64_t size;
+};
+
+
+
+/* al_findfirst:
+ *  Initiates a directory search.
+ */
+int al_findfirst(AL_CONST char *pattern, struct al_ffblk *info, int attrib)
+{
+   struct FF_DATA *ff_data;
+   struct stat s;
+   int actual_attrib;
+   char tmp[1024];
+   char *p;
+
+   /* allocate ff_data structure */
+   ff_data = _AL_MALLOC(sizeof(struct FF_DATA));
+   if (!ff_data) {
+      *allegro_errno = ENOMEM;
+      return -1;
+   }
+
+   memset(ff_data, 0, sizeof *ff_data);
+   info->ff_data = (void *) ff_data;
+
+   /* if the pattern contains no wildcard, we use stat() */
+   if (!ustrpbrk(pattern, uconvert("?*", U_ASCII, tmp, U_CURRENT, sizeof(tmp)))) {
+
+      /* start the search */
+      errno = *allegro_errno = 0;
+
+      if (stat(uconvert(pattern, U_CURRENT, tmp, U_UTF8, sizeof(tmp)), &s) == 0) {
+
+         /* get file attributes */
+         actual_attrib = ff_get_attrib(ff_get_filename(uconvert(pattern, U_CURRENT, tmp, U_UTF8, sizeof(tmp))), &s);
+         /* does it match ? */
+         if ((actual_attrib & ~attrib) == 0) {
+            info->attrib = actual_attrib;
+            info->time = s.st_mtime;
+            info->size = s.st_size; /* overflows at 2GB */
+            ff_data->size = s.st_size;
+            ustrzcpy(info->name, sizeof(info->name), get_filename(pattern));
+            return 0;
+         }
+      }
+
+       _AL_FREE(ff_data);
+      info->ff_data = NULL;
+      *allegro_errno = (errno ? errno : ENOENT);
+      return -1;
+   }
+
+   ff_data->attrib = attrib;
+
+   do_uconvert(pattern, U_CURRENT, ff_data->dirname, U_UTF8, sizeof(ff_data->dirname));
+   p = ff_get_filename(ff_data->dirname);
+   _al_sane_strncpy(ff_data->pattern, p, sizeof(ff_data->pattern));
+   if (p == ff_data->dirname)
+      _al_sane_strncpy(ff_data->dirname, "./", FF_MAXPATHLEN);
+   else
+      *p = 0;
+
+   /* nasty bodge, but gives better compatibility with DOS programs */
+   if (strcmp(ff_data->pattern, "*.*") == 0)
+      _al_sane_strncpy(ff_data->pattern, "*", FF_MAXPATHLEN);
+
+   /* start the search */
+   errno = *allegro_errno = 0;
+
+   ff_data->dir = opendir(ff_data->dirname);
+   if (!ff_data->dir) {
+      *allegro_errno = (errno ? errno : ENOENT);
+      _AL_FREE(ff_data);
+      info->ff_data = NULL;
+      return -1;
+   }
+
+   if (al_findnext(info) != 0) {
+      al_findclose(info);
+      return -1;
+   }
+
+   return 0;
+}
+
+
+
+/* al_findnext:
+ *  Retrieves the next file from a directory search.
+ */
+int al_findnext(struct al_ffblk *info)
+{
+   char tempname[FF_MAXPATHLEN];
+   char filename[FF_MAXPATHLEN];
+   int attrib;
+   struct dirent *entry;
+   struct stat s;
+   struct FF_DATA *ff_data = (struct FF_DATA *) info->ff_data;
+
+   ASSERT(ff_data);
+
+   /* if the pattern contained no wildcard */
+   if (!ff_data->dir)
+      return -1;
+
+   while (TRUE) {
+      /* read directory entry */
+      entry = readdir(ff_data->dir);
+      if (!entry) {
+         *allegro_errno = (errno ? errno : ENOENT);
+         return -1;
+      }
+
+      /* try to match file name with pattern */
+      tempname[0] = 0;
+      if (NAMLEN(entry) >= sizeof(tempname))
+         strncat(tempname, entry->d_name, sizeof(tempname) - 1);
+      else
+         strncat(tempname, entry->d_name, NAMLEN(entry));
+
+      if (ff_match(tempname, ff_data->pattern)) {
+         _al_sane_strncpy(filename, ff_data->dirname, FF_MAXPATHLEN);
+         ff_put_backslash(filename, sizeof(filename));
+         strncat(filename, tempname, sizeof(filename) - strlen(filename) - 1);
+
+         /* get file attributes */
+         if (stat(filename, &s) == 0) {
+            attrib = ff_get_attrib(tempname, &s);
+
+            /* does it match ? */
+            if ((attrib & ~ff_data->attrib) == 0)
+               break;
+         }
+         else {
+            /* evil! but no other way to avoid exiting for_each_file() */
+            *allegro_errno = 0;
+         }
+      }
+   }
+
+   info->attrib = attrib;
+   info->time = s.st_mtime;
+   info->size = s.st_size; /* overflows at 2GB */
+   ff_data->size = s.st_size;
+
+   do_uconvert(tempname, U_UTF8, info->name, U_CURRENT, sizeof(info->name));
+
+   return 0;
+}
+
+
+
+/* al_findclose:
+ *  Cleans up after a directory search.
+ */
+void al_findclose(struct al_ffblk *info)
+{
+   struct FF_DATA *ff_data = (struct FF_DATA *) info->ff_data;
+
+   if (ff_data) {
+      if (ff_data->dir) {
+         closedir(ff_data->dir);
+      }
+      _AL_FREE(ff_data);
+      info->ff_data = NULL;
+
+      /* to avoid leaking memory */
+      ff_match(NULL, NULL);
+   }
+}
+
+
+
+/* _al_getdcwd:
+ *  Returns the current directory on the specified drive.
+ */
+void _al_getdcwd(int drive, char *buf, int size)
+{
+   char tmp[1024];
+
+   if (getcwd(tmp, sizeof(tmp)))
+      do_uconvert(tmp, U_UTF8, buf, U_CURRENT, size);
+   else
+      usetc(buf, 0);
+}
+
+
+
+/* _al_ffblk_get_size:
+ *  Returns the size out of an _al_ffblk structure.
+ */
+uint64_t al_ffblk_get_size(struct al_ffblk *info)
+{
+   struct FF_DATA *ff_data;
+   ASSERT(info);
+   ff_data = (struct FF_DATA *) info->ff_data;
+   ASSERT(ff_data);
+   return ff_data->size;
+}
+
+
+
+/* _al_detect_filename_encoding:
+ *  Platform specific function to detect the filename encoding. This is called
+ *  after setting a system driver, and even if this driver is SYSTEM_NONE.
+ */
+void _al_detect_filename_encoding(void)
+{
+   char const *encoding = "unknown";
+   char *locale = getenv("LC_ALL");
+
+   if (!locale || !locale[0]) {
+      locale = getenv("LC_CTYPE");
+      if (!locale || !locale[0])
+         locale = getenv("LANG");
+   }
+
+   if (locale) {
+      if (strstr(locale, "utf8") ||
+          strstr(locale, "UTF-8") ||
+          strstr(locale, "utf-8") ||
+          strstr(locale, "UTF8")) {
+         /* Note: UTF8 is default anyway. */
+         set_filename_encoding(U_UTF8);
+         encoding = "UTF8";
+      }
+      /* TODO: detect other encodings, and support them in Allegro */
+   }
+
+   TRACE(PREFIX_I "Assumed libc encoding is %s.\n", encoding);
+}
+
+
diff -Naur src/ios/igfx.c src/ios/igfx.c
--- src/ios/igfx.c	1970-01-01 01:00:00.000000000 +0100
+++ src/ios/igfx.c	2012-05-18 07:54:09.975894000 +0200
@@ -0,0 +1,377 @@
+/*         ______   ___    ___
+*        /\  _  \ /\_ \  /\_ \
+*        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+*         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+*          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+*           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+*            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+*                                           /\____/
+*                                           \_/__/
+*
+*      Display driver.
+*
+*      By JJS for the Adventure Game Studio runtime port.
+*      Based on the Allegro PSP port.
+*
+*      See readme.txt for copyright information.
+*/
+
+#include <../../System/Library/Frameworks/OpenGLES.framework/Headers/ES1/gl.h>
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+
+extern void ios_swap_buffers();
+extern void ios_select_buffer();
+
+
+/* Software version of some blitting methods */
+static void (*_orig_blit) (BITMAP * source, BITMAP * dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height);
+
+static BITMAP *ios_display_init(int w, int h, int v_w, int v_h, int color_depth);
+static void gfx_ios_enable_acceleration(GFX_VTABLE *vtable);
+static void ios_hw_blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height);
+
+
+void ios_render();
+void ios_initialize_opengl();
+
+
+/* Options controlled by the application */
+int psp_gfx_scaling = 1;
+int psp_gfx_smoothing = 1;
+
+
+BITMAP* displayed_video_bitmap;
+
+unsigned int ios_screen_texture = 0;
+unsigned int ios_screen_width = 320;
+unsigned int ios_screen_height = 200;
+unsigned int ios_screen_physical_width = 320;
+unsigned int ios_screen_physical_height = 200;
+unsigned int ios_screen_color_depth = 32;
+int ios_screen_texture_width = 0;
+int ios_screen_texture_height = 0;
+float ios_screen_ar = 1.0f;
+float ios_device_ar = 1.0f;
+
+volatile int ios_screen_is_dirty = 0;
+int ios_screen_initialized = 0;
+
+
+GLfloat ios_vertices[] =
+{
+   0, 0,
+   320,  0,
+   0,  200,
+   320,  200
+};
+
+GLfloat ios_texture_coordinates[] =
+{
+   0, 200.0f / 256.0f,
+   320.0f / 512.0f, 200.0f / 256.0f,
+   0, 0,
+   320.0f / 512.0f, 0
+};
+
+
+GFX_DRIVER gfx_ios =
+{
+   GFX_IOS,
+   empty_string,
+   empty_string,
+   "iOS gfx driver",
+   ios_display_init,             /* AL_METHOD(struct BITMAP *, init, (int w, int h, int v_w, int v_h, int color_depth)); */
+   NULL,                         /* AL_METHOD(void, exit, (struct BITMAP *b)); */
+   NULL,                         /* AL_METHOD(int, scroll, (int x, int y)); */
+   NULL,                         /* AL_METHOD(void, vsync, (void)); */
+   NULL,                         /* AL_METHOD(void, set_palette, (AL_CONST struct RGB *p, int from, int to, int retracesync)); */
+   NULL,                         /* AL_METHOD(int, request_scroll, (int x, int y)); */
+   NULL,                         /* AL_METHOD(int, poll_scroll, (void)); */
+   NULL,                         /* AL_METHOD(void, enable_triple_buffer, (void)); */
+   NULL,                         /* AL_METHOD(struct BITMAP *, create_video_bitmap, (int width, int height)); */
+   NULL,                         /* AL_METHOD(void, destroy_video_bitmap, (struct BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(int, show_video_bitmap, (BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(int, request_video_bitmap, (BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(BITMAP *, create_system_bitmap, (int width, int height)); */
+   NULL,                         /* AL_METHOD(void, destroy_system_bitmap, (BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(int, set_mouse_sprite, (BITMAP *sprite, int xfocus, int yfocus)); */
+   NULL,                         /* AL_METHOD(int, show_mouse, (BITMAP *bmp, int x, int y)); */
+   NULL,                         /* AL_METHOD(void, hide_mouse, (void)); */
+   NULL,                         /* AL_METHOD(void, move_mouse, (int x, int y)); */
+   NULL,                         /* AL_METHOD(void, drawing_mode, (void)); */
+   NULL,                         /* AL_METHOD(void, save_video_state, (void)); */
+   NULL,                         /* AL_METHOD(void, restore_video_state, (void)); */
+   NULL,                         /* AL_METHOD(void, set_blender_mode, (int mode, int r, int g, int b, int a)); */
+   NULL,                         /* AL_METHOD(int, fetch_mode_list, (void)); */
+   0, 0,                         /* physical (not virtual!) screen size */
+   TRUE,                         /* true if video memory is linear */
+   0,                            /* bank size, in bytes */
+   0,                            /* bank granularity, in bytes */
+   0,                            /* video memory size, in bytes */
+   0,                            /* physical address of video memory */
+   FALSE                         /* true if driver runs windowed */
+};
+
+
+extern void ios_create_screen();
+
+static BITMAP *ios_display_init(int w, int h, int v_w, int v_h, int color_depth)
+{
+   GFX_VTABLE* vtable = _get_vtable(color_depth);
+
+   ios_screen_width = w;
+   ios_screen_height = h;
+   ios_screen_color_depth = color_depth;
+
+   /* Do the final screen blit to a 32 bit bitmap in palette mode */
+   if (color_depth == 8)
+      color_depth = 32;
+
+   displayed_video_bitmap = create_bitmap_ex(color_depth, w, h);
+   gfx_ios_enable_acceleration(vtable);
+
+   ios_create_screen();
+   
+   return displayed_video_bitmap;
+}
+
+
+static void gfx_ios_enable_acceleration(GFX_VTABLE *vtable)
+{
+   /* Keep the original blitting methods */
+   _orig_blit = vtable->blit_to_self;
+
+   /* Accelerated blits. */
+   vtable->blit_from_memory = ios_hw_blit;
+   vtable->blit_to_memory = ios_hw_blit;
+   vtable->blit_from_system = ios_hw_blit;
+   vtable->blit_to_system = ios_hw_blit;
+   vtable->blit_to_self = ios_hw_blit;
+
+   _screen_vtable.blit_from_memory = ios_hw_blit;
+   _screen_vtable.blit_to_memory = ios_hw_blit;
+   _screen_vtable.blit_from_system = ios_hw_blit;
+   _screen_vtable.blit_to_system = ios_hw_blit;
+   _screen_vtable.blit_to_self = ios_hw_blit;
+
+   gfx_capabilities |= (GFX_HW_VRAM_BLIT | GFX_HW_MEM_BLIT);
+}
+
+
+/* All blitting goes through here, signal a screen update if the blit target is the screen bitmap */
+static void ios_hw_blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height)
+{
+   _orig_blit(source, dest, source_x, source_y, dest_x, dest_y, width, height);
+
+   if (dest == displayed_video_bitmap)
+      ios_render();
+}
+
+
+int ios_get_next_power_of_2(int value)
+{
+   int test = 1;
+
+   while (test < value)
+      test *= 2;
+
+   return test;
+}
+
+
+/* Create the texture that holds the screen bitmap */
+void ios_create_screen_texture(int width, int height, int color_depth)
+{
+   char* empty;
+
+   ios_screen_texture_width = ios_get_next_power_of_2(width);
+   ios_screen_texture_height = ios_get_next_power_of_2(height);
+
+   empty = (char*)malloc(ios_screen_texture_width * ios_screen_texture_height * color_depth / 8);
+   memset(empty, 0, ios_screen_texture_width * ios_screen_texture_height * color_depth / 8);
+
+   if (ios_screen_texture != 0)
+      glDeleteTextures(1, &ios_screen_texture);
+
+   glGenTextures(1, &ios_screen_texture);
+   glBindTexture(GL_TEXTURE_2D, ios_screen_texture);
+
+   if (color_depth == 16)
+      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, ios_screen_texture_width, ios_screen_texture_height, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, empty);
+   else
+      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, ios_screen_texture_width, ios_screen_texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, empty);
+
+   free(empty);
+}
+
+
+/* Set the values for the texture coord. and vertex arrays */
+void ios_create_arrays()
+{
+   if (psp_gfx_scaling == 1)
+   {
+      if (ios_device_ar <= ios_screen_ar)
+      {
+         ios_vertices[2] = ios_vertices[6] = ios_screen_physical_width - 1;
+         ios_vertices[5] = ios_vertices[7] = ios_screen_physical_width * ((float)ios_screen_height / (float)ios_screen_width);
+         
+        ios_mouse_setup(
+            0, 
+            ios_screen_physical_width - 1, 
+            (ios_screen_physical_height - ios_vertices[5]) / 2, 
+            ios_screen_physical_height - ((ios_screen_physical_height - ios_vertices[5]) / 2), 
+            (float)ios_screen_width / (float)ios_screen_physical_width, 
+            (float)ios_screen_height / ios_vertices[5]);
+      }
+      else
+      {
+         ios_vertices[2] = ios_vertices[6] = ios_screen_physical_height * ((float)ios_screen_width / (float)ios_screen_height);
+         ios_vertices[5] = ios_vertices[7] = ios_screen_physical_height - 1;
+         
+         ios_mouse_setup(
+            (ios_screen_physical_width - ios_vertices[2]) / 2,
+            ios_screen_physical_width - ((ios_screen_physical_width - ios_vertices[2]) / 2),
+            0,
+            ios_screen_physical_height - 1,
+            (float)ios_screen_width / ios_vertices[2], 
+            (float)ios_screen_height / (float)ios_screen_physical_height);
+      }
+   }
+   else if (psp_gfx_scaling == 2)
+   {
+      ios_vertices[2] = ios_vertices[6] = ios_screen_physical_width - 1;
+      ios_vertices[5] = ios_vertices[7] = ios_screen_physical_height - 1;
+      
+      ios_mouse_setup(
+         0, 
+         ios_screen_physical_width - 1, 
+         0, 
+         ios_screen_physical_width - 1, 
+         (float)ios_screen_width / (float)ios_screen_physical_width, 
+         (float)ios_screen_height / (float)ios_screen_physical_height);     
+   }   
+   else
+   {
+      ios_vertices[0] = ios_vertices[4] = ios_screen_width * (-0.5f);
+      ios_vertices[2] = ios_vertices[6] = ios_screen_width * 0.5f;
+      ios_vertices[5] = ios_vertices[7] = ios_screen_height * 0.5f;
+      ios_vertices[1] = ios_vertices[3] = ios_screen_height * (-0.5f);
+      
+      ios_mouse_setup(
+         (ios_screen_physical_width - ios_screen_width) / 2,
+         ios_screen_physical_width - ((ios_screen_physical_width - ios_screen_width) / 2),
+         (ios_screen_physical_height - ios_screen_height) / 2, 
+         ios_screen_physical_height - ((ios_screen_physical_height - ios_screen_height) / 2), 
+         1.0f,
+         1.0f);
+   }
+
+   ios_texture_coordinates[1] = ios_texture_coordinates[3] = (float)ios_screen_height / (float)ios_screen_texture_height;
+   ios_texture_coordinates[2] = ios_texture_coordinates[6] = (float)ios_screen_width / (float)ios_screen_texture_width;
+}
+
+
+/* Called from the Java app to set up the screen */
+void ios_initialize_renderer(int screen_width, int screen_height)
+{
+   ios_screen_physical_width = screen_width;
+   ios_screen_physical_height = screen_height;
+   ios_screen_initialized = 0;
+}
+
+
+void ios_initialize_opengl()
+{
+   ios_screen_ar = (float)ios_screen_width / (float)ios_screen_height;
+   ios_device_ar = (float)ios_screen_physical_width / (float)ios_screen_physical_height;
+
+   glEnable(GL_CULL_FACE);
+   glEnable(GL_TEXTURE_2D);
+   glDisable(GL_DEPTH_TEST);
+   glDisable(GL_LIGHTING);
+   glDisable(GL_BLEND);
+   glDisable(GL_SCISSOR_TEST);
+   glShadeModel(GL_FLAT);
+
+   glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+
+   glViewport(0, 0, ios_screen_physical_width, ios_screen_physical_height);
+   glScissor(0, 0, ios_screen_physical_width, ios_screen_physical_height);
+   glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+   glClear(GL_COLOR_BUFFER_BIT);
+
+   glDisableClientState(GL_COLOR_ARRAY);
+   glDisableClientState(GL_NORMAL_ARRAY);
+   glEnableClientState(GL_VERTEX_ARRAY);
+   glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+   glTexCoordPointer(2, GL_FLOAT, 0, ios_texture_coordinates);
+   glVertexPointer(2, GL_FLOAT, 0, ios_vertices);
+
+   ios_create_screen_texture(ios_screen_width, ios_screen_height, ios_screen_color_depth);
+   ios_create_arrays();
+
+   glBindTexture(GL_TEXTURE_2D, ios_screen_texture);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+   if (psp_gfx_smoothing)
+   {
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+   }
+   else
+   {
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+   }
+
+   glViewport(0, 0, ios_screen_physical_width, ios_screen_physical_height);
+
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+
+   glOrthof(0, ios_screen_physical_width - 1, 0, ios_screen_physical_height - 1, 0, 1);
+
+   glMatrixMode(GL_MODELVIEW);
+   glLoadIdentity();
+
+   if (psp_gfx_scaling == 1)
+   {
+      if (ios_device_ar <= ios_screen_ar)
+         glTranslatef(0, (ios_screen_physical_height - ios_vertices[5] - 1) / 2, 0);
+      else
+         glTranslatef((ios_screen_physical_width - ios_vertices[2] - 1) / 2, 0, 0);
+   }
+   else if (psp_gfx_scaling == 0)
+   {
+      glTranslatef(ios_screen_physical_width / 2.0f, ios_screen_physical_height / 2.0f, 0);
+   }
+}
+
+
+void ios_render()
+{
+   ios_select_buffer();
+
+   if (!ios_screen_initialized)
+   {
+      ios_initialize_opengl();
+      ios_screen_initialized = 1;
+   }
+
+   if (ios_screen_color_depth == 16)
+      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, ios_screen_width, ios_screen_height, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, displayed_video_bitmap->line[0]);
+   else
+      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, ios_screen_width, ios_screen_height, GL_RGBA, GL_UNSIGNED_BYTE, displayed_video_bitmap->line[0]);
+
+   glClear(GL_COLOR_BUFFER_BIT);
+   glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+
+   glFinish();
+
+   ios_swap_buffers();	  
+}
diff -Naur src/ios/ikey.c src/ios/ikey.c
--- src/ios/ikey.c	1970-01-01 01:00:00.000000000 +0100
+++ src/ios/ikey.c	2012-05-18 07:54:09.983394900 +0200
@@ -0,0 +1,243 @@
+/*         ______   ___    ___
+*        /\  _  \ /\_ \  /\_ \
+*        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+*         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+*          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+*           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+*            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+*                                           /\____/
+*                                           \_/__/
+*
+*      Keyboard driver.
+*
+*      By JJS for the Adventure Game Studio runtime port.
+*      Based on the Allegro PSP port.
+*
+*      See readme.txt for copyright information.
+*/
+
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+#error Something is wrong with the makefile
+#endif
+
+
+static int ios_keyboard_init(void);
+static void ios_keyboard_exit(void);
+static void ios_keyboard_poll(void);
+static int ios_scancode_to_ascii(int scancode);
+
+extern int ios_get_last_keypress();
+
+
+static int ios_ascii_to_allegro[] = {
+   -1, // 0
+   -1, // 1
+   -1, // 2
+   -1, // 3
+   -1, // 4
+   -1, // 5
+   -1, // 6
+   -1, // 7
+   KEY_BACKSPACE, // 8
+   KEY_TAB, // 9
+   KEY_ENTER, // 10
+   -1, // 11
+   -1, // 12
+   KEY_ENTER, // 13
+   -1, // 14
+   -1, // 15
+   -1, // 16
+   -1, // 17
+   -1, // 18
+   -1, // 19
+   -1, // 20
+   -1, // 21
+   -1, // 22
+   -1, // 23
+   -1, // 24
+   -1, // 25
+   -1, // 26
+   KEY_ESC, // 27
+   -1, // 28
+   -1, // 29
+   -1, // 30
+   -1, // 31
+   KEY_SPACE, // 32
+   -1, // 33
+   KEY_QUOTE, // 34
+   -1, // 35
+   -1, // 36
+   -1, // 37
+   -1, // 38
+   -1, // 39
+   KEY_OPENBRACE, // 40
+   KEY_CLOSEBRACE, // 41
+   KEY_ASTERISK, // 42
+   KEY_PLUS_PAD, // 43
+   KEY_COMMA, // 44
+   -1, // 45
+   KEY_STOP, // 46
+   KEY_SLASH, // 47
+   KEY_0, // 48
+   KEY_1, // 49
+   KEY_2, // 50
+   KEY_3, // 51
+   KEY_4, // 52
+   KEY_5, // 53
+   KEY_6, // 54
+   KEY_7, // 55
+   KEY_8, // 56
+   KEY_9, // 57
+   KEY_COLON, // 58
+   KEY_SEMICOLON, // 59
+   -1, // 60
+   KEY_EQUALS, // 61
+   -1, // 62
+   -1, // 63
+   KEY_AT, // 64
+   KEY_A, // 65
+   KEY_B, // 66
+   KEY_C, // 67
+   KEY_D, // 68
+   KEY_E, // 69
+   KEY_F, // 70
+   KEY_G, // 71
+   KEY_H, // 72
+   KEY_I, // 73
+   KEY_J, // 74
+   KEY_K, // 75
+   KEY_L, // 76
+   KEY_M, // 77
+   KEY_N, // 78
+   KEY_O, // 79
+   KEY_P, // 80
+   KEY_Q, // 81
+   KEY_R, // 82
+   KEY_S, // 83
+   KEY_T, // 84
+   KEY_U, // 85
+   KEY_V, // 86
+   KEY_W, // 87
+   KEY_X, // 88
+   KEY_Y, // 89
+   KEY_Z, // 90
+   -1, // 91
+   KEY_BACKSLASH, // 92
+   -1, // 93
+   KEY_CIRCUMFLEX, // 94
+   -1, // 95
+   -1, // 96
+   KEY_A, // 97
+   KEY_B, // 98
+   KEY_C, // 99
+   KEY_D, // 100
+   KEY_E, // 101
+   KEY_F, // 102
+   KEY_G, // 103
+   KEY_H, // 104
+   KEY_I, // 105
+   KEY_J, // 106
+   KEY_K, // 107
+   KEY_L, // 108
+   KEY_M, // 109
+   KEY_N, // 110
+   KEY_O, // 111
+   KEY_P, // 112
+   KEY_Q, // 113
+   KEY_R, // 114
+   KEY_S, // 115
+   KEY_T, // 116
+   KEY_U, // 117
+   KEY_V, // 118
+   KEY_W, // 119
+   KEY_X, // 120
+   KEY_Y, // 121
+   KEY_Z, // 122
+   -1, // 123
+   -1, // 124
+   -1, // 125
+   KEY_TILDE, // 126
+   -1 // 127
+};
+
+
+KEYBOARD_DRIVER keyboard_ios =
+{
+   KEYBOARD_IOS,
+   empty_string,
+   empty_string,
+   "iOS keyboard",
+   FALSE,  // int autorepeat;
+   ios_keyboard_init,
+   ios_keyboard_exit,
+   ios_keyboard_poll,
+   NULL,   // AL_METHOD(void, set_leds, (int leds));
+   NULL,   // AL_METHOD(void, set_rate, (int delay, int rate));
+   NULL,   // AL_METHOD(void, wait_for_input, (void));
+   NULL,   // AL_METHOD(void, stop_waiting_for_input, (void));
+   NULL,   // AL_METHOD(int,  scancode_to_ascii, (int scancode));
+   NULL    // scancode_to_name
+};
+
+
+static int ios_last_scancode = -1;
+
+
+static int ios_ascii_to_allegro_keycode(int* ascii)
+{
+   if (*ascii > 127)
+   {
+      int result = *ascii - 0x1000;
+     *ascii = 0;
+     return result;
+   }
+   else
+      return ios_ascii_to_allegro[*ascii];
+}
+
+
+static int ios_keyboard_init(void)
+{
+   return 0;
+}
+
+
+static void ios_keyboard_exit(void)
+{
+}
+
+
+static void ios_keyboard_poll(void)
+{
+   int ascii_code;
+   int allegro_keycode;
+   
+   // Hold the key down till the next keyboard poll
+   if (ios_last_scancode != -1)
+   {
+      _handle_key_release(ios_last_scancode); 
+      ios_last_scancode = -1;
+   }   
+   
+   ascii_code = ios_get_last_keypress();
+   if (ascii_code < 1)
+      return;
+   
+   allegro_keycode = ios_ascii_to_allegro_keycode(&ascii_code);
+   
+   if (allegro_keycode == -1)
+      return;
+
+   // Replace LF with CR
+   if (ascii_code == 10)
+      ascii_code = 13;
+
+   _handle_key_press(ascii_code, allegro_keycode);
+
+   ios_last_scancode = allegro_keycode;
+}
diff -Naur src/ios/imouse.c src/ios/imouse.c
--- src/ios/imouse.c	1970-01-01 01:00:00.000000000 +0100
+++ src/ios/imouse.c	2012-05-18 07:54:09.984395000 +0200
@@ -0,0 +1,212 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Mouse driver.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#include "math.h"
+
+#ifndef ALLEGRO_IOS
+#error something is wrong with the makefile
+#endif
+
+static int  ios_mouse_init(void);
+static void ios_mouse_exit(void);
+static void ios_mouse_position(int, int);
+static void ios_mouse_set_range(int, int, int, int);
+static void ios_mouse_get_mickeys(int *, int *);
+static void ios_mouse_poll(void);
+
+extern void ios_poll_mouse_relative(int* x, int* y);
+extern void ios_poll_mouse_absolute(int* x, int* y);
+extern int ios_poll_mouse_buttons();
+
+static int mouse_minx = 0;
+static int mouse_miny = 0;
+static int mouse_maxx = 320;
+static int mouse_maxy = 200;
+int ios_left_mouse_stay = 0;
+int ios_right_mouse_stay = 0;
+int ios_mouse_last_x = 0;
+int ios_mouse_last_y = 0;
+int ios_mouse_clip_left = 0;
+int ios_mouse_clip_right = 479;
+int ios_mouse_clip_top = 0;
+int ios_mouse_clip_bottom = 319;
+float ios_mouse_scaling_x = 1.0f;
+float ios_mouse_scaling_y = 1.0f;
+
+int config_mouse_control_mode = 0; // 0 = direct, 1 = relative
+
+
+MOUSE_DRIVER mouse_ios =
+{
+   MOUSE_IOS,
+   empty_string,
+   empty_string,
+   "iOS mouse",
+   ios_mouse_init,
+   ios_mouse_exit,
+   ios_mouse_poll,       // AL_METHOD(void, poll, (void));
+   NULL,                 // AL_METHOD(void, timer_poll, (void));
+   ios_mouse_position,
+   ios_mouse_set_range,
+   NULL,       // AL_METHOD(void, set_speed, (int xspeed, int yspeed));
+   ios_mouse_get_mickeys,
+   NULL,       // AL_METHOD(int,  analyse_data, (AL_CONST char *buffer, int size));
+   NULL,       // AL_METHOD(void,  enable_hardware_cursor, (AL_CONST int mode));
+   NULL        // AL_METHOD(int,  select_system_cursor, (AL_CONST int cursor));
+};
+
+
+
+static int ios_mouse_init(void)
+{
+   return 3; //Num of buttons.
+}
+
+
+void ios_clip_mouse(int* x, int* y)
+{
+   if (*x < ios_mouse_clip_left)
+      *x = ios_mouse_clip_left;
+
+   if (*y < ios_mouse_clip_top)
+      *y = ios_mouse_clip_top;
+
+   if (*x > ios_mouse_clip_right)
+      *x = ios_mouse_clip_right;
+
+   if (*y > ios_mouse_clip_bottom)
+      *y = ios_mouse_clip_bottom;
+
+   *x -= ios_mouse_clip_left;
+   *y -= ios_mouse_clip_top;
+}
+
+
+void ios_scale_mouse(int* x, int* y)
+{
+   *x = (float)*x * ios_mouse_scaling_x;
+   *y = (float)*y * ios_mouse_scaling_y;
+}
+
+
+void ios_mouse_setup(int left, int right, int top, int bottom, float scaling_x, float scaling_y)
+{
+   ios_mouse_clip_left = left;
+   ios_mouse_clip_right = right;
+   ios_mouse_clip_top = top;
+   ios_mouse_clip_bottom = bottom;
+   ios_mouse_scaling_x = scaling_x;
+   ios_mouse_scaling_y = scaling_y;
+}
+
+
+static void ios_mouse_poll(void)
+{
+
+   int new_x;
+   int new_y;
+   int new_click = ios_poll_mouse_buttons();
+
+   if (config_mouse_control_mode == 1)
+   {
+      ios_poll_mouse_relative(&new_x, &new_y);
+      ios_scale_mouse(&new_x, &new_y);
+   
+      new_x += _mouse_x;
+      new_y += _mouse_y;
+   }
+   else
+   {
+      ios_poll_mouse_absolute(&new_x, &new_y);
+      ios_clip_mouse(&new_x, &new_y);	
+      ios_scale_mouse(&new_x, &new_y);
+   }
+   
+   if (new_x < mouse_minx)
+      new_x = mouse_minx;
+
+   if (new_y < mouse_miny)
+      new_y = mouse_miny;
+
+   if (new_x > mouse_maxx)
+      new_x = mouse_maxx;
+
+   if (new_y > mouse_maxy)
+      new_y = mouse_maxy;
+
+   _mouse_x = new_x;
+   _mouse_y = new_y;
+   
+   
+   if (new_click == 1)
+      ios_left_mouse_stay = 10;
+   else if (new_click == 2)
+      ios_right_mouse_stay = 10;
+   else if (new_click == 10)
+      ios_left_mouse_stay = 10 * 1000 * 1000;
+   
+   if (ios_left_mouse_stay > 0)
+      ios_left_mouse_stay--;
+
+   if (ios_right_mouse_stay > 0)
+      ios_right_mouse_stay--;
+
+   if (ios_left_mouse_stay > 0)
+      _mouse_b = 1;
+   else if (ios_right_mouse_stay > 0)
+      _mouse_b = 2;
+   else
+      _mouse_b = 0;
+}
+
+
+
+
+static void ios_mouse_position(int x, int y)
+{
+   _mouse_x = x;
+   _mouse_y = y;
+}
+
+
+
+static void ios_mouse_set_range(int x1, int y1, int x2, int y2)
+{
+   mouse_minx = x1;
+   mouse_miny = y1;
+   mouse_maxx = x2;
+   mouse_maxy = y2;
+}
+
+
+
+static void ios_mouse_get_mickeys(int *mickeyx, int *mickeyy)
+{
+
+}
+
+
+
+static void ios_mouse_exit(void)
+{
+}
+
diff -Naur src/ios/isound.c src/ios/isound.c
--- src/ios/isound.c	1970-01-01 01:00:00.000000000 +0100
+++ src/ios/isound.c	2012-05-18 07:54:09.984895100 +0200
@@ -0,0 +1,174 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Audio driver.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#include <AudioToolbox/AudioToolbox.h>
+#include <pthread.h>
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+#error something is wrong with the makefile
+#endif
+
+
+#define SAMPLES_PER_BUFFER 1024
+
+
+static int digi_ios_detect(int);
+static int digi_ios_init(int, int);
+static void digi_ios_exit(int);
+
+static short sound_buffer[2][SAMPLES_PER_BUFFER][2];
+int curr_buffer = 0;
+
+AudioQueueRef ios_queue;
+AudioQueueBufferRef ios_queue_buffer[3];
+
+int ios_audio_playing = 0;
+
+DIGI_DRIVER digi_ios =
+{
+   DIGI_IOS,
+   empty_string,
+   empty_string,
+   "iOS digital sound driver",
+   0,
+   0,
+   MIXER_MAX_SFX,
+   MIXER_DEF_SFX,
+
+   digi_ios_detect,
+   digi_ios_init,
+   digi_ios_exit,
+   NULL,
+   NULL,
+
+   NULL,
+   NULL,
+   NULL,
+   _mixer_init_voice,
+   _mixer_release_voice,
+   _mixer_start_voice,
+   _mixer_stop_voice,
+   _mixer_loop_voice,
+
+   _mixer_get_position,
+   _mixer_set_position,
+
+   _mixer_get_volume,
+   _mixer_set_volume,
+   _mixer_ramp_volume,
+   _mixer_stop_volume_ramp,
+
+   _mixer_get_frequency,
+   _mixer_set_frequency,
+   _mixer_sweep_frequency,
+   _mixer_stop_frequency_sweep,
+
+   _mixer_get_pan,
+   _mixer_set_pan,
+   _mixer_sweep_pan,
+   _mixer_stop_pan_sweep,
+
+   _mixer_set_echo,
+   _mixer_set_tremolo,
+   _mixer_set_vibrato,
+   0, 0,
+   0,
+   0,
+   0,
+   0,
+   0,
+   0
+};
+
+
+
+static int digi_ios_detect(int input)
+{
+   return TRUE;
+}
+
+
+void digi_ios_audio_callback(void* inUserData, AudioQueueRef inAQ, AudioQueueBufferRef inBuffer)
+{
+   void* bufptr = &sound_buffer[curr_buffer];
+   
+   if (!ios_audio_playing)
+      return;
+
+   /* Asks to the Allegro mixer to fill the buffer */
+   _mix_some_samples((uintptr_t)bufptr, 0, TRUE);
+
+   /* Send mixed buffer to sound card */
+   memcpy(inBuffer->mAudioData, bufptr, SAMPLES_PER_BUFFER * 2 * 2);
+   inBuffer->mAudioDataByteSize = SAMPLES_PER_BUFFER * 2 * 2;   
+   AudioQueueEnqueueBuffer(ios_queue, inBuffer, 0, NULL);
+
+   curr_buffer = !curr_buffer;
+}
+
+
+static int digi_ios_init(int input, int voices)
+{
+   int i;
+   AudioStreamBasicDescription dataFormat;
+
+   _sound_bits = 16;
+   _sound_stereo = TRUE;
+   _sound_freq = 44100;  
+  
+   digi_ios.voices = voices;
+
+   dataFormat.mSampleRate = _sound_freq;    
+   dataFormat.mFormatID = kAudioFormatLinearPCM;
+   dataFormat.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked;
+   dataFormat.mBytesPerPacket = 4;
+   dataFormat.mFramesPerPacket = 1;
+   dataFormat.mBytesPerFrame = 4;
+   dataFormat.mChannelsPerFrame = (_sound_stereo ? 2 : 1);
+   dataFormat.mBitsPerChannel = _sound_bits;
+   dataFormat.mReserved = 0;
+
+   AudioQueueNewOutput(&dataFormat, digi_ios_audio_callback, NULL, NULL, NULL, 0, &ios_queue);
+
+   for (i = 0; i < 3; i++)
+   {
+      AudioQueueAllocateBuffer(ios_queue, SAMPLES_PER_BUFFER * 2 * 2, &ios_queue_buffer[i]);
+      memset(ios_queue_buffer[i]->mAudioData, 0, SAMPLES_PER_BUFFER * 2 * 2);
+      ios_queue_buffer[i]->mAudioDataByteSize = SAMPLES_PER_BUFFER * 2 * 2;
+      AudioQueueEnqueueBuffer(ios_queue, ios_queue_buffer[i], 0, NULL);
+   }
+
+   ios_audio_playing = 1;
+
+   AudioQueueStart(ios_queue, NULL);
+
+   if (_mixer_init(SAMPLES_PER_BUFFER * 2, _sound_freq, _sound_stereo, (_sound_bits == 16), &digi_ios.voices))
+      return -1;
+
+   return 0;
+}
+
+
+static void digi_ios_exit(int input)
+{
+   ios_audio_playing = 0;
+   AudioQueueStop(ios_queue, 0);
+}
diff -Naur src/ios/isystem.c src/ios/isystem.c
--- src/ios/isystem.c	1970-01-01 01:00:00.000000000 +0100
+++ src/ios/isystem.c	2012-05-18 07:54:09.987395400 +0200
@@ -0,0 +1,102 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      System driver.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+   #error something is wrong with the makefile
+#endif
+
+
+static int ios_sys_init(void);
+static void ios_sys_exit(void);
+static void ios_get_gfx_safe_mode(int *driver, struct GFX_MODE *mode);
+
+
+
+SYSTEM_DRIVER system_ios =
+{
+   SYSTEM_IOS,
+   empty_string,
+   empty_string,
+   "iOS Device",
+   ios_sys_init,
+   ios_sys_exit,
+   NULL,  /* AL_METHOD(void, get_executable_name, (char *output, int size)); */
+   NULL,  /* AL_METHOD(int, find_resource, (char *dest, AL_CONST char *resource, int size)); */
+   NULL,  /* AL_METHOD(void, set_window_title, (AL_CONST char *name)); */
+   NULL,  /* AL_METHOD(int, set_close_button_callback, (AL_METHOD(void, proc, (void)))); */
+   NULL,  /* AL_METHOD(void, message, (AL_CONST char *msg)); */
+   NULL,  /* AL_METHOD(void, assert, (AL_CONST char *msg)); */
+   NULL,  /* AL_METHOD(void, save_console_state, (void)); */
+   NULL,  /* AL_METHOD(void, restore_console_state, (void)); */
+   NULL,  /* AL_METHOD(struct BITMAP *, create_bitmap, (int color_depth, int width, int height)); */
+   NULL,  /* AL_METHOD(void, created_bitmap, (struct BITMAP *bmp)); */
+   NULL,  /* AL_METHOD(struct BITMAP *, create_sub_bitmap, (struct BITMAP *parent, int x, int y, int width, int height)); */
+   NULL,  /* AL_METHOD(void, created_sub_bitmap, (struct BITMAP *bmp, struct BITMAP *parent)); */
+   NULL,  /* AL_METHOD(int, destroy_bitmap, (struct BITMAP *bitmap)); */
+   NULL,  /* AL_METHOD(void, read_hardware_palette, (void)); */
+   NULL,  /* AL_METHOD(void, set_palette_range, (AL_CONST struct RGB *p, int from, int to, int retracesync)); */
+   NULL,  /* AL_METHOD(struct GFX_VTABLE *, get_vtable, (int color_depth)); */
+   NULL,  /* AL_METHOD(int, set_display_switch_mode, (int mode)); */
+   NULL,  /* AL_METHOD(void, display_switch_lock, (int lock, int foreground)); */
+   NULL,  /* AL_METHOD(int, desktop_color_depth, (void)); */
+   NULL,  /* AL_METHOD(int, get_desktop_resolution, (int *width, int *height)); */
+   ios_get_gfx_safe_mode,  /*AL_METHOD(void, get_gfx_safe_mode, (int *driver, struct GFX_MODE *mode));*/
+   NULL,  /* AL_METHOD(void, yield_timeslice, (void)); */
+   NULL,  /* AL_METHOD(void *, create_mutex, (void)); */
+   NULL,  /* AL_METHOD(void, destroy_mutex, (void *handle)); */
+   NULL,  /* AL_METHOD(void, lock_mutex, (void *handle)); */
+   NULL,  /* AL_METHOD(void, unlock_mutex, (void *handle)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, gfx_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, digi_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, midi_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, keyboard_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, mouse_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, joystick_drivers, (void)); */
+   NULL   /* AL_METHOD(_DRIVER_INFO *, timer_drivers, (void)); */
+};
+
+
+
+static int ios_sys_init(void)
+{
+   os_type = OSTYPE_IOS;
+
+   return 0;
+}
+
+
+
+static void ios_sys_exit(void)
+{
+   
+}
+
+
+
+static void ios_get_gfx_safe_mode(int *driver, struct GFX_MODE *mode)
+{
+   *driver = GFX_IOS;
+   mode->width = 320;
+   mode->height = 200;
+   mode->bpp = 16;
+}
diff -Naur src/ios/itimer.c src/ios/itimer.c
--- src/ios/itimer.c	1970-01-01 01:00:00.000000000 +0100
+++ src/ios/itimer.c	2012-05-18 07:54:09.988895600 +0200
@@ -0,0 +1,228 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Timer driver.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Unix timer driver by Peter Wang.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+   #error something is wrong with the makefile
+#endif
+
+#include <pthread.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+
+/* See hack later.  */
+#ifdef ALLEGRO_LINUX_VGA
+#ifdef ALLEGRO_HAVE_SYS_IO_H
+/* iopl() exists in here instead of unistd.h in glibc */
+#include <sys/io.h>
+#endif
+#include "allegro/platform/aintlnx.h"
+#endif
+
+
+#define TIMER_TO_USEC(x)  ((long)((x) / 1.193181))
+#define USEC_TO_TIMER(x)  ((long)((x) * (TIMERS_PER_SECOND / 1000000.)))
+
+
+static int ptimer_init(void);
+static void ptimer_exit(void);
+void _unix_rest(unsigned int ms, void (*callback) (void));
+
+
+TIMER_DRIVER timer_ios =
+{
+   TIMER_IOS,
+   empty_string,
+   empty_string,
+   "Unix pthreads timers",
+   ptimer_init,
+   ptimer_exit,
+   NULL, NULL,		/* install_int, remove_int */
+   NULL, NULL,		/* install_param_int, remove_param_int */
+   NULL, NULL,		/* can_simulate_retrace, simulate_retrace */
+   _unix_rest		/* rest */
+};
+
+
+
+static pthread_t thread;
+static int thread_alive;
+
+
+
+
+
+/* ptimer_thread_func:
+ *  The timer thread.
+ */
+static void *ptimer_thread_func(void *unused)
+{
+   struct timeval old_time;
+   struct timeval new_time;
+   struct timeval delay;
+   long interval = 0x8000;
+
+
+   gettimeofday(&old_time, 0);
+
+   while (thread_alive) {
+      /* `select' is more accurate than `usleep' on my system.  */
+      delay.tv_sec = interval / TIMERS_PER_SECOND;
+      delay.tv_usec = TIMER_TO_USEC(interval) % 1000000L;
+      select(0, NULL, NULL, NULL, &delay);
+
+      /* Calculate actual time elapsed.  */
+      gettimeofday(&new_time, 0);
+      interval = USEC_TO_TIMER((new_time.tv_sec - old_time.tv_sec) * 1000000L
+			       + (new_time.tv_usec - old_time.tv_usec));
+      old_time = new_time;
+
+      /* Handle a tick.  */
+      interval = _handle_timer_tick(interval);
+   }
+
+   return NULL;
+}
+
+
+
+/* ptimer_init:
+ *  Installs the timer thread.
+ */
+static int ptimer_init(void)
+{
+   thread_alive = 1;
+
+   if (pthread_create(&thread, NULL, ptimer_thread_func, NULL) != 0) {
+   thread_alive = 0;
+      return -1;
+   }
+   return 0;
+}
+
+
+
+/* ptimer_exit:
+ *  Shuts down the timer thread.
+ */
+static void ptimer_exit(void)
+{
+   if (thread_alive) {
+      thread_alive = 0;
+      pthread_join(thread, NULL);
+   }
+}
+
+
+
+
+
+
+
+
+/* timeval_subtract:
+ *  Subtract the `struct timeval' values X and Y, storing the result
+ *  in RESULT.  Return 1 if the difference is negative, otherwise 0.
+ *
+ *  This function is from the glibc manual.  It handles weird platforms
+ *  where the tv_sec is unsigned.
+ */
+static int timeval_subtract(struct timeval *result,
+			    struct timeval *x,
+			    struct timeval *y)
+{
+   /* Perform the carry for the later subtraction by updating Y. */
+   if (x->tv_usec < y->tv_usec) {
+      int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
+      y->tv_usec -= 1000000 * nsec;
+      y->tv_sec += nsec;
+   }
+   if (x->tv_usec - y->tv_usec > 1000000) {
+      int nsec = (x->tv_usec - y->tv_usec) / 1000000;
+      y->tv_usec += 1000000 * nsec;
+      y->tv_sec -= nsec;
+   }
+
+   /* Compute the time remaining to wait.
+    * `tv_usec' is certainly positive. */
+   result->tv_sec = x->tv_sec - y->tv_sec;
+   result->tv_usec = x->tv_usec - y->tv_usec;
+   /* Return 1 if result is negative. */
+   return x->tv_sec < y->tv_sec;
+}
+
+
+
+void _unix_rest(unsigned int ms, void (*callback) (void))
+{
+   if (callback) {
+      struct timeval tv, tv_end;
+
+      gettimeofday (&tv_end, NULL);
+      tv_end.tv_usec += ms * 1000;
+      tv_end.tv_sec  += (tv_end.tv_usec / 1000000L);
+      tv_end.tv_usec %= 1000000L;
+
+      while (1)
+      {
+         (*callback)();
+         gettimeofday (&tv, NULL);
+         if (tv.tv_sec > tv_end.tv_sec)
+            break;
+         if (tv.tv_sec == tv_end.tv_sec && tv.tv_usec >= tv_end.tv_usec)
+             break;
+      }
+   }
+   else {
+      struct timeval now;
+      struct timeval end;
+      struct timeval delay;
+      int result;
+
+      gettimeofday(&now, NULL);
+
+      end = now;
+      end.tv_usec += ms * 1000;
+      end.tv_sec  += (end.tv_usec / 1000000L);
+      end.tv_usec %= 1000000L;
+
+      while (1) {
+	 if (timeval_subtract(&delay, &end, &now))
+	    break;
+
+#ifdef ALLEGRO_MACOSX
+	 result = usleep((delay.tv_sec * 1000000L) + delay.tv_usec);
+#else
+	 result = select(0, NULL, NULL, NULL, &delay);
+#endif
+	 if (result == 0)	/* ok */
+	    break;
+	 if ((result != -1) || (errno != EINTR))
+	    break;
+
+	 /* interrupted */
+	 gettimeofday(&now, NULL);
+      }
+   }
+}
