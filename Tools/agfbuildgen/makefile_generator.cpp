//=============================================================================
//
// Adventure Game Studio (AGS)
//
// Copyright (C) 1999-2011 Chris Jones and 2011-2025 various contributors
// The full list of copyright holders can be found in the Copyright.txt
// file, which is part of this source code distribution.
//
// The AGS source code is provided under the Artistic License 2.0.
// A copy of this license can be found in the file License.txt and at
// https://opensource.org/license/artistic-2-0/
//
//=============================================================================
#include <vector>
#include "makefile_writer.h"
#include "data/agfreader.h"
#include "generator_common.h"

using namespace AGS;
using namespace AGS::Common;
using namespace WriterUtils;

// Note on Makefile
// The $@ and $< are called automatic variables.
// - The variable $@ represents the name of the target;
// - The variable $< represents the first prerequisite required to create the output file.

namespace MakefileGenerator {

void GenerateMakefile(const GeneratorOptions& opt) {
    // TO-DO: we don't want to set the OutputWriter here because then it will write a file and be harder to test
    // instead it's best to the this as an input parameter here, we can then use a different function to wrap this
    // and call it or alternatively expose the name of the build file on the header and have the caller do it.
    // std::unique_ptr<OutputWriterInterface> outfile(new OutputFileWriter("Makefile"));

    // FIX-ME:  this is wrong somehow and triggers the destructor!!
    // MakefileWriter writer(std::move(outfile));
    MakefileWriter writer(opt.OutputFile);

    const std::vector<String> crm_list = opt.RoomFileList;
    const std::vector<String> headers_list = opt.HeaderFileList;
    const std::vector<String> scripts_list = opt.ScriptFileList;
    const std::vector<String> trs_files = opt.TrsFileList;

    writer.Comment("Makefile for AGS GAME");
    // Variables
    writer.Variable("AGSCC", opt.ToolAgscc);
    writer.Variable("AGFEXPORT", opt.ToolAgfexport);
    writer.Variable("AGF2DLASC", opt.ToolAgf2dlgasc);
    writer.Variable("TRAC", opt.ToolTrac);
    writer.Variable("AGSPAK", opt.ToolAgspak);
    writer.Variable("CRM2ASH", opt.ToolCrm2ash);
    writer.Variable("GAME_PROJECT_DIR", opt.GameProjectDir);
    writer.Variable("GAME_PROJECT_FILE", opt.GameProjectFile);
    writer.Variable("OUTPUT_DIR", opt.OutputDir);
    writer.Variable("TEMP_DIR", opt.TempDir);
    writer.Variable("AGSDEFNS_FILE", opt.AgsDefnsFile);

    // Auto headers
    writer.Rule("$(TEMP_DIR)/_AutoGenerated.ash", {"$(GAME_PROJECT_FILE)"}, "$(AGFEXPORT) autoash $< $@");
    writer.Rule("$(TEMP_DIR)/_GlobalVariables.ash", {"$(GAME_PROJECT_FILE)"},"$(AGFEXPORT) glvar $< $(TEMP_DIR)/_GlobalVariables.ash $(TEMP_DIR)/_GlobalVariables.asc");
    writer.Rule("$(TEMP_DIR)/DialogScript.asc", {"$(GAME_PROJECT_FILE)"}, "$(AGF2DLASC) $< $@");

    // Compile script modules
    std::vector<String> headers_base {"$(AGSDEFNS_FILE)","$(TEMP_DIR)/_AutoGenerated.ash","$(TEMP_DIR)/_GlobalVariables.ash"};

    for (int i = 0; i < scripts_list.size(); i++) {
        const auto &script = scripts_list[i];

        String scriptname = script.Left(script.GetLength() - 4); // Strip extension
        String asc = String::FromFormat("$(GAME_PROJECT_DIR)/%s", script.GetCStr());
        String out = String::FromFormat("$(TEMP_DIR)/%s.o", scriptname.GetCStr());

        std::vector<String> this_script_headers(headers_base);
        this_script_headers.insert(this_script_headers.end(), headers_list.begin(), headers_list.begin() + i);
        String headers = Join(":", this_script_headers);

        std::vector<String> dependencies(this_script_headers);
        dependencies.push_back(asc);
        String cmd = String::FromFormat("$(AGSCC) %s %s -H %s", asc.GetCStr(), out.GetCStr(), headers.GetCStr());

        writer.Rule(out, dependencies, cmd);
    }

    // Compile dialog script
    if(opt.HasDialogScripts)
    {
        String asc = "$(TEMP_DIR)/DialogScript.asc";
        String out = "$(TEMP_DIR)/DialogScript.o";
        std::vector<String> script_headers(headers_base);
        script_headers.insert(script_headers.end(), headers_list.begin(), headers_list.end());
        String headers = Join(":", script_headers);

        std::vector<String> dependencies(script_headers);
        dependencies.push_back(asc);

        String cmd = String::FromFormat("$(AGSCC) %s %s -H %s", asc.GetCStr(), out.GetCStr(), headers.GetCStr());

        writer.Rule(out, dependencies, cmd);
    }

    // Handle rooms
    for (const auto &crm : crm_list) {
        String room = crm.Left(crm.GetLength() - 4); // Strip ".crm" extension
        String room_header = String::FromFormat("%s.ash", room.GetCStr());
        String room_crm_file = String::FromFormat("$(GAME_PROJECT_DIR)/%s", crm.GetCStr());

        writer.Rule(room_header,{room_crm_file},"$(CRM2ASH) $< $@");
    }

    // Generate TRA files from TRS files using trac.exe
    for (const auto &trs : trs_files) {
        String tra = trs.Left(trs.GetLength() - 4); // Strip ".trs" extension
        writer.Rule(String::FromFormat("$(TEMP_DIR)/%s.tra", tra.GetCStr()),
                    {trs},
                    "$(TRAC) $< $@");
    }

    // build game28.dta

    // Package the game files using agspak.exe (Placeholder logic for now)
    // writer.Rule("game.ags", {"temp/game28.dta", "temp/acsprset.spr", "temp/sprindex.dat"},
    //     "$(AGSPAK) $^ $@");

    // Package the audio and speech files
    // writer.Rule("audio.vox", {"AudioCache/*"}, "$(AGSPAK) $^ $@");
    // writer.Rule("speech.vox", {"Speech/*"}, "$(AGSPAK) $^ $@");

    writer.Close(); // TO-DO: refactor to not need this
}

} // namespace MakefileGenerator
