diff --git a/CMakeLists.txt b/CMakeLists.txt
index 245be10..105c923 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -65,7 +65,7 @@ if(WIN32)
     endif()
 endif(WIN32)
 
-set(ALLEGRO_VERSION 4.4.2)
+set(ALLEGRO_VERSION 4.4.3)
 string(REGEX MATCH "^[0-9]+[.][0-9]+" ALLEGRO_SOVERSION ${ALLEGRO_VERSION})
 
 # Mac OS X -compatibility_version.
@@ -95,7 +95,7 @@ include(Common)
 # Build options
 #
 
-option(SHARED "Build shared library for main Allegro library" on)
+option(SHARED "Build shared library for main Allegro library and addons" on)
 set(BUILD_SHARED_LIBS ${SHARED})    # actual CMake variable
 
 # On some 64-bit platforms, libraries should be installed into `lib64'
@@ -107,6 +107,7 @@ option(MAGIC_MAIN "Enable magic main (Unix)" off)
 option(WANT_FRAMEWORKS "Want frameworks on Mac OS X" off)
 option(WANT_EMBED
     "Make frameworks embeddable in application bundles (Mac OS X)" on)
+option(ENABLE_QUICKDRAW "Enable Quick Graphics on OS X" OFF)
 
 set(FRAMEWORK_INSTALL_PREFIX "/Library/Frameworks" CACHE STRING
     "Directory in which to install Mac OS X frameworks")
@@ -451,6 +452,15 @@ if(ALLEGRO_UNIX) # not MACOSX
         endif(ALSA_FOUND)
     endif(WANT_ALSA)
 
+    pkg_check_modules(SDL2 sdl2)
+    if(SDL2_FOUND)
+        set(ALLEGRO_WITH_SDL2DIGI 1)
+        include_directories(SYSTEM ${SDL2_INCLUDE_DIRS})
+        link_directories(${SDL2_LIBRARY_DIRS})
+        list(APPEND PLATFORM_LIBS_NON_MODULES ${SDL2_LIBRARIES})
+        add_our_module(alleg-sdl2digi src/unix/sdl2digi.c ${SDL2_LIBRARIES})
+    endif(SDL2_FOUND)
+
     if(WANT_JACK)
         pkg_check_modules(JACK jack)
         if(JACK_FOUND)
@@ -538,6 +548,7 @@ option(WANT_LINUX_CONSOLE "Want Linux console support (Linux)" off)
 option(WANT_LINUX_VGA "Want Linux console VGA driver (Linux)" on)
 option(WANT_LINUX_FBCON "Want Linux console fbcon driver (Linux)" on)
 option(WANT_LINUX_SVGALIB "Want Linux console SVGAlib driver (Linux)" on)
+option(WANT_LINUX_TSLIB "Want Linux console tslib mouse driver (Linux)" on)
 
 if(WANT_LINUX_CONSOLE AND CMAKE_SYSTEM_NAME STREQUAL Linux)
     set(ALLEGRO_LINUX 1)
@@ -582,6 +593,16 @@ if(WANT_LINUX_CONSOLE AND CMAKE_SYSTEM_NAME STREQUAL Linux)
                 ${SVGALIB_LIBRARY})
         endif()
     endif()
+
+    if(WANT_LINUX_TSLIB)
+        find_package(Tslib)
+        if(TSLIB_FOUND)
+            set(ALLEGRO_LINUX_TSLIB 1)
+            include_directories(SYSTEM ${TSLIB_INCLUDE_DIR})
+            set(CMAKE_REQUIRED_LIBRARIES ${TSLIB_LIBRARY})
+            list(APPEND PLATFORM_LIBS ${TSLIB_LIBRARY})
+        endif()
+    endif()
 endif(WANT_LINUX_CONSOLE AND CMAKE_SYSTEM_NAME STREQUAL Linux)
 
 # -- Windows --
@@ -637,6 +658,13 @@ endif(BEOS)
 
 if(ALLEGRO_MACOSX)
     list(APPEND PLATFORM_SOURCES ${ALLEGRO_SRC_MACOSX_FILES})
+    IF(ENABLE_QUICKDRAW)
+      SET_SOURCE_FILES_PROPERTIES(
+        ${ALLEGRO_SRC_MACOSX_FILES}
+        PROPERTIES
+            COMPILE_FLAGS ENABLE_QUICKDRAW
+      )
+    ENDIF()
     if(NOT SHARED)
 	list(APPEND PLATFORM_SOURCES src/macosx/main.m)
     endif(NOT SHARED)
@@ -647,8 +675,9 @@ if(ALLEGRO_MACOSX)
     find_library(COREAUDIO_LIBRARY CoreAudio)
     find_library(AUDIOUNIT_LIBRARY AudioUnit)
     find_library(AUDIOTOOLBOX_LIBRARY AudioToolbox)
+    find_library(OPENGL_LIBRARY OpenGL)
     find_package(QuickTime)
-    mark_as_advanced(COCOA_LIBRARY CARBON_LIBRARY IOKIT_LIBRARY)
+    mark_as_advanced(COCOA_LIBRARY CARBON_LIBRARY IOKIT_LIBRARY OPENGL_LIBRARY)
     mark_as_advanced(COREAUDIO_LIBRARY AUDIOUNIT_LIBRARY AUDIOTOOLBOX_LIBRARY)
     mark_as_advanced(QUICKTIME_INCLUDE_DIR QUICKTIME_LIBRARY)
 
@@ -660,6 +689,7 @@ if(ALLEGRO_MACOSX)
 	${AUDIOUNIT_LIBRARY}
 	${AUDIOTOOLBOX_LIBRARY}
 	${QUICKTIME_LIBRARY}
+	${OPENGL_LIBRARY}
 	)
 endif(ALLEGRO_MACOSX)
 
@@ -907,12 +937,17 @@ option(WANT_LOADPNG "Enable loadpng" on)
 option(WANT_LOGG "Enable logg" on)
 option(WANT_JPGALLEG "Enable JPGAlleg" on)
 
-if(WANT_FRAMEWORKS)
+if (BUILD_SHARED_LIBS)
     set(ADDON_LINKAGE SHARED)
 else()
     set(ADDON_LINKAGE STATIC)
 endif()
 
+if(WANT_FRAMEWORKS)
+    set(ADDON_LINKAGE SHARED)
+endif()
+
+
 if(WANT_ALLEGROGL)
     add_subdirectory(addons/allegrogl)
 endif()
diff --git a/addons/allegrogl/src/fontconv.c b/addons/allegrogl/src/fontconv.c
index a660d30..ee363ff 100644
--- a/addons/allegrogl/src/fontconv.c
+++ b/addons/allegrogl/src/fontconv.c
@@ -4,10 +4,10 @@
 /** \file fontconv.c
  *  \brief Allegro FONT conversion routines.
  *
- * Notes: - Depends on the Allegro's FONT structure remaining 
+ * Notes: - Depends on the Allegro's FONT structure remaining
  *          intact.
  * Bugs:  - Bitmapped font support is flakey at best.
- * 
+ *
  */
 
 #include <math.h>
@@ -128,7 +128,7 @@ static int iroundf(float v) {
 	}
 	else {
 		/* distance to ceil smaller than distance to floor */
-		if ((c - v) < (v - f)) 
+		if ((c - v) < (v - f))
 			return (int)f;
 		else
 			return (int)c;
@@ -282,7 +282,7 @@ static int agl_get_font_range_end(FONT *f, int range) {
 		fad = next;
 		n++;
 	}
-	
+
 	return -1;
 }
 
@@ -298,7 +298,7 @@ static int create_textured_font_call_lists(AGL_GLYPH *coords, int max, BITMAP *b
 	scale = fabs(scale);
 
 	list = glGenLists(max);
-		
+
 	for (i = 0; i < max; i++) {
 		/* Coords of glyph in texture (texture coords) */
 		float tx = (float)coords[i].x / bmp->w;
@@ -329,7 +329,7 @@ static int create_textured_font_call_lists(AGL_GLYPH *coords, int max, BITMAP *b
 		}
 
 		glNewList(list + i, GL_COMPILE);
-			
+
 		glBegin(GL_QUADS);
 			glTexCoord2f(tx, ty);
 			glVertex2f(xoffs, -yoffs);
@@ -370,14 +370,14 @@ static FONT_AGL_DATA* copy_glyph_range(FONT_AGL_DATA *fad, int start, int end,
 	count = end - start;
 
 	coords = malloc(count * sizeof (AGL_GLYPH));
-		
+
 	/* for now, just copy glyph coords of the range */
 	for (i = 0; i < count; i++) {
 		coords[i] = fad->glyph_coords[start - fad->start + i];
 		coords[i].glyph_num = i;
 	}
-			
-	/* calculate the width of the glyphs and find the max height */	
+
+	/* calculate the width of the glyphs and find the max height */
 	for (i = 0; i < count; i++) {
 		int hh = coords[i].h + coords[i].offset_y + coords[i].offset_h;
 		if (h < hh)
@@ -510,7 +510,7 @@ static FONT *agl_extract_font_range(FONT *f, int start, int end) {
 				retval->data = newfad;
 			}
 		}
-			
+
 		next = next->next;
 	}
 
@@ -651,9 +651,9 @@ FONT *allegro_gl_convert_allegro_font(FONT *f, int type, float scale) {
  *
  *  You should destroy the font via allegro_gl_destroy_font() when you are
  *  done with it.
- * 
+ *
  * <b>Scaling</b>
- * 
+ *
  *  For #AGL_FONT_TYPE_TEXTURED fonts, glyphs in the font need to be mapped
  *  to OpenGL coordinates. The scale factor ensures that you get the scaling
  *  you need. scale reprents the number of pixels to be mapped to 1.0 OpenGL
@@ -675,7 +675,7 @@ FONT *allegro_gl_convert_allegro_font(FONT *f, int type, float scale) {
  *  it's ignored if the conversion will lead to a font of that type.
  *
  * <b>Format</b>
- * 
+ *
  *  The format specifies what internal format OpenGL should use for the texture,
  *  in the case of #AGL_FONT_TYPE_TEXTURED fonts. It has the same semantics as
  *  the internalformat parameter of glTexImage2D(). If you would like for
@@ -698,7 +698,7 @@ FONT *allegro_gl_convert_allegro_font_ex(FONT *f, int type, float scale,
 		FONT_COLOR_DATA* cf;
 		void *ptr;
 	} dat;
-	
+
 	if (!__allegro_gl_valid_context) {
 		return NULL;
 	}
@@ -750,13 +750,13 @@ FONT *allegro_gl_convert_allegro_font_ex(FONT *f, int type, float scale,
 		return NULL;
 	}
 	memset(destdata, 0, sizeof(FONT_AGL_DATA) * max);
-	
+
 	/* Construct the linked list */
 	for (i = 0; i < max - 1; i++) {
 		destdata[i].next = &destdata[i + 1];
 	}
 	destdata[max - 1].next = NULL;
-	
+
 	/* Set up the font */
 	dest->data = destdata;
 	dest->vtable = font_vtable_agl;
@@ -786,13 +786,13 @@ FONT *allegro_gl_convert_allegro_font_ex(FONT *f, int type, float scale,
 			aglf_convert_allegro_font_to_texture(&destdata, f, dat.ptr, &height,
 			                                     scale, format);
 		}
-			
+
 		if (height > dest->height) {
 			dest->height = height;
 		}
-			
+
 		dat.ptr = (is_mono_font(f) ? (void*)dat.mf->next : (void*)dat.cf->next);
-		
+
 		destdata = destdata->next;
 	}
 
@@ -807,7 +807,7 @@ FONT *allegro_gl_convert_allegro_font_ex(FONT *f, int type, float scale,
 static int sort_glyphs(const void *c1, const void *c2) {
 	AGL_GLYPH *g1 = (AGL_GLYPH*)c1;
 	AGL_GLYPH *g2 = (AGL_GLYPH*)c2;
-	
+
 	if (g1->w < g2->w) {
 		return 1;
 	}
@@ -826,7 +826,7 @@ static int sort_glyphs(const void *c1, const void *c2) {
 static int unsort_glyphs(const void *c1, const void *c2) {
 	AGL_GLYPH *g1 = (AGL_GLYPH*)c1;
 	AGL_GLYPH *g2 = (AGL_GLYPH*)c2;
-	
+
 	return g1->glyph_num - g2->glyph_num;
 }
 
@@ -837,7 +837,7 @@ static int unsort_glyphs(const void *c1, const void *c2) {
 static int sort_textures(const void *c1, const void *c2) {
 	texture_size *t1 = (texture_size*)c1;
 	texture_size *t2 = (texture_size*)c2;
-	
+
 	return t1->w * t1->h - t2->w * t2->h;
 }
 
@@ -875,13 +875,13 @@ static int aglf_sort_out_glyphs(BITMAP *bmp, AGL_GLYPH *glyphs, const int beg,
 	/* We now try to make all the glyphs fit on the bitmap */
 	for (i = 0; i < end - beg; i++) {
 		int collide = FALSE;
-	
+
 		/* Place glyphs on last_line */
 		glyphs[i].x = last_x;
 		glyphs[i].y = last_line;
-		
+
 		/* Check for collision */
-		
+
 		for (j = 0; j < i; j++) {
 			if ((glyphs[i].x >= glyphs[j].x + glyphs[j].w)
 			        || (glyphs[i].y >= glyphs[j].y + glyphs[j].h)
@@ -893,7 +893,7 @@ static int aglf_sort_out_glyphs(BITMAP *bmp, AGL_GLYPH *glyphs, const int beg,
 			glyphs[i].x = last_x;
 			j = 0;
 		}
-		
+
 		if ((last_x + glyphs[i].w > bmp->w)
 		 || (last_line + glyphs[i].h > bmp->h)) {
 			collide = TRUE;
@@ -946,11 +946,11 @@ static int split_font(FONT *f, void *source, void **dest1, void **dest2) {
 	union mixed_ptr range1, range2, src;
 	int colored;
 	int i;
-	
+
 	(*dest1) = NULL;
 	(*dest2) = NULL;
 	src.ptr = source;
-	
+
 	colored = (is_mono_font(f) ? FALSE : TRUE);
 
 	/* Allocate the ranges that we need */
@@ -963,7 +963,7 @@ static int split_font(FONT *f, void *source, void **dest1, void **dest2) {
 		      : (int)sizeof(FONT_MONO_DATA));
 		return FALSE;
 	}
-	
+
 	range2.ptr = malloc(colored ? sizeof(FONT_COLOR_DATA)
 	                            : sizeof(FONT_MONO_DATA));
 	if (!range2.ptr) {
@@ -974,23 +974,23 @@ static int split_font(FONT *f, void *source, void **dest1, void **dest2) {
 		free(range1.ptr);
 		return FALSE;
 	}
-	
+
 	(*dest1) = range1.ptr;
 	(*dest2) = range2.ptr;
-	
+
 	/* Now we split up the range */
 	if (colored) {
 		/* Half the range */
 		int mid = src.cf->begin + (src.cf->end - src.cf->begin) / 2;
-		
+
 		range1.cf->begin = src.cf->begin;
 		range1.cf->end = mid;
 		range2.cf->begin = mid;
 		range2.cf->end = src.cf->end;
-		
+
 		range1.cf->next = NULL;
 		range2.cf->next = NULL;
-		
+
 		/* Split up the bitmaps */
 		range1.cf->bitmaps = malloc(sizeof(BITMAP*)
 		                                * (range1.cf->end - range1.cf->begin));
@@ -1015,7 +1015,7 @@ static int split_font(FONT *f, void *source, void **dest1, void **dest2) {
 			return FALSE;
 		}
 
-		
+
 		for (i = 0; i < (range1.cf->end - range1.cf->begin); i++) {
 			range1.cf->bitmaps[i] = src.cf->bitmaps[i];
 		}
@@ -1027,15 +1027,15 @@ static int split_font(FONT *f, void *source, void **dest1, void **dest2) {
 	else {
 		/* Half the range */
 		int mid = src.mf->begin + (src.mf->end - src.mf->begin) / 2;
-		
+
 		range1.mf->begin = src.mf->begin;
 		range1.mf->end = mid;
 		range2.mf->begin = mid;
 		range2.mf->end = src.mf->end;
-		
+
 		range1.mf->next = NULL;
 		range2.mf->next = NULL;
-		
+
 		/* Split up the bitmaps */
 		range1.mf->glyphs = malloc(sizeof(FONT_GLYPH*)
 		                                 * (range1.mf->end - range1.mf->begin));
@@ -1059,7 +1059,7 @@ static int split_font(FONT *f, void *source, void **dest1, void **dest2) {
 			free(range2.ptr);
 			return FALSE;
 		}
-		
+
 		for (i = 0; i < (range1.mf->end - range1.mf->begin); i++) {
 			range1.mf->glyphs[i] = src.mf->glyphs[i];
 		}
@@ -1068,7 +1068,7 @@ static int split_font(FONT *f, void *source, void **dest1, void **dest2) {
 			            src.mf->glyphs[i + range2.mf->begin - range1.mf->begin];
 		}
 	}
-	
+
 	return TRUE;
 }
 
@@ -1077,7 +1077,7 @@ static int split_font(FONT *f, void *source, void **dest1, void **dest2) {
 /* Destroys a split font */
 static void destroy_split_font(FONT *f, union mixed_ptr range1,
                                         union mixed_ptr range2) {
-	
+
 	if (!is_mono_font(f)) {
 		free(range1.cf->bitmaps);
 		free(range2.cf->bitmaps);
@@ -1086,10 +1086,10 @@ static void destroy_split_font(FONT *f, union mixed_ptr range1,
 		free(range1.mf->glyphs);
 		free(range2.mf->glyphs);
 	}
-	
+
 	free(range1.ptr);
 	free(range2.ptr);
-	
+
 	return;
 }
 
@@ -1109,7 +1109,7 @@ static int do_crop_font_range(FONT *f, AGL_GLYPH *glyphs, int beg, int end) {
 		      "bitmap of size: %ix%i!\n", 32, 32);
 		goto error;
 	}
-	
+
 	/* Crop glyphs */
 	for (i = 0; i < max; i++) {
 		int used = 0;
@@ -1124,7 +1124,7 @@ static int do_crop_font_range(FONT *f, AGL_GLYPH *glyphs, int beg, int end) {
 				goto error;
 			}
 		}
-		clear(temp);
+		clear_bitmap(temp);
 
 		usetc(buf + usetc(buf, glyphs[i].glyph_num + beg), 0);
 
@@ -1157,7 +1157,7 @@ static int do_crop_font_range(FONT *f, AGL_GLYPH *glyphs, int beg, int end) {
 			glyphs[i].w = 1;
 			continue;
 		}
-		
+
 		/* Crop bottom */
 		j = glyphs[i].h + glyphs[i].offset_y - 1;
 		for ( /* above */; j >= glyphs[i].offset_y; j--) {
@@ -1218,7 +1218,7 @@ static int do_crop_font_range(FONT *f, AGL_GLYPH *glyphs, int beg, int end) {
 		      glyphs[i].offset_w, glyphs[i].offset_h);
 #endif
 	}
-	
+
 	destroy_bitmap(temp);
 
 	return TRUE;
@@ -1228,7 +1228,7 @@ error:
 		destroy_bitmap(temp);
 	}
 
-	return FALSE;	
+	return FALSE;
 }
 
 
@@ -1272,7 +1272,7 @@ static int crop_font_range(FONT *f, void *src, int beg, int end,
 		/* Not placed yet */
 		glyphs[i].x = -1;
 	}
-	
+
 	if (crop) {
 		ret = do_crop_font_range(f, glyphs, beg, end);
 	}
@@ -1333,7 +1333,7 @@ static BITMAP* look_for_texture(int beg, int end, AGL_GLYPH *glyphs,
 
 	for (i = 0; i < NUM_TEXTURE_SIZE * NUM_TEXTURE_SIZE; i++) {
 		int num_channels;
-		
+
 		/* Check the area - it must be larger than
 		 * all the glyphs
 		 */
@@ -1344,7 +1344,7 @@ static BITMAP* look_for_texture(int beg, int end, AGL_GLYPH *glyphs,
 		if (area < total_area) {
 			continue;
 		}
-			
+
 		/* Check against max values */
 		if ((t->h < max_h) || (t->w < max_w)) {
 			continue;
@@ -1392,7 +1392,7 @@ static BITMAP* look_for_texture(int beg, int end, AGL_GLYPH *glyphs,
 		destroy_bitmap(bmp);
 		bmp = NULL;
 	}
-	
+
 	return NULL;
 }
 
@@ -1452,7 +1452,7 @@ static int draw_glyphs(BITMAP *bmp, FONT *f, GLint format, int beg, int end,
 #endif
 		/* Generate an alpha font */
 		BITMAP *rgbbmp = create_bitmap_ex(24, bmp->w, bmp->h);
-		
+
 		if (!rgbbmp) {
 			TRACE(PREFIX_E "convert_allegro_font_to_texture: "
 			      "Ran out of memory while creating %ix%ix%i bitmap!\n",
@@ -1461,10 +1461,10 @@ static int draw_glyphs(BITMAP *bmp, FONT *f, GLint format, int beg, int end,
 		}
 
 		clear_bitmap(rgbbmp);
-		
+
 		for (i = 0; i < end - beg; i++) {
 			usetc(buf + usetc(buf, glyphs[i].glyph_num + beg), 0);
-			
+
 			textout_ex(rgbbmp, f, buf, glyphs[i].x - glyphs[i].offset_x,
 			                          glyphs[i].y - glyphs[i].offset_y, -1, -1);
 		}
@@ -1533,7 +1533,7 @@ static void aglf_convert_allegro_font_to_texture(FONT_AGL_DATA **dest, FONT *f,
 	int beg = 0, end = 0;
 	int max_w, max_h;
 	int total_area, gross_area;
-	
+
 	AGL_GLYPH *glyph_coords;
 
 	union mixed_ptr dat;
@@ -1609,7 +1609,7 @@ static void aglf_convert_allegro_font_to_texture(FONT_AGL_DATA **dest, FONT *f,
 		dest2->is_free_chunk = TRUE;
 		dest2->format = dest1->format;
 		dest2->has_alpha = dest1->has_alpha;
-		
+
 		if (split_font(f, dat.ptr, &f1.ptr, &f2.ptr) == FALSE) {
 			TRACE(PREFIX_E "convert_allegro_font_to_texture: Unable "
 			      "to split font!\n");
@@ -1617,7 +1617,7 @@ static void aglf_convert_allegro_font_to_texture(FONT_AGL_DATA **dest, FONT *f,
 			free(dest2);
 			return;
 		}
-		
+
 		aglf_convert_allegro_font_to_texture(&dest1, f, f1.ptr, height, scale,
 		                                     format);
 		height1 = (*height);
@@ -1628,7 +1628,7 @@ static void aglf_convert_allegro_font_to_texture(FONT_AGL_DATA **dest, FONT *f,
 		if (height1 > (*height))
 			(*height) = height1;
 		(*dest) = dest2;
-		
+
 		return;
 	}
 
@@ -1699,26 +1699,26 @@ static void aglf_convert_allegro_font_to_bitmap(FONT_AGL_DATA *dest, FONT *f,
 		      "memory while allocating %i bytes\n", (int)sizeof(FONT_GLYPH));
 		return;
 	}
-	
+
 	*height = f->height;
-		
-	if (is_mono_font(f)) {		
-	
+
+	if (is_mono_font(f)) {
+
 		/* for each glyph */
-		for (i = 0; i < max; i++) {		
+		for (i = 0; i < max; i++) {
 			FONT_GLYPH *oldgl = dat.mf->glyphs[i];
-	
+
 			int size = sizeof(FONT_GLYPH) + ((oldgl->w + 31) / 32) * 4
 			                                                         * oldgl->h;
-	
+
 			/* create new glyph */
 			FONT_GLYPH *newgl = (FONT_GLYPH*)malloc(size);
-	
+
 			if (!newgl)
 				break;
-	
+
 			memset(newgl, 0, size);
-	
+
 			newgl->w = oldgl->w;
 			newgl->h = oldgl->h;
 
@@ -1785,7 +1785,7 @@ static void aglf_convert_allegro_font_to_bitmap(FONT_AGL_DATA *dest, FONT *f,
 		}
 		dest->list_base = list;
 	}
-		
+
 	dest->is_free_chunk = 0;
 	dest->type = AGL_FONT_TYPE_BITMAP;
 	dest->start = beg;
diff --git a/addons/jpgalleg/include/jpgalleg.h b/addons/jpgalleg/include/jpgalleg.h
index a532823..64894f4 100644
--- a/addons/jpgalleg/include/jpgalleg.h
+++ b/addons/jpgalleg/include/jpgalleg.h
@@ -22,6 +22,26 @@
 
 #include <allegro.h>
 
+
+#if (defined JPGALLEG_DYNAMIC) && (defined ALLEGRO_WINDOWS)
+    #ifdef JPGALLEG_SRC_BUILD
+        #define _AJPG_DLL __declspec(dllexport)
+    #else
+        #define _AJPG_DLL __declspec(dllimport)
+    #endif /* ALLEGRO_GL_SRC_BUILD */
+#else
+    #define _AJPG_DLL
+#endif /* (defined JPGALLEG_DYNAMIC) && (defined ALLEGRO_WINDOWS) */
+
+#define AJPG_VAR(type, name) extern _AJPG_DLL type name
+
+#if (defined JPGALLEG_DYNAMIC) && (defined ALLEGRO_WINDOWS)
+    #define AJPG_FUNC(type, name, args) extern _AJPG_DLL type __cdecl name args
+#else
+    #define AJPG_FUNC(type, name, args) extern type name args
+#endif /* (defined JPGALLEG_DYNAMIC) && (defined ALLEGRO_WINDOWS) */
+
+
 /* Library version constant and string */
 #define JPGALLEG_VERSION 0x0206
 #define JPGALLEG_VERSION_STRING			"JPGalleg 2.6, by Angelo Mottola, 2000-2006"
@@ -63,20 +83,20 @@ extern "C" {
 #endif
 
 
-extern int jpgalleg_init(void);
+AJPG_FUNC(int, jpgalleg_init, (void));
 
-extern BITMAP *load_jpg(AL_CONST char *filename, RGB *palette);
-extern BITMAP *load_jpg_ex(AL_CONST char *filename, RGB *palette, void (*callback)(int progress));
-extern BITMAP *load_memory_jpg(void *buffer, int size, RGB *palette);
-extern BITMAP *load_memory_jpg_ex(void *buffer, int size, RGB *palette, void (*callback)(int progress));
+AJPG_FUNC(BITMAP *, load_jpg, (AL_CONST char *filename, RGB *palette));
+AJPG_FUNC(BITMAP *, load_jpg_ex, (AL_CONST char *filename, RGB *palette, void (*callback)(int progress)));
+AJPG_FUNC(BITMAP *, load_memory_jpg, (void *buffer, int size, RGB *palette));
+AJPG_FUNC(BITMAP *, load_memory_jpg_ex, (void *buffer, int size, RGB *palette, void (*callback)(int progress)));
 
-extern int save_jpg(AL_CONST char *filename, BITMAP *image, AL_CONST RGB *palette);
-extern int save_jpg_ex(AL_CONST char *filename, BITMAP *image, AL_CONST RGB *palette, int quality, int flags, void (*callback)(int progress));
-extern int save_memory_jpg(void *buffer, int *size, BITMAP *image, AL_CONST RGB *palette);
-extern int save_memory_jpg_ex(void *buffer, int *size, BITMAP *image, AL_CONST RGB *palette, int quality, int flags, void (*callback)(int progress));
+AJPG_FUNC(int, save_jpg, (AL_CONST char *filename, BITMAP *image, AL_CONST RGB *palette));
+AJPG_FUNC(int, save_jpg_ex, (AL_CONST char *filename, BITMAP *image, AL_CONST RGB *palette, int quality, int flags, void (*callback)(int progress)));
+AJPG_FUNC(int, save_memory_jpg, (void *buffer, int *size, BITMAP *image, AL_CONST RGB *palette));
+AJPG_FUNC(int, save_memory_jpg_ex, (void *buffer, int *size, BITMAP *image, AL_CONST RGB *palette, int quality, int flags, void (*callback)(int progress)));
 
-extern int jpgalleg_error;
-extern const char *jpgalleg_error_string(void);
+AJPG_VAR(int, jpgalleg_error);
+AJPG_FUNC(const char *, jpgalleg_error_string, (void));
 
 
 #ifdef __cplusplus
diff --git a/addons/loadpng/CHANGES.txt b/addons/loadpng/CHANGES.txt
index 351bb6b..3759d60 100644
--- a/addons/loadpng/CHANGES.txt
+++ b/addons/loadpng/CHANGES.txt
@@ -163,3 +163,6 @@
 	I haven't tested it.
 
 	Released: version 1.5.
+
+From December 2007, loadpng lives in the Allegro repository.
+This file is no longer updated.
diff --git a/addons/loadpng/LICENSE.txt b/addons/loadpng/LICENSE.txt
new file mode 100644
index 0000000..af62ca5
--- /dev/null
+++ b/addons/loadpng/LICENSE.txt
@@ -0,0 +1,21 @@
+Copyright (C) 1999-2012 Peter Wang
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
diff --git a/addons/loadpng/README.txt b/addons/loadpng/README.txt
index c545f61..fb9b2d0 100644
--- a/addons/loadpng/README.txt
+++ b/addons/loadpng/README.txt
@@ -4,8 +4,8 @@
 
 This wrapper is mostly a copy and paste job from example.c in the
 libpng docs, stripping out the useless transformations and making it
-use Allegro BITMAP and PALETTE structures.  It is placed in the public
-domain.
+use Allegro BITMAP and PALETTE structures.  It is released under the
+terms of the zlib license.  See LICENSE.txt for more information.
 
 
 Requirements:
diff --git a/addons/loadpng/loadpng.c b/addons/loadpng/loadpng.c
index 95fe4b9..f45f6ac 100644
--- a/addons/loadpng/loadpng.c
+++ b/addons/loadpng/loadpng.c
@@ -1,7 +1,5 @@
 /* loadpng, Allegro wrapper routines for libpng
  * by Peter Wang (tjaden@users.sf.net).
- *
- * This file is hereby placed in the public domain.
  */
 
 
diff --git a/addons/loadpng/loadpng.h b/addons/loadpng/loadpng.h
index 9d584de..35111d6 100644
--- a/addons/loadpng/loadpng.h
+++ b/addons/loadpng/loadpng.h
@@ -1,5 +1,4 @@
 /* loadpng.h */
-/* This file is hereby placed in the public domain. */
 #ifndef _included_loadpng_h_
 #define _included_loadpng_h_
 
@@ -8,6 +7,25 @@ extern "C" {
 #endif
 
 
+#if (defined LOADPNG_DYNAMIC) && (defined ALLEGRO_WINDOWS)
+    #ifdef LOADPNG_SRC_BUILD
+        #define _APNG_DLL __declspec(dllexport)
+    #else
+        #define _APNG_DLL __declspec(dllimport)
+    #endif /* ALLEGRO_GL_SRC_BUILD */
+#else
+    #define _APNG_DLL
+#endif /* (defined LOADPNG_DYNAMIC) && (defined ALLEGRO_WINDOWS) */
+
+#define APNG_VAR(type, name) extern _APNG_DLL type name
+
+#if (defined LOADPNG_DYNAMIC) && (defined ALLEGRO_WINDOWS)
+    #define APNG_FUNC(type, name, args) extern _APNG_DLL type __cdecl name args
+#else
+    #define APNG_FUNC(type, name, args) extern type name args
+#endif /* (defined LOADPNG_DYNAMIC) && (defined ALLEGRO_WINDOWS) */
+
+
 
 /* Overkill :-) */
 #define LOADPNG_VERSION		1
@@ -27,37 +45,37 @@ extern "C" {
  *
  * Otherwise, the value of _png_screen_gamma is taken as-is.
  */
-extern double _png_screen_gamma;
+APNG_VAR(double, _png_screen_gamma);
 
 
 /* Choose zlib compression level for saving file.
  * Default is Z_BEST_COMPRESSION.
  */
-extern int _png_compression_level;
+APNG_VAR(int, _png_compression_level);
 
 
 /* Load a PNG from disk. */
-extern BITMAP *load_png(AL_CONST char *filename, RGB *pal);
+APNG_FUNC(BITMAP *, load_png, (AL_CONST char *filename, RGB *pal));
 
 /* Load a PNG from some place. */
-extern BITMAP *load_png_pf(PACKFILE *fp, RGB *pal);
+APNG_FUNC(BITMAP *, load_png_pf, (PACKFILE *fp, RGB *pal));
 
 /* Load a PNG from memory. */
-extern BITMAP *load_memory_png(AL_CONST void *buffer, int buffer_size, RGB *pal);
+APNG_FUNC(BITMAP *, load_memory_png, (AL_CONST void *buffer, int buffer_size, RGB *pal));
 
 /* Save a bitmap to disk in PNG format. */
-extern int save_png(AL_CONST char *filename, BITMAP *bmp, AL_CONST RGB *pal);
+APNG_FUNC(int, save_png, (AL_CONST char *filename, BITMAP *bmp, AL_CONST RGB *pal));
 
 /* Adds `PNG' to Allegro's internal file type table.
  * You can then just use load_bitmap and save_bitmap as usual.
  */
-extern void register_png_file_type(void);
+APNG_FUNC(void, register_png_file_type, (void));
 
 /* Register an datafile type ID with Allegro, so that when an object
  * with that type ID is encountered while loading a datafile, that
  * object will be loaded as a PNG file.
  */
-extern void register_png_datafile_object(int id);
+APNG_FUNC(void, register_png_datafile_object, (int id));
 
 /* This is supposed to resemble jpgalleg_init in JPGalleg 2.0, just in
  * case you are lazier than lazy.  It contains these 3 lines of code:
@@ -65,7 +83,7 @@ extern void register_png_datafile_object(int id);
  *  register_png_file_type();
  *  return 0;
  */
-extern int loadpng_init(void);
+APNG_FUNC(int, loadpng_init, (void));
 
 
 #ifdef __cplusplus
diff --git a/addons/loadpng/regpng.c b/addons/loadpng/regpng.c
index 1681e4b..1d570ea 100644
--- a/addons/loadpng/regpng.c
+++ b/addons/loadpng/regpng.c
@@ -1,7 +1,5 @@
 /* loadpng, Allegro wrapper routines for libpng
  * by Peter Wang (tjaden@users.sf.net).
- *
- * This file is hereby placed in the public domain.
  */
 
 
diff --git a/addons/loadpng/savepng.c b/addons/loadpng/savepng.c
index e2d04f9..5274944 100644
--- a/addons/loadpng/savepng.c
+++ b/addons/loadpng/savepng.c
@@ -1,7 +1,5 @@
 /* loadpng, Allegro wrapper routines for libpng
  * by Peter Wang (tjaden@users.sf.net).
- *
- * This file is hereby placed in the public domain.
  */
 
 
diff --git a/addons/logg/logg.c b/addons/logg/logg.c
index 01ee0e8..bfd7284 100644
--- a/addons/logg/logg.c
+++ b/addons/logg/logg.c
@@ -2,7 +2,7 @@
 #include "allegro.h"
 #include "allegro/internal/aintern.h"
 
-#include "logg.h"
+#include "loggint.h"
 
 /* XXX requires testing */
 #ifdef ALLEGRO_BIG_ENDIAN
@@ -117,7 +117,7 @@ static int read_ogg_data(LOGG_Stream* s)
 	s->current_page %= OGG_PAGES_TO_BUFFER;
 
 	memset(s->buf[page], 0, logg_bufsize);
-	
+
 	while (read < logg_bufsize) {
 		int thisRead = ov_read(&s->ovf, s->buf[page]+read,
 				logg_bufsize-read,
diff --git a/addons/logg/logg.h b/addons/logg/logg.h
index 454d1c8..761c5a7 100644
--- a/addons/logg/logg.h
+++ b/addons/logg/logg.h
@@ -1,40 +1,46 @@
 #ifndef LOGG_H
 #define LOGG_H
 
+#include <allegro.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include <allegro.h>
-#include <vorbis/vorbisfile.h>
-
-#define OGG_PAGES_TO_BUFFER 2
-
-typedef struct {
-	char *buf[OGG_PAGES_TO_BUFFER];
-	int current_page;
-	int playing_page;
-	AUDIOSTREAM* audio_stream;
-	OggVorbis_File ovf;
-	int bits;
-	int stereo;
-	int freq;
-	int len;
-	char* filename;
-	int loop;
-	int volume;
-	int pan;
-} LOGG_Stream;
-
-extern SAMPLE* logg_load(const char* filename);
-extern int logg_get_buffer_size();
-extern void logg_set_buffer_size(int size);
-extern LOGG_Stream* logg_get_stream(const char* filename,
-		int volume, int pan, int loop);
-extern int logg_update_stream(LOGG_Stream* s);
-extern void logg_destroy_stream(LOGG_Stream* s);
-extern void logg_stop_stream(LOGG_Stream* s);
-extern int logg_restart_stream(LOGG_Stream* s);
+#if (defined LOGG_DYNAMIC) && (defined ALLEGRO_WINDOWS)
+    #ifdef LOGG_SRC_BUILD
+        #define _AOGG_DLL __declspec(dllexport)
+    #else
+        #define _AOGG_DLL __declspec(dllimport)
+    #endif /* ALLEGRO_GL_SRC_BUILD */
+#else
+    #define _AOGG_DLL
+#endif /* (defined LOGG_DYNAMIC) && (defined ALLEGRO_WINDOWS) */
+
+#define AOGG_VAR(type, name) extern _AOGG_DLL type name
+
+#if (defined LOGG_DYNAMIC) && (defined ALLEGRO_WINDOWS)
+    #define AOGG_FUNC(type, name, args) extern _AOGG_DLL type __cdecl name args
+#else
+    #define AOGG_FUNC(type, name, args) extern type name args
+#endif /* (defined LOGG_DYNAMIC) && (defined ALLEGRO_WINDOWS) */
+
+
+#define LOGG_VERSION     1
+#define LOGG_SUBVERSION  0
+#define LOGG_VERSIONSTR  "1.0"
+
+typedef struct LOGG_Stream LOGG_Stream;
+
+AOGG_FUNC(SAMPLE*, logg_load,(const char* filename));
+AOGG_FUNC(int, logg_get_buffer_size,(void));
+AOGG_FUNC(void, logg_set_buffer_size,(int size));
+AOGG_FUNC(LOGG_Stream*, logg_get_stream,(const char* filename,
+		int volume, int pan, int loop));
+AOGG_FUNC(int, logg_update_stream,(LOGG_Stream* s));
+AOGG_FUNC(void, logg_destroy_stream,(LOGG_Stream* s));
+AOGG_FUNC(void, logg_stop_stream,(LOGG_Stream* s));
+AOGG_FUNC(int, logg_restart_stream,(LOGG_Stream* s));
 
 #ifdef __cplusplus
 }
diff --git a/addons/logg/loggint.h b/addons/logg/loggint.h
new file mode 100644
index 0000000..3708f38
--- /dev/null
+++ b/addons/logg/loggint.h
@@ -0,0 +1,36 @@
+#ifndef LOGGINT_H
+#define LOGGINT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <allegro.h>
+#include <vorbis/vorbisfile.h>
+
+#define OGG_PAGES_TO_BUFFER 2
+
+struct LOGG_Stream {
+	char *buf[OGG_PAGES_TO_BUFFER];
+	int current_page;
+	int playing_page;
+	AUDIOSTREAM* audio_stream;
+	OggVorbis_File ovf;
+	int bits;
+	int stereo;
+	int freq;
+	int len;
+	char* filename;
+	int loop;
+	int volume;
+	int pan;
+};
+
+#include "logg.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/addons/logg/play_ogg.c b/addons/logg/play_ogg.c
index da23da8..f51a097 100644
--- a/addons/logg/play_ogg.c
+++ b/addons/logg/play_ogg.c
@@ -1,3 +1,4 @@
+#include <stdio.h>
 #include "logg.h"
 
 int main(int argc, char** argv)
diff --git a/cmake/FileList.cmake b/cmake/FileList.cmake
index 5604958..d2a0bc4 100644
--- a/cmake/FileList.cmake
+++ b/cmake/FileList.cmake
@@ -245,6 +245,7 @@ set(ALLEGRO_SRC_LINUX_FILES
         src/linux/lvgahelp.c
         src/linux/svgalib.c
         src/linux/svgalibs.s
+        src/linux/tslib.c
         src/linux/vtswitch.c
         src/misc/vbeaf.c
         src/misc/vbeafs.s
@@ -257,6 +258,7 @@ set(ALLEGRO_SRC_LINUX_FILES
 set(ALLEGRO_SRC_UNIX_FILES
         src/unix/alsa9.c
         src/unix/alsamidi.c
+        src/unix/sdl2digi.c
         src/unix/arts.c
         src/unix/sgial.c
         src/unix/jack.c
@@ -307,13 +309,11 @@ set(ALLEGRO_SRC_MACOSX_FILES
         src/macosx/hidman.m
         src/macosx/keybd.m
         src/macosx/pcpu.m
-        src/macosx/qtmidi.m
         src/macosx/quartz.m
-        src/macosx/qzfull.m
         src/macosx/qzmouse.m
-        src/macosx/qzwindow.m
-        src/macosx/soundman.m
         src/macosx/system.m
+        src/macosx/cocoagl.m
+        src/macosx/cocoashared.m
         src/unix/ufile.c
         src/unix/utimer.c
         src/unix/uptimer.c
@@ -334,6 +334,19 @@ set(ALLEGRO_SRC_PSP_FILES
         src/psp/pvram.c
         src/psp/pvtable8.c
         )
+		
+set(ALLEGRO_SRC_IOS_FILES
+        src/ios/idrivers.c
+        src/ios/isound.c
+        src/ios/ifile.c
+        src/ios/igfx.c
+        src/ios/ikey.c
+        src/ios/isystem.c
+        src/ios/imouse.c
+        src/ios/itimer.c
+        src/ios/ithreads.c
+        src/misc/colconv.c
+        )
 
 set(ALLEGRO_INCLUDE_ALLEGRO_FILES
         include/allegro/3d.h
@@ -400,6 +413,7 @@ set(ALLEGRO_INCLUDE_ALLEGRO_PLATFORM_FILES
         include/allegro/platform/aintmac.h
         include/allegro/platform/aintosx.h
         include/allegro/platform/aintpsp.h
+        include/allegro/platform/aintios.h
         include/allegro/platform/aintqnx.h
         include/allegro/platform/aintunix.h
         include/allegro/platform/aintwin.h
@@ -421,6 +435,8 @@ set(ALLEGRO_INCLUDE_ALLEGRO_PLATFORM_FILES
         # include/allegro/platform/alplatf.h.cmake
         include/allegro/platform/alpsp.h
         include/allegro/platform/alpspcfg.h
+        include/allegro/platform/alios.h
+        include/allegro/platform/alioscfg.h
         include/allegro/platform/alqnx.h
         include/allegro/platform/alqnxcfg.h
         include/allegro/platform/alucfg.h
diff --git a/cmake/FindTslib.cmake b/cmake/FindTslib.cmake
new file mode 100644
index 0000000..e7605c1
--- /dev/null
+++ b/cmake/FindTslib.cmake
@@ -0,0 +1,20 @@
+# - Find tslib
+#
+#  TSLIB_INCLUDE_DIR - where to find tslib.h.
+#  TSLIB_LIBRARIES   - List of libraries when using tslib.
+#  TSLIB_FOUND       - True if tslib found.
+
+if(TSLIB_INCLUDE_DIR)
+    # Already in cache, be silent
+    set(TSLIB_FIND_QUIETLY TRUE)
+endif(TSLIB_INCLUDE_DIR)
+find_path(TSLIB_INCLUDE_DIR tslib.h)
+find_library(TSLIB_LIBRARY NAMES ts)
+# Handle the QUIETLY and REQUIRED arguments and set TSLIB_FOUND
+# to TRUE if all listed variables are TRUE.
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(TSLIB DEFAULT_MSG
+    TSLIB_INCLUDE_DIR TSLIB_LIBRARY)
+
+mark_as_advanced(TSLIB_INCLUDE_DIR)
+mark_as_advanced(TSLIB_LIBRARY)
diff --git a/docs/src/allegro._tx b/docs/src/allegro._tx
index c16aa36..f6568b7 100644
--- a/docs/src/allegro._tx
+++ b/docs/src/allegro._tx
@@ -18,7 +18,7 @@
 @document_title=Allegro Manual
 @html_footer=Back to contents
 @rtfh=Allegro - a game programming library
-@manh="version 4.4.2" "Allegro" "Allegro manual"
+@manh="version 4.4.3 (SVN)" "Allegro" "Allegro manual"
 @mans=#include <allegro.h>
 @man_shortdesc_force1=allegro
 @man_shortdesc_force2=Allegro game programming library.
@@ -52,12 +52,12 @@
        \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
 	\/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
 				       /\____/
-				       \_/__/     Version 4.4.2
+				       \_/__/     Version 4.4.3 (SVN)
 
 
 		A game programming library.
 
-	     By Shawn Hargreaves, May 19, 2011.
+	     By Shawn Hargreaves, May 24, 2011.
 
 		See the AUTHORS file for a
 	       complete list of contributors.
diff --git a/docs/src/readme._tx b/docs/src/readme._tx
index 082ea21..aa8f677 100644
--- a/docs/src/readme._tx
+++ b/docs/src/readme._tx
@@ -31,12 +31,12 @@
        \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
 	\/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
 				       /\____/
-				       \_/__/     Version 4.4.2
+				       \_/__/     Version 4.4.3 (SVN)
 
 
 		A game programming library.
 
-	     By Shawn Hargreaves, May 19, 2011.
+	     By Shawn Hargreaves, May 24, 2011.
 
 		See the AUTHORS file for a
 	       complete list of contributors.
diff --git a/examples/exkeys.c b/examples/exkeys.c
index 9ea8485..75d3b3c 100644
--- a/examples/exkeys.c
+++ b/examples/exkeys.c
@@ -73,7 +73,7 @@ void keypress_handler(int scancode)
    color = scancode & 0x80 ? makecol(255, 255, 0) : makecol(128, 0, 0);
    rectfill(screen, x, y, x + 95, y + 8, color);
    ustrzncpy(str, sizeof(str), scancode_to_name(i), 12);
-   textprintf_ex(screen, font, x + 1, y + 1, makecol(0, 0, 0), -1, "%s", str);
+   textout_ex(screen, font, str, x + 1, y + 1, makecol(0, 0, 0), -1);
 }
 END_OF_FUNCTION(keypress_handler)
 
@@ -193,7 +193,7 @@ int main(void)
       if (key_shifts & KB_NUMLOCK_FLAG)  strcat(buf, " num");
       if (key_shifts & KB_SCROLOCK_FLAG) strcat(buf, " scrl");
       scroll();
-      textprintf_ex(screen, font, 8, SCREEN_H-16, makecol(0, 0, 0), makecol(255, 255, 255), buf);
+      textprintf_ex(screen, font, 8, SCREEN_H-16, makecol(0, 0, 0), makecol(255, 255, 255), "%s", buf);
    } while (k != 27);
 
    /* various scan codes are defined in allegro.h as KEY_* constants */
@@ -234,7 +234,7 @@ int main(void)
       if (key[KEY_8]) buf[8] = '8'; else buf[8] = ' ';
       if (key[KEY_9]) buf[9] = '9'; else buf[9] = ' ';
       buf[10] = 0;
-      textprintf_ex(screen, font, 8, SCREEN_H-16, makecol(0, 0, 0), makecol(255, 255, 255), buf);
+      textout_ex(screen, font, buf, 8, SCREEN_H-16, makecol(0, 0, 0), makecol(255, 255, 255));
       rest(1);
    } while (!keypressed() || (readkey() >> 8) != KEY_ESC);
 
diff --git a/examples/extrans2.c b/examples/extrans2.c
index 4400a11..d5c1630 100644
--- a/examples/extrans2.c
+++ b/examples/extrans2.c
@@ -211,7 +211,7 @@ int main(int argc, char **argv)
       } else {
          msg = "no flipping";
       }
-      textprintf_ex(buffer, font, 1, 1, makecol(255, 255, 255), -1, msg);
+      textout_ex(buffer, font, msg, 1, 1, makecol(255, 255, 255), -1);
 
       /* finally blit the back buffer on the screen */
       blit(buffer, screen, 0, 0, 0, 0, buffer->w, buffer->h);
diff --git a/include/allegro/base.h b/include/allegro/base.h
index 967b75c..a93736f 100644
--- a/include/allegro/base.h
+++ b/include/allegro/base.h
@@ -46,10 +46,10 @@
 
 #define ALLEGRO_VERSION          4
 #define ALLEGRO_SUB_VERSION      4
-#define ALLEGRO_WIP_VERSION      2
-#define ALLEGRO_VERSION_STR      "4.4.2"
+#define ALLEGRO_WIP_VERSION      3
+#define ALLEGRO_VERSION_STR      "4.4.3 (SVN)"
 #define ALLEGRO_DATE_STR         "2011"
-#define ALLEGRO_DATE             20110519    /* yyyymmdd */
+#define ALLEGRO_DATE             20110524    /* yyyymmdd */
 
 /*******************************************/
 /************ Some global stuff ************/
diff --git a/include/allegro/internal/alconfig.h b/include/allegro/internal/alconfig.h
index 68ec3e4..948ed64 100644
--- a/include/allegro/internal/alconfig.h
+++ b/include/allegro/internal/alconfig.h
@@ -14,7 +14,7 @@
  *
  *      See readme.txt for copyright information.
  */
-
+#define ALLEGRO_IOS
 
 /* which color depths to include? */
 #define ALLEGRO_COLOR8
@@ -62,6 +62,8 @@
       #include "allegro/platform/alucfg.h"
    #elif defined ALLEGRO_PSP
       #include "allegro/platform/alpspcfg.h"
+   #elif defined ALLEGRO_IOS
+      #include "allegro/platform/alioscfg.h"   
    #else
       #error platform not supported
    #endif
diff --git a/include/allegro/platform/aintios.h b/include/allegro/platform/aintios.h
new file mode 100644
index 0000000..4d18946
--- /dev/null
+++ b/include/allegro/platform/aintios.h
@@ -0,0 +1,31 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Internal header file for the Android Allegro library port.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef AINTIOS_H
+#define AINTIOS_H
+
+AL_FUNC(void *, _ios_create_mutex, (void));
+AL_FUNC(void, _ios_destroy_mutex, (void *handle));
+AL_FUNC(void, _ios_lock_mutex, (void *handle));
+AL_FUNC(void, _ios_unlock_mutex, (void *handle));
+
+void ios_mouse_setup(int left, int right, int top, int bottom, float scaling_x, float scaling_y);
+
+#endif
+
diff --git a/include/allegro/platform/aintosx.h b/include/allegro/platform/aintosx.h
index dcd21b2..9c9a408 100644
--- a/include/allegro/platform/aintosx.h
+++ b/include/allegro/platform/aintosx.h
@@ -42,6 +42,7 @@
 #define OSX_GFX_NONE                    0
 #define OSX_GFX_WINDOW                  1
 #define OSX_GFX_FULL                    2
+#define OSX_GFX_GL                      3
 
 #define BMP_EXTRA(bmp)                  ((BMP_EXTRA_INFO *)((bmp)->extra))
 
@@ -60,7 +61,7 @@
 
 
 
-@interface AllegroAppDelegate : NSObject
+@interface AllegroAppDelegate : NSObject <NSApplicationDelegate>
 - (BOOL)application: (NSApplication *)theApplication openFile: (NSString *)filename;
 - (void)applicationDidFinishLaunching: (NSNotification *)aNotification;
 - (void)applicationDidChangeScreenParameters: (NSNotification *)aNotification;
@@ -71,8 +72,12 @@
 
 
 @interface AllegroWindow : NSWindow
+#ifdef ENABLE_QUICKDRAW
 - (void)display;
 - (void)miniaturize: (id)sender;
+#endif
+- (BOOL)canBecomeKeyWindow;
+- (BOOL)canBecomeMainWindow;
 @end
 
 
@@ -81,11 +86,15 @@
 - (void)windowDidDeminiaturize: (NSNotification *)aNotification;
 @end
 
-
+#ifdef ENABLE_QUICKDRAW
 @interface AllegroView: NSQuickDrawView
 - (void)resetCursorRects;
 @end
+#endif
 
+// @interface AllegroCocoaGLView: NSOpenGLView
+// - (id) initWithFrame: (NSRect) frame windowed:(BOOL)windowed;
+// @end
 
 typedef void RETSIGTYPE;
 
@@ -129,7 +138,6 @@ typedef struct
 
 
 void osx_event_handler(void);
-int osx_bootstrap_ok(void);
 
 void setup_direct_shifts(void);
 void osx_init_fade_system(void);
@@ -160,6 +168,7 @@ void osx_mouse_move(int x, int y);
 HID_DEVICE_COLLECTION *osx_hid_scan(int type, HID_DEVICE_COLLECTION*);
 void osx_hid_free(HID_DEVICE_COLLECTION *);
 
+void runOnMainQueueWithoutDeadlocking(void (^block)(void));
 
 AL_VAR(NSBundle *, osx_bundle);
 AL_VAR(void *, osx_event_mutex);
@@ -173,7 +182,9 @@ AL_ARRAY(char, osx_window_title);
 AL_VAR(int, osx_window_first_expose);
 AL_VAR(int, osx_skip_events_processing);
 AL_VAR(void *, osx_skip_events_processing_mutex);
+#ifdef ENABLE_QUICKDRAW
 AL_VAR(CGDirectPaletteRef, osx_palette);
+#endif
 AL_VAR(int, osx_palette_dirty);
 AL_VAR(int, osx_mouse_warped);
 AL_VAR(int, osx_skip_mouse_move);
diff --git a/include/allegro/platform/alios.h b/include/allegro/platform/alios.h
new file mode 100644
index 0000000..1d04056
--- /dev/null
+++ b/include/allegro/platform/alios.h
@@ -0,0 +1,65 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Android specific header defines.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALIOS_H
+#define ALIOS_H
+
+#ifndef ALLEGRO_IOS
+   #error bad include
+#endif
+
+#include <stdio.h>
+
+
+/* The Android C library doesn't include stricmp */
+#define stricmp strcasecmp
+
+/* System driver */
+#define SYSTEM_IOS              AL_ID('I','O','S',' ')
+AL_VAR(SYSTEM_DRIVER, system_ios);
+
+/* Timer driver */
+#define TIMER_IOS               AL_ID('I','O','S','T')
+AL_VAR(TIMER_DRIVER, timer_ios);
+
+/* Keyboard driver */
+#define KEYBOARD_IOS            AL_ID('I','O','S','K')
+AL_VAR(KEYBOARD_DRIVER, keyboard_ios);
+
+/* Mouse drivers */
+#define MOUSE_IOS               AL_ID('I','O','S','M')
+AL_VAR(MOUSE_DRIVER, mouse_ios);
+
+/* Gfx driver */
+#define GFX_IOS                 AL_ID('I','O','S','G')
+AL_VAR(GFX_DRIVER, gfx_ios);
+
+/* Digital sound driver */
+#define DIGI_IOS                AL_ID('I','O','S','S')
+AL_VAR(DIGI_DRIVER, digi_ios);
+
+/* Joystick drivers */
+#define JOYSTICK_IOS            AL_ID('I','O','S','J')
+AL_VAR(JOYSTICK_DRIVER, joystick_ios);
+
+
+
+
+
+#endif
diff --git a/include/allegro/platform/alioscfg.h b/include/allegro/platform/alioscfg.h
new file mode 100644
index 0000000..be35c3d
--- /dev/null
+++ b/include/allegro/platform/alioscfg.h
@@ -0,0 +1,70 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Android specific header defines.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALIOSCFG_H
+#define ALIOSCFG_H
+
+#define ALLEGRO_EXTRA_HEADER "allegro/platform/alios.h"
+
+#ifndef SCAN_DEPEND
+   #include <fcntl.h>
+   #include <unistd.h>
+#endif
+
+
+#ifndef ALLEGRO_NO_MAGIC_MAIN
+   #define ALLEGRO_MAGIC_MAIN
+   #define main _mangled_main
+   #undef END_OF_MAIN
+   #define END_OF_MAIN() void *_mangled_main_address = (void *) _mangled_main;
+#else
+   #undef END_OF_MAIN
+   #define END_OF_MAIN() void *_mangled_main_address;
+#endif
+
+#include <stdio.h>
+
+#define ALLEGRO_HAVE_DIRENT_H   1
+#define ALLEGRO_HAVE_INTTYPES_H 1
+#define ALLEGRO_HAVE_STDINT_H   1
+#define ALLEGRO_HAVE_SYS_TIME_H 1
+#define ALLEGRO_HAVE_SYS_STAT_H 1
+
+#define ALLEGRO_HAVE_LIBPTHREAD 1
+
+/* Describe this platform */
+#define ALLEGRO_PLATFORM_STR  "iOS"
+#define ALLEGRO_USE_CONSTRUCTOR
+#define ALLEGRO_MULTITHREADED
+#define ALLEGRO_LITTLE_ENDIAN
+
+/* Provide implementations of missing definitions */
+#ifndef O_BINARY
+   #define O_BINARY     0
+#endif
+#define dup(X)	(fcntl(X, F_DUPFD, 0))
+
+/* Exclude ASM */
+#ifndef ALLEGRO_NO_ASM
+   #define ALLEGRO_NO_ASM
+#endif
+
+
+
+#endif
diff --git a/include/allegro/platform/alosx.h b/include/allegro/platform/alosx.h
index 20787f3..9c2a4e9 100644
--- a/include/allegro/platform/alosx.h
+++ b/include/allegro/platform/alosx.h
@@ -92,8 +92,12 @@ AL_VAR(MOUSE_DRIVER, mouse_macosx);
 /* Gfx drivers */
 #define GFX_QUARTZ_WINDOW       AL_ID('Q','Z','W','N')
 #define GFX_QUARTZ_FULLSCREEN   AL_ID('Q','Z','F','L')
+#define GFX_COCOAGL_WINDOW      AL_ID('C','O','W','N')
+#define GFX_COCOAGL_FULLSCREEN  AL_ID('C','O','F','L')
 AL_VAR(GFX_DRIVER, gfx_quartz_window);
 AL_VAR(GFX_DRIVER, gfx_quartz_full);
+AL_VAR(GFX_DRIVER, gfx_cocoagl_window);
+AL_VAR(GFX_DRIVER, gfx_cocoagl_full);
 
 /* Digital sound drivers */
 #define DIGI_CORE_AUDIO         AL_ID('D','C','A',' ')
diff --git a/include/allegro/platform/alunix.h b/include/allegro/platform/alunix.h
index c0196f5..f179854 100644
--- a/include/allegro/platform/alunix.h
+++ b/include/allegro/platform/alunix.h
@@ -69,6 +69,7 @@ AL_VAR(TIMER_DRIVER, timerdrv_unix_sigalrm);
 #define DIGI_ALSA             AL_ID('A','L','S','A')
 #define MIDI_ALSA             AL_ID('A','M','I','D')
 #define DIGI_JACK             AL_ID('J','A','C','K')
+#define DIGI_SDL2             AL_ID('S','D','L','2')
 
 
 #ifdef ALLEGRO_WITH_OSSDIGI
@@ -103,6 +104,12 @@ AL_VAR(DIGI_DRIVER, digi_sgial);
       {  DIGI_SGIAL,      &digi_sgial,          TRUE  },
 #endif /* ALLEGRO_WITH_SGIALDIGI */
 
+#ifdef ALLEGRO_WITH_SDL2ADIGI
+AL_VAR(DIGI_DRIVER, digi_sdl2);
+#define DIGI_DRIVER_SDL2                                         \
+      {  DIGI_SDL2,       &digi_sdl2,           TRUE  },
+#endif /* ALLEGRO_WITH_SDL2ADIGI */
+
 #ifdef ALLEGRO_WITH_ALSADIGI
 AL_VAR(DIGI_DRIVER, digi_alsa);
 #define DIGI_DRIVER_ALSA                                         \
@@ -178,6 +185,7 @@ AL_VAR(GFX_DRIVER, gfx_xdga2_soft);
 #define MOUSEDRV_LINUX_MS        AL_ID('M','S',' ',' ')
 #define MOUSEDRV_LINUX_IMS       AL_ID('I','M','S',' ')
 #define MOUSEDRV_LINUX_EVDEV     AL_ID('E','V',' ',' ')
+#define MOUSEDRV_LINUX_TSLIB     AL_ID('T','S','L','I')
 
 #define JOY_TYPE_LINUX_ANALOGUE  AL_ID('L','N','X','A')
 
@@ -214,6 +222,7 @@ AL_VAR(MOUSE_DRIVER, mousedrv_linux_gpmdata);
 AL_VAR(MOUSE_DRIVER, mousedrv_linux_ms);
 AL_VAR(MOUSE_DRIVER, mousedrv_linux_ims);
 AL_VAR(MOUSE_DRIVER, mousedrv_linux_evdev);
+AL_VAR(MOUSE_DRIVER, mousedrv_linux_tslib);
 
 AL_FUNC_DEPRECATED(void, split_modex_screen, (int lyne));
 
diff --git a/include/allegro/platform/alunixac.h.cmake b/include/allegro/platform/alunixac.h.cmake
index 5adb3aa..25186d0 100644
--- a/include/allegro/platform/alunixac.h.cmake
+++ b/include/allegro/platform/alunixac.h.cmake
@@ -123,6 +123,9 @@
 /* Define to enable Linux console VGA driver. */
 #cmakedefine ALLEGRO_LINUX_VGA
 
+/* Define to enable Linux console tslib mouse driver. */
+#cmakedefine ALLEGRO_LINUX_TSLIB
+
 /*---------------------------------------------------------------------------*/
 
 /* Define to the installed ALSA version. */
@@ -152,6 +155,9 @@
 /* Define if SGI AL DIGI driver is supported. */
 #cmakedefine ALLEGRO_WITH_SGIALDIGI
 
+/* Define if SDL2 DIGI driver is supported. */
+#cmakedefine ALLEGRO_WITH_SDL2DIGI
+
 /*---------------------------------------------------------------------------*/
 
 /* Define to (void *)-1, if MAP_FAILED is not defined. */
diff --git a/include/allegro/system.h b/include/allegro/system.h
index 2aa6a59..e218bff 100644
--- a/include/allegro/system.h
+++ b/include/allegro/system.h
@@ -66,6 +66,7 @@ AL_ARRAY(char, allegro_error);
 #define OSTYPE_MACOS       AL_ID('M','A','C',' ')
 #define OSTYPE_MACOSX      AL_ID('M','A','C','X')
 #define OSTYPE_PSP         AL_ID('K','P','S','P')
+#define OSTYPE_IOS         AL_ID('I','O','S',' ')
 
 AL_VAR(int, os_type);
 AL_VAR(int, os_version);
diff --git a/misc/allegro-config.in b/misc/allegro-config.in
index 84223cd..d032272 100644
--- a/misc/allegro-config.in
+++ b/misc/allegro-config.in
@@ -12,7 +12,7 @@
 #
 #  This is heavily based on a similar script from GTK.
 
-version=4.4.2
+version=4.4.3
 
 prefix=@prefix@
 exec_prefix=$prefix
diff --git a/misc/pkgreadme._tx b/misc/pkgreadme._tx
index 465f4b4..3a49284 100644
--- a/misc/pkgreadme._tx
+++ b/misc/pkgreadme._tx
@@ -12,12 +12,12 @@
        \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
 	\/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
 				       /\____/
-				       \_/__/     Version 4.4.2
+				       \_/__/     Version 4.4.3 (SVN)
 
 
 		A game programming library.
 
-	     By Shawn Hargreaves, May 19, 2011.
+	     By Shawn Hargreaves, May 24, 2011.
 
 		See the AUTHORS file for a
 	       complete list of contributors.
diff --git a/setup/setup.c b/setup/setup.c
index 894bacb..df56485 100644
--- a/setup/setup.c
+++ b/setup/setup.c
@@ -1163,7 +1163,7 @@ static void plot_joystick_state(BITMAP *bmp, int i)
 	 textprintf_ex(bmp, font, SCREEN_W/2-96, SCREEN_H/2-60+c*20, -1, -1, uconvert_ascii("%s (%d/%d)", tmp),
                     joystick_driver->name, i+1, num_joysticks);
       else
-	 textprintf_ex(bmp, font, SCREEN_W/2-96, SCREEN_H/2-60+c*20, -1, -1, joystick_driver->name);
+	 textout_ex(bmp, font, joystick_driver->name, SCREEN_W/2-96, SCREEN_H/2-60+c*20, -1, -1);
       c++;
    }
 
@@ -2879,7 +2879,7 @@ int main(void)
       alert(uconvert_ascii("Error loading " SETUP_DATA_FILE, tmp1), NULL, NULL, uconvert_ascii("OK", tmp2), NULL, 13, 0);
     #else
       set_gfx_mode(GFX_TEXT, 0, 0, 0, 0);
-      allegro_message(uconvert_ascii("Error loading " SETUP_DATA_FILE "\n", tmp1));
+      allegro_message("%s", uconvert_ascii("Error loading " SETUP_DATA_FILE "\n", tmp1));
     #endif
       return 1;
    }
diff --git a/src/config.c b/src/config.c
index 7824a09..c49d424 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,6 +1,6 @@
 /*         ______   ___    ___
- *        /\  _  \ /\_ \  /\_ \ 
- *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
  *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
  *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
  *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
@@ -47,7 +47,7 @@ typedef struct CONFIG_HOOK
    int (*intgetter)(AL_CONST char *name, int def);
    AL_CONST char *(*stringgetter)(AL_CONST char *name, AL_CONST char *def);
    void (*stringsetter)(AL_CONST char *name, AL_CONST char *value);
-   struct CONFIG_HOOK *next; 
+   struct CONFIG_HOOK *next;
 } CONFIG_HOOK;
 
 
@@ -199,7 +199,7 @@ static void config_cleanup(void)
 	 if (hook->section)
 	    _AL_FREE(hook->section);
 
-	 nexthook = hook->next; 
+	 nexthook = hook->next;
 	 _AL_FREE(hook);
 	 hook = nexthook;
       }
@@ -209,10 +209,10 @@ static void config_cleanup(void)
 
    _AL_FREE(config_argv);
    config_argv = NULL;
-   
+
    _AL_FREE(argv_buf);
    argv_buf = NULL;
-   
+
    argv_buf_size = 0;
 
    _remove_exit_func(config_cleanup);
@@ -523,7 +523,7 @@ void set_config_file(AL_CONST char *filename)
 
 
 /* set_config_data:
- *  Sets the block of data to be used for all future configuration 
+ *  Sets the block of data to be used for all future configuration
  *  operations.
  */
 void set_config_data(AL_CONST char *data, int length)
@@ -552,7 +552,7 @@ void override_config_file(AL_CONST char *filename)
 
 
 /* override_config_data:
- *  Sets the block of data that will override all future configuration 
+ *  Sets the block of data that will override all future configuration
  *  operations.
  */
 void override_config_data(AL_CONST char *data, int length)
@@ -631,8 +631,8 @@ static void prettify_section_name(AL_CONST char *in, char *out, int out_size)
 
 
 /* hook_config_section:
- *  Hooks a config section to a set of getter/setter functions. This will 
- *  override the normal table of values, and give the provider of the hooks 
+ *  Hooks a config section to a set of getter/setter functions. This will
+ *  override the normal table of values, and give the provider of the hooks
  *  complete control over that section.
  */
 void hook_config_section(AL_CONST char *section, int (*intgetter)(AL_CONST char *, int), AL_CONST char *(*stringgetter)(AL_CONST char *, AL_CONST char *), void (*stringsetter)(AL_CONST char *, AL_CONST char *))
@@ -1044,7 +1044,7 @@ static CONFIG_ENTRY *insert_variable(CONFIG *the_config, CONFIG_ENTRY *p, AL_CON
 
    if (p) {
       n->next = p->next;
-      p->next = n; 
+      p->next = n;
    }
    else {
       n->next = NULL;
@@ -1136,8 +1136,8 @@ void set_config_string(AL_CONST char *section, AL_CONST char *name, AL_CONST cha
 	       }
 
 	       /* append to the end of the section */
-	       while ((p) && (p->next) && 
-		      (((p->next->name) && (ugetc(p->next->name))) || 
+	       while ((p) && (p->next) &&
+		      (((p->next->name) && (ugetc(p->next->name))) ||
 		       ((p->next->data) && (ugetc(p->next->data)))))
 		  p = p->next;
 
@@ -1149,7 +1149,7 @@ void set_config_string(AL_CONST char *section, AL_CONST char *name, AL_CONST cha
 	       insert_variable(the_config, NULL, name, val);
 	       the_config->head->next = p;
 	    }
-	 } 
+	 }
       }
 
       the_config->dirty = TRUE;
@@ -1246,7 +1246,7 @@ void _reload_config(void)
 
 /* reload_config_texts:
  *  Reads in a block of translated system text, looking for either a
- *  user-specified file, a ??text.cfg file, or a language.dat#??TEXT_CFG 
+ *  user-specified file, a ??text.cfg file, or a language.dat#??TEXT_CFG
  *  datafile object. If new_language is not NULL, the language config
  *  variable will be set to new_language before reloading the
  *  configuration files.
@@ -1511,6 +1511,6 @@ int list_config_sections(AL_CONST char ***names)
  */
 void free_config_entries(AL_CONST char ***names)
 {
-    _AL_FREE(*names);
+    _AL_FREE(*((char***)(names)));
     *names = NULL;
 }
diff --git a/src/digmid.c b/src/digmid.c
index 04b82af..c823e84 100644
--- a/src/digmid.c
+++ b/src/digmid.c
@@ -13,6 +13,8 @@
  *      By Shawn Hargreaves, based on code by Tom Novelli.
  *      Chris Robinson added some optimizations and the digmid_set_pan method.
  *
+ *      Modified for the Adventure Game Studio runtime port by JJS.
+ *
  *      See readme.txt for copyright information.
  */
 
@@ -520,7 +522,7 @@ static int digmid_load_patches(AL_CONST char *patches, AL_CONST char *drums)
 {
    PACKFILE *f;
    char dir[1024], file[1024], buf[1024], filename[1024];
-   char todo[256][1024];
+   char* todo[256];
    char *argv[16], *p;
    char tmp[128];
    int argc;
@@ -530,9 +532,12 @@ static int digmid_load_patches(AL_CONST char *patches, AL_CONST char *drums)
    int drum_start = 0;
    int type, size;
    int i, j, c;
+   
+   for (i = 0; i < 256; i++)
+      todo[i] = (char*)malloc(1024);
 
    if (!_digmid_find_patches(dir, sizeof(dir), file, sizeof(file)))
-      return -1;
+      goto error_exit;
 
    for (i=0; i<256; i++)
       usetc(todo[i], 0);
@@ -542,7 +547,7 @@ static int digmid_load_patches(AL_CONST char *patches, AL_CONST char *drums)
 
    f = pack_fopen(buf, F_READ);
    if (!f)
-      return -1;
+      goto error_exit;
 
    while (pack_fgets(buf, sizeof(buf), f) != 0) {
       argc = parse_string(buf, argv);
@@ -584,7 +589,7 @@ static int digmid_load_patches(AL_CONST char *patches, AL_CONST char *drums)
 
 		  if (!patch[patchnum]) {
 		     /* need to load this sample */
-		     ustrzcpy(todo[patchnum], sizeof(todo[patchnum]), argv[1]);
+		     ustrzcpy(todo[patchnum], 1024, argv[1]);
 		  }
 	       }
 	    }
@@ -608,13 +613,13 @@ static int digmid_load_patches(AL_CONST char *patches, AL_CONST char *drums)
 
       f = pack_fopen(dir, F_READ_PACKED);
       if (!f)
-	 return -1;
+	 goto error_exit;
 
       if (((ugetc(dir) == '#') && (ustrlen(dir) == 1)) || (!ustrchr(dir, '#'))) {
 	 type = pack_mgetl(f);
 	 if (type != DAT_MAGIC) {
 	    pack_fclose(f);
-	    return -1;
+	    goto error_exit;
 	 }
       }
 
@@ -675,6 +680,7 @@ static int digmid_load_patches(AL_CONST char *patches, AL_CONST char *drums)
 	    pack_fseek(f, size+4);
 	 }
       }
+      pack_fclose(f);
    }
    else {
       /* read from regular disk files */
@@ -706,7 +712,16 @@ static int digmid_load_patches(AL_CONST char *patches, AL_CONST char *drums)
       }
    }
 
+   for (i = 0; i < 256; i++)
+      free(todo[i]);
+
    return 0;
+
+error_exit:
+
+    for (i = 0; i < 256; i++)
+       free(todo[i]);
+   return -1;
 }
 
diff --git a/src/ios/idrivers.c b/src/ios/idrivers.c
new file mode 100644
index 0000000..f5c9e20
--- /dev/null
+++ b/src/ios/idrivers.c
@@ -0,0 +1,75 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      List of iOS drivers.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include "allegro.h"
+
+#ifndef ALLEGRO_IOS
+#error Something is wrong with the makefile
+#endif
+
+
+_DRIVER_INFO _system_driver_list[] =
+{
+   { SYSTEM_IOS,              &system_ios,              TRUE  },
+   { SYSTEM_NONE,             &system_none,             FALSE },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _keyboard_driver_list[] =
+{
+   { KEYBOARD_IOS,            &keyboard_ios,            TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _timer_driver_list[] =
+{
+   { TIMER_IOS,               &timer_ios,               TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _mouse_driver_list[] =
+{
+   { MOUSE_IOS,               &mouse_ios,               TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _gfx_driver_list[] =
+{
+   { GFX_IOS,                 &gfx_ios,                 TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+_DRIVER_INFO _digi_driver_list[] =
+{
+   { DIGI_IOS,                &digi_ios,                TRUE  },
+   { 0,                       NULL,                     0     }
+};
+
+
+BEGIN_MIDI_DRIVER_LIST
+MIDI_DRIVER_DIGMID
+END_MIDI_DRIVER_LIST
+
+BEGIN_JOYSTICK_DRIVER_LIST
+END_JOYSTICK_DRIVER_LIST
diff --git a/src/ios/ifile.c b/src/ios/ifile.c
new file mode 100644
index 0000000..d681c90
--- /dev/null
+++ b/src/ios/ifile.c
@@ -0,0 +1,536 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Helper routines to make file.c work on the Android/iOS platform.
+ *
+ *      By Michael Bukin.
+ *
+ *      Modified for the Adventure Game Studio runtime port by JJS.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+/* libc should use 64-bit for file sizes when possible */
+#define _FILE_OFFSET_BITS 64
+
+#include <stdio.h>
+#include <string.h>
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+
+#ifdef ALLEGRO_HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+
+#ifdef ALLEGRO_HAVE_DIRENT_H
+   #include <sys/types.h>
+   #include <dirent.h>
+   #define NAMLEN(dirent) (strlen((dirent)->d_name))
+#else
+   /* Apparently all new systems have `dirent.h'. */
+   #error ALLEGRO_HAVE_DIRENT_H not defined
+#endif
+
+#ifdef ALLEGRO_HAVE_SYS_TIME_H
+  #include <sys/time.h>
+#endif
+#ifdef ALLEGRO_HAVE_TIME_H
+  #include <time.h>
+#endif
+
+#define PREFIX_I "al-unix INFO: "
+
+#define PREFIX_I "al-unix INFO: "
+
+
+/* _al_file_isok:
+ *  Helper function to check if it is safe to access a file on a floppy
+ *  drive.
+ */
+int _al_file_isok(AL_CONST char *filename)
+{
+   return TRUE;
+}
+
+
+
+/* _al_file_size_ex:
+ *  Measures the size of the specified file.
+ */
+uint64_t _al_file_size_ex(AL_CONST char *filename)
+{
+   struct stat s;
+   char tmp[1024];
+
+   if (stat(uconvert(filename, U_CURRENT, tmp, U_UTF8, sizeof(tmp)), &s) != 0) {
+      *allegro_errno = errno;
+      return 0;
+   }
+
+   return s.st_size;
+}
+
+
+
+/* _al_file_time:
+ *  Returns the timestamp of the specified file.
+ */
+time_t _al_file_time(AL_CONST char *filename)
+{
+   struct stat s;
+   char tmp[1024];
+
+   if (stat(uconvert(filename, U_CURRENT, tmp, U_UTF8, sizeof(tmp)), &s) != 0) {
+      *allegro_errno = errno;
+      return 0;
+   }
+
+   return s.st_mtime;
+}
+
+
+
+/* ff_get_filename:
+ *  When passed a completely specified file path, this returns a pointer
+ *  to the filename portion.
+ */
+static char *ff_get_filename(AL_CONST char *path)
+{
+   char *p = (char*)path + strlen(path);
+
+   while ((p > path) && (*(p - 1) != '/'))
+      p--;
+
+   return p;
+}
+
+
+
+/* ff_put_backslash:
+ *  If the last character of the filename is not a /, this routine will
+ *  concatenate a / on to it.
+ */
+static void ff_put_backslash(char *filename, int size)
+{
+   int len = strlen(filename);
+
+   if ((len > 0) && (len < (size - 1)) && (filename[len - 1] != '/')) {
+      filename[len] = '/';
+      filename[len + 1] = 0;
+   }
+}
+
+
+
+#define FF_MATCH_TRY 0
+#define FF_MATCH_ONE 1
+#define FF_MATCH_ANY 2
+
+
+struct FF_MATCH_DATA
+{
+   int type;
+   AL_CONST char *s1;
+   AL_CONST char *s2;
+};
+
+
+
+/* ff_match:
+ *  Matches two strings ('*' matches any number of characters,
+ *  '?' matches any character).
+ */
+static int ff_match(AL_CONST char *s1, AL_CONST char *s2)
+{
+   static unsigned int size = 0;
+   static struct FF_MATCH_DATA *data = NULL;
+   AL_CONST char *s1end;
+   int index, c1, c2;
+
+   /* handle NULL arguments */
+   if ((!s1) && (!s2)) {
+      if (data) {
+         _AL_FREE(data);
+         data = NULL;
+      }
+
+      return 0;
+   }
+
+   s1end = s1 + strlen(s1);
+
+   /* allocate larger working area if necessary */
+   if (data && (size < strlen(s2))) {
+      _AL_FREE(data);
+      data = NULL;
+   }
+
+   if (!data) {
+      size = strlen(s2);
+      data = _AL_MALLOC(sizeof(struct FF_MATCH_DATA) * size * 2 + 1);
+      if (!data)
+         return 0;
+   }
+
+   index = 0;
+   data[0].s1 = s1;
+   data[0].s2 = s2;
+   data[0].type = FF_MATCH_TRY;
+
+   while (index >= 0) {
+      s1 = data[index].s1;
+      s2 = data[index].s2;
+      c1 = *s1;
+      c2 = *s2;
+
+      switch (data[index].type) {
+
+      case FF_MATCH_TRY:
+         if (c2 == 0) {
+            /* pattern exhausted */
+            if (c1 == 0)
+               return 1;
+            else
+               index--;
+         }
+         else if (c1 == 0) {
+            /* string exhausted */
+            while (*s2 == '*')
+               s2++;
+            if (*s2 == 0)
+               return 1;
+            else
+               index--;
+         }
+         else if (c2 == '*') {
+            /* try to match the rest of pattern with empty string */
+            data[index++].type = FF_MATCH_ANY;
+            data[index].s1 = s1end;
+            data[index].s2 = s2 + 1;
+            data[index].type = FF_MATCH_TRY;
+         }
+         /* do case insensitive matching */
+         else if ((c2 == '?') || (c1 == c2) 
+           || ((c1 <= 90) && (c1 >= 65) && (c2 == c1 + 32)) 
+           || ((c2 <= 90) && (c2 >= 65) && (c1 == c2 + 32))) {
+            /* try to match the rest */
+            data[index++].type = FF_MATCH_ONE;
+            data[index].s1 = s1 + 1;
+            data[index].s2 = s2 + 1;
+            data[index].type = FF_MATCH_TRY;
+         }
+         else
+            index--;
+         break;
+
+      case FF_MATCH_ONE:
+         /* the rest of string did not match, try earlier */
+         index--;
+         break;
+
+      case FF_MATCH_ANY:
+         /* rest of string did not match, try add more chars to string tail */
+         if (--data[index + 1].s1 >= s1) {
+            data[index + 1].type = FF_MATCH_TRY;
+            index++;
+         }
+         else
+            index--;
+         break;
+
+      default:
+         /* this is a bird? This is a plane? No it's a bug!!! */
+         return 0;
+      }
+   }
+
+   return 0;
+}
+
+
+
+/* ff_get_attrib:
+ *  Builds up the attribute list of the file pointed to by name and s.
+ */
+static int ff_get_attrib(AL_CONST char *name, struct stat *s)
+{
+   int attrib = 0;
+/*
+   uid_t euid = geteuid();
+
+   if (euid != 0) {
+      if (s->st_uid == euid) {
+	 if ((s->st_mode & S_IWUSR) == 0)
+	    attrib |= FA_RDONLY;
+      }
+      else if (s->st_gid == getegid()) {
+	 if ((s->st_mode & S_IWGRP) == 0)
+	    attrib |= FA_RDONLY;
+      }
+      else if ((s->st_mode & S_IWOTH) == 0) {
+	 attrib |= FA_RDONLY;
+      }
+   }
+*/
+   if (S_ISDIR(s->st_mode))
+      attrib |= FA_DIREC;
+
+   if ((name[0] == '.') && ((name[1] != '.') || (name[2] != '\0')))
+      attrib |= FA_HIDDEN;
+
+   return attrib;
+}
+
+
+
+/* structure for use by the directory scanning routines */
+#define FF_MAXPATHLEN 1024
+
+struct FF_DATA
+{
+   DIR *dir;
+   char dirname[FF_MAXPATHLEN];
+   char pattern[FF_MAXPATHLEN];
+   int attrib;
+   uint64_t size;
+};
+
+
+
+/* al_findfirst:
+ *  Initiates a directory search.
+ */
+int al_findfirst(AL_CONST char *pattern, struct al_ffblk *info, int attrib)
+{
+   struct FF_DATA *ff_data;
+   struct stat s;
+   int actual_attrib;
+   char tmp[1024];
+   char *p;
+
+   /* allocate ff_data structure */
+   ff_data = _AL_MALLOC(sizeof(struct FF_DATA));
+   if (!ff_data) {
+      *allegro_errno = ENOMEM;
+      return -1;
+   }
+
+   memset(ff_data, 0, sizeof *ff_data);
+   info->ff_data = (void *) ff_data;
+
+   /* if the pattern contains no wildcard, we use stat() */
+   if (!ustrpbrk(pattern, uconvert("?*", U_ASCII, tmp, U_CURRENT, sizeof(tmp)))) {
+
+      /* start the search */
+      errno = *allegro_errno = 0;
+
+      if (stat(uconvert(pattern, U_CURRENT, tmp, U_UTF8, sizeof(tmp)), &s) == 0) {
+
+         /* get file attributes */
+         actual_attrib = ff_get_attrib(ff_get_filename(uconvert(pattern, U_CURRENT, tmp, U_UTF8, sizeof(tmp))), &s);
+         /* does it match ? */
+         if ((actual_attrib & ~attrib) == 0) {
+            info->attrib = actual_attrib;
+            info->time = s.st_mtime;
+            info->size = s.st_size; /* overflows at 2GB */
+            ff_data->size = s.st_size;
+            ustrzcpy(info->name, sizeof(info->name), get_filename(pattern));
+            return 0;
+         }
+      }
+
+       _AL_FREE(ff_data);
+      info->ff_data = NULL;
+      *allegro_errno = (errno ? errno : ENOENT);
+      return -1;
+   }
+
+   ff_data->attrib = attrib;
+
+   do_uconvert(pattern, U_CURRENT, ff_data->dirname, U_UTF8, sizeof(ff_data->dirname));
+   p = ff_get_filename(ff_data->dirname);
+   _al_sane_strncpy(ff_data->pattern, p, sizeof(ff_data->pattern));
+   if (p == ff_data->dirname)
+      _al_sane_strncpy(ff_data->dirname, "./", FF_MAXPATHLEN);
+   else
+      *p = 0;
+
+   /* nasty bodge, but gives better compatibility with DOS programs */
+   if (strcmp(ff_data->pattern, "*.*") == 0)
+      _al_sane_strncpy(ff_data->pattern, "*", FF_MAXPATHLEN);
+
+   /* start the search */
+   errno = *allegro_errno = 0;
+
+   ff_data->dir = opendir(ff_data->dirname);
+   if (!ff_data->dir) {
+      *allegro_errno = (errno ? errno : ENOENT);
+      _AL_FREE(ff_data);
+      info->ff_data = NULL;
+      return -1;
+   }
+
+   if (al_findnext(info) != 0) {
+      al_findclose(info);
+      return -1;
+   }
+
+   return 0;
+}
+
+
+
+/* al_findnext:
+ *  Retrieves the next file from a directory search.
+ */
+int al_findnext(struct al_ffblk *info)
+{
+   char tempname[FF_MAXPATHLEN];
+   char filename[FF_MAXPATHLEN];
+   int attrib;
+   struct dirent *entry;
+   struct stat s;
+   struct FF_DATA *ff_data = (struct FF_DATA *) info->ff_data;
+
+   ASSERT(ff_data);
+
+   /* if the pattern contained no wildcard */
+   if (!ff_data->dir)
+      return -1;
+
+   while (TRUE) {
+      /* read directory entry */
+      entry = readdir(ff_data->dir);
+      if (!entry) {
+         *allegro_errno = (errno ? errno : ENOENT);
+         return -1;
+      }
+
+      /* try to match file name with pattern */
+      tempname[0] = 0;
+      if (NAMLEN(entry) >= sizeof(tempname))
+         strncat(tempname, entry->d_name, sizeof(tempname) - 1);
+      else
+         strncat(tempname, entry->d_name, NAMLEN(entry));
+
+      if (ff_match(tempname, ff_data->pattern)) {
+         _al_sane_strncpy(filename, ff_data->dirname, FF_MAXPATHLEN);
+         ff_put_backslash(filename, sizeof(filename));
+         strncat(filename, tempname, sizeof(filename) - strlen(filename) - 1);
+
+         /* get file attributes */
+         if (stat(filename, &s) == 0) {
+            attrib = ff_get_attrib(tempname, &s);
+
+            /* does it match ? */
+            if ((attrib & ~ff_data->attrib) == 0)
+               break;
+         }
+         else {
+            /* evil! but no other way to avoid exiting for_each_file() */
+            *allegro_errno = 0;
+         }
+      }
+   }
+
+   info->attrib = attrib;
+   info->time = s.st_mtime;
+   info->size = s.st_size; /* overflows at 2GB */
+   ff_data->size = s.st_size;
+
+   do_uconvert(tempname, U_UTF8, info->name, U_CURRENT, sizeof(info->name));
+
+   return 0;
+}
+
+
+
+/* al_findclose:
+ *  Cleans up after a directory search.
+ */
+void al_findclose(struct al_ffblk *info)
+{
+   struct FF_DATA *ff_data = (struct FF_DATA *) info->ff_data;
+
+   if (ff_data) {
+      if (ff_data->dir) {
+         closedir(ff_data->dir);
+      }
+      _AL_FREE(ff_data);
+      info->ff_data = NULL;
+
+      /* to avoid leaking memory */
+      ff_match(NULL, NULL);
+   }
+}
+
+
+
+/* _al_getdcwd:
+ *  Returns the current directory on the specified drive.
+ */
+void _al_getdcwd(int drive, char *buf, int size)
+{
+   char tmp[1024];
+
+   if (getcwd(tmp, sizeof(tmp)))
+      do_uconvert(tmp, U_UTF8, buf, U_CURRENT, size);
+   else
+      usetc(buf, 0);
+}
+
+
+
+/* _al_ffblk_get_size:
+ *  Returns the size out of an _al_ffblk structure.
+ */
+uint64_t al_ffblk_get_size(struct al_ffblk *info)
+{
+   struct FF_DATA *ff_data;
+   ASSERT(info);
+   ff_data = (struct FF_DATA *) info->ff_data;
+   ASSERT(ff_data);
+   return ff_data->size;
+}
+
+
+
+/* _al_detect_filename_encoding:
+ *  Platform specific function to detect the filename encoding. This is called
+ *  after setting a system driver, and even if this driver is SYSTEM_NONE.
+ */
+void _al_detect_filename_encoding(void)
+{
+   char const *encoding = "unknown";
+   char *locale = getenv("LC_ALL");
+
+   if (!locale || !locale[0]) {
+      locale = getenv("LC_CTYPE");
+      if (!locale || !locale[0])
+         locale = getenv("LANG");
+   }
+
+   if (locale) {
+      if (strstr(locale, "utf8") ||
+          strstr(locale, "UTF-8") ||
+          strstr(locale, "utf-8") ||
+          strstr(locale, "UTF8")) {
+         /* Note: UTF8 is default anyway. */
+         set_filename_encoding(U_UTF8);
+         encoding = "UTF8";
+      }
+      /* TODO: detect other encodings, and support them in Allegro */
+   }
+
+   TRACE(PREFIX_I "Assumed libc encoding is %s.\n", encoding);
+}
+
+
diff --git a/src/ios/igfx.c b/src/ios/igfx.c
new file mode 100644
index 0000000..ac93e31
--- /dev/null
+++ b/src/ios/igfx.c
@@ -0,0 +1,377 @@
+/*         ______   ___    ___
+*        /\  _  \ /\_ \  /\_ \
+*        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+*         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+*          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+*           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+*            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+*                                           /\____/
+*                                           \_/__/
+*
+*      Display driver.
+*
+*      By JJS for the Adventure Game Studio runtime port.
+*      Based on the Allegro PSP port.
+*
+*      See readme.txt for copyright information.
+*/
+
+#include <../../System/Library/Frameworks/OpenGLES.framework/Headers/ES1/gl.h>
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+
+extern void ios_swap_buffers();
+extern void ios_select_buffer();
+
+
+/* Software version of some blitting methods */
+static void (*_orig_blit) (BITMAP * source, BITMAP * dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height);
+
+static BITMAP *ios_display_init(int w, int h, int v_w, int v_h, int color_depth);
+static void gfx_ios_enable_acceleration(GFX_VTABLE *vtable);
+static void ios_hw_blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height);
+
+
+void ios_render();
+void ios_initialize_opengl();
+
+
+/* Options controlled by the application */
+int psp_gfx_scaling = 1;
+int psp_gfx_smoothing = 1;
+
+
+BITMAP* displayed_video_bitmap;
+
+unsigned int ios_screen_texture = 0;
+unsigned int ios_screen_width = 320;
+unsigned int ios_screen_height = 200;
+unsigned int ios_screen_physical_width = 320;
+unsigned int ios_screen_physical_height = 200;
+unsigned int ios_screen_color_depth = 32;
+int ios_screen_texture_width = 0;
+int ios_screen_texture_height = 0;
+float ios_screen_ar = 1.0f;
+float ios_device_ar = 1.0f;
+
+volatile int ios_screen_is_dirty = 0;
+int ios_screen_initialized = 0;
+
+
+GLfloat ios_vertices[] =
+{
+   0, 0,
+   320,  0,
+   0,  200,
+   320,  200
+};
+
+GLfloat ios_texture_coordinates[] =
+{
+   0, 200.0f / 256.0f,
+   320.0f / 512.0f, 200.0f / 256.0f,
+   0, 0,
+   320.0f / 512.0f, 0
+};
+
+
+GFX_DRIVER gfx_ios =
+{
+   GFX_IOS,
+   empty_string,
+   empty_string,
+   "iOS gfx driver",
+   ios_display_init,             /* AL_METHOD(struct BITMAP *, init, (int w, int h, int v_w, int v_h, int color_depth)); */
+   NULL,                         /* AL_METHOD(void, exit, (struct BITMAP *b)); */
+   NULL,                         /* AL_METHOD(int, scroll, (int x, int y)); */
+   NULL,                         /* AL_METHOD(void, vsync, (void)); */
+   NULL,                         /* AL_METHOD(void, set_palette, (AL_CONST struct RGB *p, int from, int to, int retracesync)); */
+   NULL,                         /* AL_METHOD(int, request_scroll, (int x, int y)); */
+   NULL,                         /* AL_METHOD(int, poll_scroll, (void)); */
+   NULL,                         /* AL_METHOD(void, enable_triple_buffer, (void)); */
+   NULL,                         /* AL_METHOD(struct BITMAP *, create_video_bitmap, (int width, int height)); */
+   NULL,                         /* AL_METHOD(void, destroy_video_bitmap, (struct BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(int, show_video_bitmap, (BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(int, request_video_bitmap, (BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(BITMAP *, create_system_bitmap, (int width, int height)); */
+   NULL,                         /* AL_METHOD(void, destroy_system_bitmap, (BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(int, set_mouse_sprite, (BITMAP *sprite, int xfocus, int yfocus)); */
+   NULL,                         /* AL_METHOD(int, show_mouse, (BITMAP *bmp, int x, int y)); */
+   NULL,                         /* AL_METHOD(void, hide_mouse, (void)); */
+   NULL,                         /* AL_METHOD(void, move_mouse, (int x, int y)); */
+   NULL,                         /* AL_METHOD(void, drawing_mode, (void)); */
+   NULL,                         /* AL_METHOD(void, save_video_state, (void)); */
+   NULL,                         /* AL_METHOD(void, restore_video_state, (void)); */
+   NULL,                         /* AL_METHOD(void, set_blender_mode, (int mode, int r, int g, int b, int a)); */
+   NULL,                         /* AL_METHOD(int, fetch_mode_list, (void)); */
+   0, 0,                         /* physical (not virtual!) screen size */
+   TRUE,                         /* true if video memory is linear */
+   0,                            /* bank size, in bytes */
+   0,                            /* bank granularity, in bytes */
+   0,                            /* video memory size, in bytes */
+   0,                            /* physical address of video memory */
+   FALSE                         /* true if driver runs windowed */
+};
+
+
+extern void ios_create_screen();
+
+static BITMAP *ios_display_init(int w, int h, int v_w, int v_h, int color_depth)
+{
+   GFX_VTABLE* vtable = _get_vtable(color_depth);
+
+   /* Do the final screen blit to a 32 bit bitmap in palette mode */
+   if (color_depth == 8)
+      color_depth = 32;
+
+   ios_screen_width = w;
+   ios_screen_height = h;
+   ios_screen_color_depth = color_depth;
+
+   displayed_video_bitmap = create_bitmap_ex(color_depth, w, h);
+   gfx_ios_enable_acceleration(vtable);
+
+   ios_create_screen();
+   
+   return displayed_video_bitmap;
+}
+
+
+static void gfx_ios_enable_acceleration(GFX_VTABLE *vtable)
+{
+   /* Keep the original blitting methods */
+   _orig_blit = vtable->blit_to_self;
+
+   /* Accelerated blits. */
+   vtable->blit_from_memory = ios_hw_blit;
+   vtable->blit_to_memory = ios_hw_blit;
+   vtable->blit_from_system = ios_hw_blit;
+   vtable->blit_to_system = ios_hw_blit;
+   vtable->blit_to_self = ios_hw_blit;
+
+   _screen_vtable.blit_from_memory = ios_hw_blit;
+   _screen_vtable.blit_to_memory = ios_hw_blit;
+   _screen_vtable.blit_from_system = ios_hw_blit;
+   _screen_vtable.blit_to_system = ios_hw_blit;
+   _screen_vtable.blit_to_self = ios_hw_blit;
+
+   gfx_capabilities |= (GFX_HW_VRAM_BLIT | GFX_HW_MEM_BLIT);
+}
+
+
+/* All blitting goes through here, signal a screen update if the blit target is the screen bitmap */
+static void ios_hw_blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height)
+{
+   _orig_blit(source, dest, source_x, source_y, dest_x, dest_y, width, height);
+
+   if (dest == displayed_video_bitmap)
+      ios_render();
+}
+
+
+int ios_get_next_power_of_2(int value)
+{
+   int test = 1;
+
+   while (test < value)
+      test *= 2;
+
+   return test;
+}
+
+
+/* Create the texture that holds the screen bitmap */
+void ios_create_screen_texture(int width, int height, int color_depth)
+{
+   char* empty;
+
+   ios_screen_texture_width = ios_get_next_power_of_2(width);
+   ios_screen_texture_height = ios_get_next_power_of_2(height);
+
+   empty = (char*)malloc(ios_screen_texture_width * ios_screen_texture_height * color_depth / 8);
+   memset(empty, 0, ios_screen_texture_width * ios_screen_texture_height * color_depth / 8);
+
+   if (ios_screen_texture != 0)
+      glDeleteTextures(1, &ios_screen_texture);
+
+   glGenTextures(1, &ios_screen_texture);
+   glBindTexture(GL_TEXTURE_2D, ios_screen_texture);
+
+   if (color_depth == 16)
+      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, ios_screen_texture_width, ios_screen_texture_height, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, empty);
+   else
+      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, ios_screen_texture_width, ios_screen_texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, empty);
+
+   free(empty);
+}
+
+
+/* Set the values for the texture coord. and vertex arrays */
+void ios_create_arrays()
+{
+   if (psp_gfx_scaling == 1)
+   {
+      if (ios_device_ar <= ios_screen_ar)
+      {
+         ios_vertices[2] = ios_vertices[6] = ios_screen_physical_width - 1;
+         ios_vertices[5] = ios_vertices[7] = ios_screen_physical_width * ((float)ios_screen_height / (float)ios_screen_width);
+         
+        ios_mouse_setup(
+            0, 
+            ios_screen_physical_width - 1, 
+            (ios_screen_physical_height - ios_vertices[5]) / 2, 
+            ios_screen_physical_height - ((ios_screen_physical_height - ios_vertices[5]) / 2), 
+            (float)ios_screen_width / (float)ios_screen_physical_width, 
+            (float)ios_screen_height / ios_vertices[5]);
+      }
+      else
+      {
+         ios_vertices[2] = ios_vertices[6] = ios_screen_physical_height * ((float)ios_screen_width / (float)ios_screen_height);
+         ios_vertices[5] = ios_vertices[7] = ios_screen_physical_height - 1;
+         
+         ios_mouse_setup(
+            (ios_screen_physical_width - ios_vertices[2]) / 2,
+            ios_screen_physical_width - ((ios_screen_physical_width - ios_vertices[2]) / 2),
+            0,
+            ios_screen_physical_height - 1,
+            (float)ios_screen_width / ios_vertices[2], 
+            (float)ios_screen_height / (float)ios_screen_physical_height);
+      }
+   }
+   else if (psp_gfx_scaling == 2)
+   {
+      ios_vertices[2] = ios_vertices[6] = ios_screen_physical_width - 1;
+      ios_vertices[5] = ios_vertices[7] = ios_screen_physical_height - 1;
+      
+      ios_mouse_setup(
+         0, 
+         ios_screen_physical_width - 1, 
+         0, 
+         ios_screen_physical_width - 1, 
+         (float)ios_screen_width / (float)ios_screen_physical_width, 
+         (float)ios_screen_height / (float)ios_screen_physical_height);     
+   }   
+   else
+   {
+      ios_vertices[0] = ios_vertices[4] = ios_screen_width * (-0.5f);
+      ios_vertices[2] = ios_vertices[6] = ios_screen_width * 0.5f;
+      ios_vertices[5] = ios_vertices[7] = ios_screen_height * 0.5f;
+      ios_vertices[1] = ios_vertices[3] = ios_screen_height * (-0.5f);
+      
+      ios_mouse_setup(
+         (ios_screen_physical_width - ios_screen_width) / 2,
+         ios_screen_physical_width - ((ios_screen_physical_width - ios_screen_width) / 2),
+         (ios_screen_physical_height - ios_screen_height) / 2, 
+         ios_screen_physical_height - ((ios_screen_physical_height - ios_screen_height) / 2), 
+         1.0f,
+         1.0f);
+   }
+
+   ios_texture_coordinates[1] = ios_texture_coordinates[3] = (float)ios_screen_height / (float)ios_screen_texture_height;
+   ios_texture_coordinates[2] = ios_texture_coordinates[6] = (float)ios_screen_width / (float)ios_screen_texture_width;
+}
+
+
+/* Called from the Java app to set up the screen */
+void ios_initialize_renderer(int screen_width, int screen_height)
+{
+   ios_screen_physical_width = screen_width;
+   ios_screen_physical_height = screen_height;
+   ios_screen_initialized = 0;
+}
+
+
+void ios_initialize_opengl()
+{
+   ios_screen_ar = (float)ios_screen_width / (float)ios_screen_height;
+   ios_device_ar = (float)ios_screen_physical_width / (float)ios_screen_physical_height;
+
+   glEnable(GL_CULL_FACE);
+   glEnable(GL_TEXTURE_2D);
+   glDisable(GL_DEPTH_TEST);
+   glDisable(GL_LIGHTING);
+   glDisable(GL_BLEND);
+   glDisable(GL_SCISSOR_TEST);
+   glShadeModel(GL_FLAT);
+
+   glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+
+   glViewport(0, 0, ios_screen_physical_width, ios_screen_physical_height);
+   glScissor(0, 0, ios_screen_physical_width, ios_screen_physical_height);
+   glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+   glClear(GL_COLOR_BUFFER_BIT);
+
+   glDisableClientState(GL_COLOR_ARRAY);
+   glDisableClientState(GL_NORMAL_ARRAY);
+   glEnableClientState(GL_VERTEX_ARRAY);
+   glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+   glTexCoordPointer(2, GL_FLOAT, 0, ios_texture_coordinates);
+   glVertexPointer(2, GL_FLOAT, 0, ios_vertices);
+
+   ios_create_screen_texture(ios_screen_width, ios_screen_height, ios_screen_color_depth);
+   ios_create_arrays();
+
+   glBindTexture(GL_TEXTURE_2D, ios_screen_texture);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+   if (psp_gfx_smoothing)
+   {
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+   }
+   else
+   {
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+   }
+
+   glViewport(0, 0, ios_screen_physical_width, ios_screen_physical_height);
+
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+
+   glOrthof(0, ios_screen_physical_width - 1, 0, ios_screen_physical_height - 1, 0, 1);
+
+   glMatrixMode(GL_MODELVIEW);
+   glLoadIdentity();
+
+   if (psp_gfx_scaling == 1)
+   {
+      if (ios_device_ar <= ios_screen_ar)
+         glTranslatef(0, (ios_screen_physical_height - ios_vertices[5] - 1) / 2, 0);
+      else
+         glTranslatef((ios_screen_physical_width - ios_vertices[2] - 1) / 2, 0, 0);
+   }
+   else if (psp_gfx_scaling == 0)
+   {
+      glTranslatef(ios_screen_physical_width / 2.0f, ios_screen_physical_height / 2.0f, 0);
+   }
+}
+
+
+void ios_render()
+{
+   ios_select_buffer();
+
+   if (!ios_screen_initialized)
+   {
+      ios_initialize_opengl();
+      ios_screen_initialized = 1;
+   }
+
+   if (ios_screen_color_depth == 16)
+      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, ios_screen_width, ios_screen_height, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, displayed_video_bitmap->line[0]);
+   else
+      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, ios_screen_width, ios_screen_height, GL_RGBA, GL_UNSIGNED_BYTE, displayed_video_bitmap->line[0]);
+
+   glClear(GL_COLOR_BUFFER_BIT);
+   glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+
+   glFinish();
+
+   ios_swap_buffers();	  
+}
diff --git a/src/ios/ikey.c b/src/ios/ikey.c
new file mode 100644
index 0000000..83d47f6
--- /dev/null
+++ b/src/ios/ikey.c
@@ -0,0 +1,243 @@
+/*         ______   ___    ___
+*        /\  _  \ /\_ \  /\_ \
+*        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+*         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+*          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+*           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+*            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+*                                           /\____/
+*                                           \_/__/
+*
+*      Keyboard driver.
+*
+*      By JJS for the Adventure Game Studio runtime port.
+*      Based on the Allegro PSP port.
+*
+*      See readme.txt for copyright information.
+*/
+
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+#error Something is wrong with the makefile
+#endif
+
+
+static int ios_keyboard_init(void);
+static void ios_keyboard_exit(void);
+static void ios_keyboard_poll(void);
+static int ios_scancode_to_ascii(int scancode);
+
+extern int ios_get_last_keypress();
+
+
+static int ios_ascii_to_allegro[] = {
+   -1, // 0
+   -1, // 1
+   -1, // 2
+   -1, // 3
+   -1, // 4
+   -1, // 5
+   -1, // 6
+   -1, // 7
+   KEY_BACKSPACE, // 8
+   KEY_TAB, // 9
+   KEY_ENTER, // 10
+   -1, // 11
+   -1, // 12
+   KEY_ENTER, // 13
+   -1, // 14
+   -1, // 15
+   -1, // 16
+   -1, // 17
+   -1, // 18
+   -1, // 19
+   -1, // 20
+   -1, // 21
+   -1, // 22
+   -1, // 23
+   -1, // 24
+   -1, // 25
+   -1, // 26
+   KEY_ESC, // 27
+   -1, // 28
+   -1, // 29
+   -1, // 30
+   -1, // 31
+   KEY_SPACE, // 32
+   -1, // 33
+   KEY_QUOTE, // 34
+   -1, // 35
+   -1, // 36
+   -1, // 37
+   -1, // 38
+   -1, // 39
+   KEY_OPENBRACE, // 40
+   KEY_CLOSEBRACE, // 41
+   KEY_ASTERISK, // 42
+   KEY_PLUS_PAD, // 43
+   KEY_COMMA, // 44
+   -1, // 45
+   KEY_STOP, // 46
+   KEY_SLASH, // 47
+   KEY_0, // 48
+   KEY_1, // 49
+   KEY_2, // 50
+   KEY_3, // 51
+   KEY_4, // 52
+   KEY_5, // 53
+   KEY_6, // 54
+   KEY_7, // 55
+   KEY_8, // 56
+   KEY_9, // 57
+   KEY_COLON, // 58
+   KEY_SEMICOLON, // 59
+   -1, // 60
+   KEY_EQUALS, // 61
+   -1, // 62
+   -1, // 63
+   KEY_AT, // 64
+   KEY_A, // 65
+   KEY_B, // 66
+   KEY_C, // 67
+   KEY_D, // 68
+   KEY_E, // 69
+   KEY_F, // 70
+   KEY_G, // 71
+   KEY_H, // 72
+   KEY_I, // 73
+   KEY_J, // 74
+   KEY_K, // 75
+   KEY_L, // 76
+   KEY_M, // 77
+   KEY_N, // 78
+   KEY_O, // 79
+   KEY_P, // 80
+   KEY_Q, // 81
+   KEY_R, // 82
+   KEY_S, // 83
+   KEY_T, // 84
+   KEY_U, // 85
+   KEY_V, // 86
+   KEY_W, // 87
+   KEY_X, // 88
+   KEY_Y, // 89
+   KEY_Z, // 90
+   -1, // 91
+   KEY_BACKSLASH, // 92
+   -1, // 93
+   KEY_CIRCUMFLEX, // 94
+   -1, // 95
+   -1, // 96
+   KEY_A, // 97
+   KEY_B, // 98
+   KEY_C, // 99
+   KEY_D, // 100
+   KEY_E, // 101
+   KEY_F, // 102
+   KEY_G, // 103
+   KEY_H, // 104
+   KEY_I, // 105
+   KEY_J, // 106
+   KEY_K, // 107
+   KEY_L, // 108
+   KEY_M, // 109
+   KEY_N, // 110
+   KEY_O, // 111
+   KEY_P, // 112
+   KEY_Q, // 113
+   KEY_R, // 114
+   KEY_S, // 115
+   KEY_T, // 116
+   KEY_U, // 117
+   KEY_V, // 118
+   KEY_W, // 119
+   KEY_X, // 120
+   KEY_Y, // 121
+   KEY_Z, // 122
+   -1, // 123
+   -1, // 124
+   -1, // 125
+   KEY_TILDE, // 126
+   -1 // 127
+};
+
+
+KEYBOARD_DRIVER keyboard_ios =
+{
+   KEYBOARD_IOS,
+   empty_string,
+   empty_string,
+   "iOS keyboard",
+   FALSE,  // int autorepeat;
+   ios_keyboard_init,
+   ios_keyboard_exit,
+   ios_keyboard_poll,
+   NULL,   // AL_METHOD(void, set_leds, (int leds));
+   NULL,   // AL_METHOD(void, set_rate, (int delay, int rate));
+   NULL,   // AL_METHOD(void, wait_for_input, (void));
+   NULL,   // AL_METHOD(void, stop_waiting_for_input, (void));
+   NULL,   // AL_METHOD(int,  scancode_to_ascii, (int scancode));
+   NULL    // scancode_to_name
+};
+
+
+static int ios_last_scancode = -1;
+
+
+static int ios_ascii_to_allegro_keycode(int* ascii)
+{
+   if (*ascii > 127)
+   {
+      int result = *ascii - 0x1000;
+     *ascii = 0;
+     return result;
+   }
+   else
+      return ios_ascii_to_allegro[*ascii];
+}
+
+
+static int ios_keyboard_init(void)
+{
+   return 0;
+}
+
+
+static void ios_keyboard_exit(void)
+{
+}
+
+
+static void ios_keyboard_poll(void)
+{
+   int ascii_code;
+   int allegro_keycode;
+   
+   // Hold the key down till the next keyboard poll
+   if (ios_last_scancode != -1)
+   {
+      _handle_key_release(ios_last_scancode); 
+      ios_last_scancode = -1;
+   }   
+   
+   ascii_code = ios_get_last_keypress();
+   if (ascii_code < 1)
+      return;
+   
+   allegro_keycode = ios_ascii_to_allegro_keycode(&ascii_code);
+   
+   if (allegro_keycode == -1)
+      return;
+
+   // Replace LF with CR
+   if (ascii_code == 10)
+      ascii_code = 13;
+
+   _handle_key_press(ascii_code, allegro_keycode);
+
+   ios_last_scancode = allegro_keycode;
+}
diff --git a/src/ios/imouse.c b/src/ios/imouse.c
new file mode 100644
index 0000000..1212e74
--- /dev/null
+++ b/src/ios/imouse.c
@@ -0,0 +1,212 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Mouse driver.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#include "math.h"
+
+#ifndef ALLEGRO_IOS
+#error something is wrong with the makefile
+#endif
+
+static int  ios_mouse_init(void);
+static void ios_mouse_exit(void);
+static void ios_mouse_position(int, int);
+static void ios_mouse_set_range(int, int, int, int);
+static void ios_mouse_get_mickeys(int *, int *);
+static void ios_mouse_poll(void);
+
+extern void ios_poll_mouse_relative(int* x, int* y);
+extern void ios_poll_mouse_absolute(int* x, int* y);
+extern int ios_poll_mouse_buttons();
+
+static int mouse_minx = 0;
+static int mouse_miny = 0;
+static int mouse_maxx = 320;
+static int mouse_maxy = 200;
+int ios_left_mouse_stay = 0;
+int ios_right_mouse_stay = 0;
+int ios_mouse_last_x = 0;
+int ios_mouse_last_y = 0;
+int ios_mouse_clip_left = 0;
+int ios_mouse_clip_right = 479;
+int ios_mouse_clip_top = 0;
+int ios_mouse_clip_bottom = 319;
+float ios_mouse_scaling_x = 1.0f;
+float ios_mouse_scaling_y = 1.0f;
+
+int config_mouse_control_mode = 0; // 0 = direct, 1 = relative
+
+
+MOUSE_DRIVER mouse_ios =
+{
+   MOUSE_IOS,
+   empty_string,
+   empty_string,
+   "iOS mouse",
+   ios_mouse_init,
+   ios_mouse_exit,
+   ios_mouse_poll,       // AL_METHOD(void, poll, (void));
+   NULL,                 // AL_METHOD(void, timer_poll, (void));
+   ios_mouse_position,
+   ios_mouse_set_range,
+   NULL,       // AL_METHOD(void, set_speed, (int xspeed, int yspeed));
+   ios_mouse_get_mickeys,
+   NULL,       // AL_METHOD(int,  analyse_data, (AL_CONST char *buffer, int size));
+   NULL,       // AL_METHOD(void,  enable_hardware_cursor, (AL_CONST int mode));
+   NULL        // AL_METHOD(int,  select_system_cursor, (AL_CONST int cursor));
+};
+
+
+
+static int ios_mouse_init(void)
+{
+   return 3; //Num of buttons.
+}
+
+
+void ios_clip_mouse(int* x, int* y)
+{
+   if (*x < ios_mouse_clip_left)
+      *x = ios_mouse_clip_left;
+
+   if (*y < ios_mouse_clip_top)
+      *y = ios_mouse_clip_top;
+
+   if (*x > ios_mouse_clip_right)
+      *x = ios_mouse_clip_right;
+
+   if (*y > ios_mouse_clip_bottom)
+      *y = ios_mouse_clip_bottom;
+
+   *x -= ios_mouse_clip_left;
+   *y -= ios_mouse_clip_top;
+}
+
+
+void ios_scale_mouse(int* x, int* y)
+{
+   *x = (float)*x * ios_mouse_scaling_x;
+   *y = (float)*y * ios_mouse_scaling_y;
+}
+
+
+void ios_mouse_setup(int left, int right, int top, int bottom, float scaling_x, float scaling_y)
+{
+   ios_mouse_clip_left = left;
+   ios_mouse_clip_right = right;
+   ios_mouse_clip_top = top;
+   ios_mouse_clip_bottom = bottom;
+   ios_mouse_scaling_x = scaling_x;
+   ios_mouse_scaling_y = scaling_y;
+}
+
+
+static void ios_mouse_poll(void)
+{
+
+   int new_x;
+   int new_y;
+   int new_click = ios_poll_mouse_buttons();
+
+   if (config_mouse_control_mode == 1)
+   {
+      ios_poll_mouse_relative(&new_x, &new_y);
+      ios_scale_mouse(&new_x, &new_y);
+   
+      new_x += _mouse_x;
+      new_y += _mouse_y;
+   }
+   else
+   {
+      ios_poll_mouse_absolute(&new_x, &new_y);
+      ios_clip_mouse(&new_x, &new_y);	
+      ios_scale_mouse(&new_x, &new_y);
+   }
+   
+   if (new_x < mouse_minx)
+      new_x = mouse_minx;
+
+   if (new_y < mouse_miny)
+      new_y = mouse_miny;
+
+   if (new_x > mouse_maxx)
+      new_x = mouse_maxx;
+
+   if (new_y > mouse_maxy)
+      new_y = mouse_maxy;
+
+   _mouse_x = new_x;
+   _mouse_y = new_y;
+   
+   
+   if (new_click == 1)
+      ios_left_mouse_stay = 10;
+   else if (new_click == 2)
+      ios_right_mouse_stay = 10;
+   else if (new_click == 10)
+      ios_left_mouse_stay = 10 * 1000 * 1000;
+   
+   if (ios_left_mouse_stay > 0)
+      ios_left_mouse_stay--;
+
+   if (ios_right_mouse_stay > 0)
+      ios_right_mouse_stay--;
+
+   if (ios_left_mouse_stay > 0)
+      _mouse_b = 1;
+   else if (ios_right_mouse_stay > 0)
+      _mouse_b = 2;
+   else
+      _mouse_b = 0;
+}
+
+
+
+
+static void ios_mouse_position(int x, int y)
+{
+   _mouse_x = x;
+   _mouse_y = y;
+}
+
+
+
+static void ios_mouse_set_range(int x1, int y1, int x2, int y2)
+{
+   mouse_minx = x1;
+   mouse_miny = y1;
+   mouse_maxx = x2;
+   mouse_maxy = y2;
+}
+
+
+
+static void ios_mouse_get_mickeys(int *mickeyx, int *mickeyy)
+{
+
+}
+
+
+
+static void ios_mouse_exit(void)
+{
+}
+
diff --git a/src/ios/isound.c b/src/ios/isound.c
new file mode 100644
index 0000000..b1ca27b
--- /dev/null
+++ b/src/ios/isound.c
@@ -0,0 +1,223 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Audio driver.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#include <AudioToolbox/AudioToolbox.h>
+#include <pthread.h>
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+#error something is wrong with the makefile
+#endif
+
+
+#define SAMPLES_PER_BUFFER 1024
+
+
+static int digi_ios_detect(int);
+static int digi_ios_init(int, int);
+static void digi_ios_exit(int);
+static void ios_start_audio_queue();
+
+static short sound_buffer[2][SAMPLES_PER_BUFFER][2];
+int curr_buffer = 0;
+
+AudioQueueRef ios_queue;
+AudioQueueBufferRef ios_queue_buffer[3];
+AudioStreamBasicDescription ios_data_format;
+
+volatile int ios_audio_playing = 0;
+volatile int ios_audio_interrupted = 0;
+volatile int ios_audio_must_restart = 0;
+
+DIGI_DRIVER digi_ios =
+{
+   DIGI_IOS,
+   empty_string,
+   empty_string,
+   "iOS digital sound driver",
+   0,
+   0,
+   MIXER_MAX_SFX,
+   MIXER_DEF_SFX,
+
+   digi_ios_detect,
+   digi_ios_init,
+   digi_ios_exit,
+   NULL,
+   NULL,
+
+   NULL,
+   NULL,
+   NULL,
+   _mixer_init_voice,
+   _mixer_release_voice,
+   _mixer_start_voice,
+   _mixer_stop_voice,
+   _mixer_loop_voice,
+
+   _mixer_get_position,
+   _mixer_set_position,
+
+   _mixer_get_volume,
+   _mixer_set_volume,
+   _mixer_ramp_volume,
+   _mixer_stop_volume_ramp,
+
+   _mixer_get_frequency,
+   _mixer_set_frequency,
+   _mixer_sweep_frequency,
+   _mixer_stop_frequency_sweep,
+
+   _mixer_get_pan,
+   _mixer_set_pan,
+   _mixer_sweep_pan,
+   _mixer_stop_pan_sweep,
+
+   _mixer_set_echo,
+   _mixer_set_tremolo,
+   _mixer_set_vibrato,
+   0, 0,
+   0,
+   0,
+   0,
+   0,
+   0,
+   0
+};
+
+
+
+static int digi_ios_detect(int input)
+{
+   return TRUE;
+}
+
+
+void ios_resume_sound()
+{
+   if (ios_audio_must_restart)
+   {
+      ios_audio_must_restart = 0;
+      AudioQueueStart(ios_queue, NULL);
+   }
+}
+
+
+void digi_ios_interruption_handler(void *inUserData, UInt32 interruptionState) 
+{
+   if (interruptionState == kAudioSessionBeginInterruption) 
+   {
+      ios_audio_interrupted = 1;
+      AudioQueueStop(ios_queue, 1);
+   }
+   else if (interruptionState == kAudioSessionEndInterruption)
+   {
+      ios_audio_interrupted = 0;
+      ios_start_audio_queue();
+   }
+}
+
+
+void digi_ios_audio_callback(void* inUserData, AudioQueueRef inAQ, AudioQueueBufferRef inBuffer)
+{
+   void* bufptr = &sound_buffer[curr_buffer];
+   
+   if (!ios_audio_playing || ios_audio_interrupted)
+      return;
+
+   /* Asks to the Allegro mixer to fill the buffer */
+   _mix_some_samples((uintptr_t)bufptr, 0, TRUE);
+
+   /* Send mixed buffer to sound card */
+   memcpy(inBuffer->mAudioData, bufptr, SAMPLES_PER_BUFFER * 2 * 2);
+   inBuffer->mAudioDataByteSize = SAMPLES_PER_BUFFER * 2 * 2;   
+   AudioQueueEnqueueBuffer(ios_queue, inBuffer, 0, NULL);
+
+   curr_buffer = !curr_buffer;
+}
+
+
+extern volatile int is_in_foreground;
+
+static void ios_start_audio_queue()
+{
+   int i;
+   
+   AudioQueueNewOutput(&ios_data_format, digi_ios_audio_callback, NULL, NULL, NULL, 0, &ios_queue);
+
+   for (i = 0; i < 3; i++)
+   {
+      AudioQueueAllocateBuffer(ios_queue, SAMPLES_PER_BUFFER * 2 * 2, &ios_queue_buffer[i]);
+      memset(ios_queue_buffer[i]->mAudioData, 0, SAMPLES_PER_BUFFER * 2 * 2);
+      ios_queue_buffer[i]->mAudioDataByteSize = SAMPLES_PER_BUFFER * 2 * 2;
+      AudioQueueEnqueueBuffer(ios_queue, ios_queue_buffer[i], 0, NULL);
+   }
+
+   ios_audio_playing = 1;
+
+   /* Error -12985 happens if the app is currently in the background.
+      The most likely cause for this is that an interrupting event
+      (like a phone call or an alarm) occured and the user dismissed it
+      by pressing the power button. This calls the audio resume callback
+      but the app is already in the background. Set a flag so that audio
+      gets restarted after the app has come to the foreground. */
+   if (AudioQueueStart(ios_queue, NULL) == -12985)
+   {
+      ios_audio_must_restart = 1;
+   }
+}
+
+
+static int digi_ios_init(int input, int voices)
+{
+   _sound_bits = 16;
+   _sound_stereo = TRUE;
+   _sound_freq = 44100;  
+  
+   digi_ios.voices = voices;
+
+   ios_data_format.mSampleRate = _sound_freq;    
+   ios_data_format.mFormatID = kAudioFormatLinearPCM;
+   ios_data_format.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked;
+   ios_data_format.mBytesPerPacket = 4;
+   ios_data_format.mFramesPerPacket = 1;
+   ios_data_format.mBytesPerFrame = 4;
+   ios_data_format.mChannelsPerFrame = (_sound_stereo ? 2 : 1);
+   ios_data_format.mBitsPerChannel = _sound_bits;
+   ios_data_format.mReserved = 0;
+
+   if (_mixer_init(SAMPLES_PER_BUFFER * 2, _sound_freq, _sound_stereo, (_sound_bits == 16), &digi_ios.voices))
+      return -1;
+
+#ifndef __i386__
+   AudioSessionInitialize(NULL, NULL, digi_ios_interruption_handler, NULL);
+#endif
+
+   ios_start_audio_queue();
+
+   return 0;
+}
+
+
+static void digi_ios_exit(int input)
+{
+   ios_audio_playing = 0;
+   AudioQueueStop(ios_queue, 0);
+}
diff --git a/src/ios/isystem.c b/src/ios/isystem.c
new file mode 100644
index 0000000..7eb7b93
--- /dev/null
+++ b/src/ios/isystem.c
@@ -0,0 +1,102 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      System driver.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Allegro PSP port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+   #error something is wrong with the makefile
+#endif
+
+
+static int ios_sys_init(void);
+static void ios_sys_exit(void);
+static void ios_get_gfx_safe_mode(int *driver, struct GFX_MODE *mode);
+
+
+
+SYSTEM_DRIVER system_ios =
+{
+   SYSTEM_IOS,
+   empty_string,
+   empty_string,
+   "iOS Device",
+   ios_sys_init,
+   ios_sys_exit,
+   NULL,  /* AL_METHOD(void, get_executable_name, (char *output, int size)); */
+   NULL,  /* AL_METHOD(int, find_resource, (char *dest, AL_CONST char *resource, int size)); */
+   NULL,  /* AL_METHOD(void, set_window_title, (AL_CONST char *name)); */
+   NULL,  /* AL_METHOD(int, set_close_button_callback, (AL_METHOD(void, proc, (void)))); */
+   NULL,  /* AL_METHOD(void, message, (AL_CONST char *msg)); */
+   NULL,  /* AL_METHOD(void, assert, (AL_CONST char *msg)); */
+   NULL,  /* AL_METHOD(void, save_console_state, (void)); */
+   NULL,  /* AL_METHOD(void, restore_console_state, (void)); */
+   NULL,  /* AL_METHOD(struct BITMAP *, create_bitmap, (int color_depth, int width, int height)); */
+   NULL,  /* AL_METHOD(void, created_bitmap, (struct BITMAP *bmp)); */
+   NULL,  /* AL_METHOD(struct BITMAP *, create_sub_bitmap, (struct BITMAP *parent, int x, int y, int width, int height)); */
+   NULL,  /* AL_METHOD(void, created_sub_bitmap, (struct BITMAP *bmp, struct BITMAP *parent)); */
+   NULL,  /* AL_METHOD(int, destroy_bitmap, (struct BITMAP *bitmap)); */
+   NULL,  /* AL_METHOD(void, read_hardware_palette, (void)); */
+   NULL,  /* AL_METHOD(void, set_palette_range, (AL_CONST struct RGB *p, int from, int to, int retracesync)); */
+   NULL,  /* AL_METHOD(struct GFX_VTABLE *, get_vtable, (int color_depth)); */
+   NULL,  /* AL_METHOD(int, set_display_switch_mode, (int mode)); */
+   NULL,  /* AL_METHOD(void, display_switch_lock, (int lock, int foreground)); */
+   NULL,  /* AL_METHOD(int, desktop_color_depth, (void)); */
+   NULL,  /* AL_METHOD(int, get_desktop_resolution, (int *width, int *height)); */
+   ios_get_gfx_safe_mode,  /*AL_METHOD(void, get_gfx_safe_mode, (int *driver, struct GFX_MODE *mode));*/
+   NULL,  /* AL_METHOD(void, yield_timeslice, (void)); */
+   _ios_create_mutex,  /* AL_METHOD(void *, create_mutex, (void)); */
+   _ios_destroy_mutex,  /* AL_METHOD(void, destroy_mutex, (void *handle)); */
+   _ios_lock_mutex,  /* AL_METHOD(void, lock_mutex, (void *handle)); */
+   _ios_unlock_mutex,  /* AL_METHOD(void, unlock_mutex, (void *handle)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, gfx_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, digi_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, midi_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, keyboard_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, mouse_drivers, (void)); */
+   NULL,  /* AL_METHOD(_DRIVER_INFO *, joystick_drivers, (void)); */
+   NULL   /* AL_METHOD(_DRIVER_INFO *, timer_drivers, (void)); */
+};
+
+
+
+static int ios_sys_init(void)
+{
+   os_type = OSTYPE_IOS;
+
+   return 0;
+}
+
+
+
+static void ios_sys_exit(void)
+{
+   
+}
+
+
+
+static void ios_get_gfx_safe_mode(int *driver, struct GFX_MODE *mode)
+{
+   *driver = GFX_IOS;
+   mode->width = 320;
+   mode->height = 200;
+   mode->bpp = 16;
+}
diff --git a/src/ios/ithreads.c b/src/ios/ithreads.c
new file mode 100644
index 0000000..35a9bc9
--- /dev/null
+++ b/src/ios/ithreads.c
@@ -0,0 +1,113 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Asynchronous event processing with pthreads.
+ *
+ *      By George Foot and Peter Wang.
+ *
+ *      Synchronization functions added by Eric Botcazou.
+ *
+ *      Copied in part for the AGS iOS port.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+   #error something is wrong with the makefile
+#endif
+
+#include <pthread.h>
+#include <signal.h>
+#include <sys/time.h>
+#include <limits.h>
+
+
+/* custom mutex that supports nested locking */
+struct my_mutex {
+   int lock_count;                /* level of nested locking     */
+   pthread_t owner;               /* thread which owns the mutex */
+   pthread_mutex_t actual_mutex;  /* underlying mutex object     */
+};
+
+
+
+/* _ios_create_mutex:
+ *  Creates a mutex and returns a pointer to it.
+ */
+void *_ios_create_mutex(void)
+{
+   struct my_mutex *mx;
+
+   mx = _AL_MALLOC(sizeof(struct my_mutex));
+   if (!mx) {
+      *allegro_errno = ENOMEM;
+      return NULL;
+   }
+
+   mx->lock_count = 0;
+   mx->owner = (pthread_t) 0;
+
+   pthread_mutex_init(&mx->actual_mutex, NULL);
+
+   return (void *)mx;
+}
+
+
+
+/* _ios_destroy_mutex:
+ *  Destroys a mutex.
+ */
+void _ios_destroy_mutex(void *handle)
+{
+   struct my_mutex *mx = (struct my_mutex *)handle;
+
+   pthread_mutex_destroy(&mx->actual_mutex);
+
+   _AL_FREE(mx);
+}
+
+
+
+/* _ios_lock_mutex:
+ *  Locks a mutex.
+ */
+void _ios_lock_mutex(void *handle)
+{
+   struct my_mutex *mx = (struct my_mutex *)handle;
+
+   if (mx->owner != pthread_self()) {
+      pthread_mutex_lock(&mx->actual_mutex);
+      mx->owner = pthread_self();      
+   }
+
+   mx->lock_count++;
+}
+
+
+
+/* _ios_unlock_mutex:
+ *  Unlocks a mutex.
+ */
+void _ios_unlock_mutex(void *handle)
+{
+   struct my_mutex *mx = (struct my_mutex *)handle;
+
+   mx->lock_count--;
+
+   if (mx->lock_count == 0) {
+      mx->owner = (pthread_t) 0;
+      pthread_mutex_unlock(&mx->actual_mutex);
+   }
+}
diff --git a/src/ios/itimer.c b/src/ios/itimer.c
new file mode 100644
index 0000000..b1c561e
--- /dev/null
+++ b/src/ios/itimer.c
@@ -0,0 +1,232 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Timer driver.
+ *
+ *      By JJS for the Adventure Game Studio runtime port.
+ *      Based on the Unix timer driver by Peter Wang.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintios.h"
+
+#ifndef ALLEGRO_IOS
+   #error something is wrong with the makefile
+#endif
+
+#include <pthread.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+
+/* See hack later.  */
+#ifdef ALLEGRO_LINUX_VGA
+#ifdef ALLEGRO_HAVE_SYS_IO_H
+/* iopl() exists in here instead of unistd.h in glibc */
+#include <sys/io.h>
+#endif
+#include "allegro/platform/aintlnx.h"
+#endif
+
+
+#define TIMER_TO_USEC(x)  ((long)((x) / 1.193181))
+#define USEC_TO_TIMER(x)  ((long)((x) * (TIMERS_PER_SECOND / 1000000.)))
+
+
+static int ptimer_init(void);
+static void ptimer_exit(void);
+void _unix_rest(unsigned int ms, void (*callback) (void));
+
+
+TIMER_DRIVER timer_ios =
+{
+   TIMER_IOS,
+   empty_string,
+   empty_string,
+   "Unix pthreads timers",
+   ptimer_init,
+   ptimer_exit,
+   NULL, NULL,		/* install_int, remove_int */
+   NULL, NULL,		/* install_param_int, remove_param_int */
+   NULL, NULL,		/* can_simulate_retrace, simulate_retrace */
+   _unix_rest		/* rest */
+};
+
+
+
+static pthread_t thread;
+static int thread_alive;
+
+
+
+
+
+/* ptimer_thread_func:
+ *  The timer thread.
+ */
+static void *ptimer_thread_func(void *unused)
+{
+   struct timeval old_time;
+   struct timeval new_time;
+   struct timeval delay;
+   long interval = 0x8000;
+
+
+   gettimeofday(&old_time, 0);
+
+   while (thread_alive) {
+      /* `select' is more accurate than `usleep' on my system.  */
+      delay.tv_sec = interval / TIMERS_PER_SECOND;
+      delay.tv_usec = TIMER_TO_USEC(interval) % 1000000L;
+      select(0, NULL, NULL, NULL, &delay);
+
+      /* Calculate actual time elapsed.  */
+      gettimeofday(&new_time, 0);
+      interval = USEC_TO_TIMER((new_time.tv_sec - old_time.tv_sec) * 1000000L
+			       + (new_time.tv_usec - old_time.tv_usec));
+      old_time = new_time;
+
+      /* If the app is sent to the background, a long time will have elapsed on return. */
+      if ((interval < 0) || (interval > 0x8000 * 100))
+         interval = 0x8000;
+
+      /* Handle a tick.  */
+      interval = _handle_timer_tick(interval);
+   }
+
+   return NULL;
+}
+
+
+
+/* ptimer_init:
+ *  Installs the timer thread.
+ */
+static int ptimer_init(void)
+{
+   thread_alive = 1;
+
+   if (pthread_create(&thread, NULL, ptimer_thread_func, NULL) != 0) {
+   thread_alive = 0;
+      return -1;
+   }
+   return 0;
+}
+
+
+
+/* ptimer_exit:
+ *  Shuts down the timer thread.
+ */
+static void ptimer_exit(void)
+{
+   if (thread_alive) {
+      thread_alive = 0;
+      pthread_join(thread, NULL);
+   }
+}
+
+
+
+
+
+
+
+
+/* timeval_subtract:
+ *  Subtract the `struct timeval' values X and Y, storing the result
+ *  in RESULT.  Return 1 if the difference is negative, otherwise 0.
+ *
+ *  This function is from the glibc manual.  It handles weird platforms
+ *  where the tv_sec is unsigned.
+ */
+static int timeval_subtract(struct timeval *result,
+			    struct timeval *x,
+			    struct timeval *y)
+{
+   /* Perform the carry for the later subtraction by updating Y. */
+   if (x->tv_usec < y->tv_usec) {
+      int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
+      y->tv_usec -= 1000000 * nsec;
+      y->tv_sec += nsec;
+   }
+   if (x->tv_usec - y->tv_usec > 1000000) {
+      int nsec = (x->tv_usec - y->tv_usec) / 1000000;
+      y->tv_usec += 1000000 * nsec;
+      y->tv_sec -= nsec;
+   }
+
+   /* Compute the time remaining to wait.
+    * `tv_usec' is certainly positive. */
+   result->tv_sec = x->tv_sec - y->tv_sec;
+   result->tv_usec = x->tv_usec - y->tv_usec;
+   /* Return 1 if result is negative. */
+   return x->tv_sec < y->tv_sec;
+}
+
+
+
+void _unix_rest(unsigned int ms, void (*callback) (void))
+{
+   if (callback) {
+      struct timeval tv, tv_end;
+
+      gettimeofday (&tv_end, NULL);
+      tv_end.tv_usec += ms * 1000;
+      tv_end.tv_sec  += (tv_end.tv_usec / 1000000L);
+      tv_end.tv_usec %= 1000000L;
+
+      while (1)
+      {
+         (*callback)();
+         gettimeofday (&tv, NULL);
+         if (tv.tv_sec > tv_end.tv_sec)
+            break;
+         if (tv.tv_sec == tv_end.tv_sec && tv.tv_usec >= tv_end.tv_usec)
+             break;
+      }
+   }
+   else {
+      struct timeval now;
+      struct timeval end;
+      struct timeval delay;
+      int result;
+
+      gettimeofday(&now, NULL);
+
+      end = now;
+      end.tv_usec += ms * 1000;
+      end.tv_sec  += (end.tv_usec / 1000000L);
+      end.tv_usec %= 1000000L;
+
+      while (1) {
+	 if (timeval_subtract(&delay, &end, &now))
+	    break;
+
+#ifdef ALLEGRO_MACOSX
+	 result = usleep((delay.tv_sec * 1000000L) + delay.tv_usec);
+#else
+	 result = select(0, NULL, NULL, NULL, &delay);
+#endif
+	 if (result == 0)	/* ok */
+	    break;
+	 if ((result != -1) || (errno != EINTR))
+	    break;
+
+	 /* interrupted */
+	 gettimeofday(&now, NULL);
+      }
+   }
+}
diff --git a/src/keyboard.c b/src/keyboard.c
index 56f60da..c433268 100644
--- a/src/keyboard.c
+++ b/src/keyboard.c
@@ -1,6 +1,6 @@
-/*         ______   ___    ___ 
- *        /\  _  \ /\_ \  /\_ \ 
- *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
  *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
  *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
  *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
@@ -20,10 +20,19 @@
 #include "allegro/internal/aintern.h"
 
 
+/* thedmd: Keyboard driver hit GCC bug 43614.
+ *         Details: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43614
+ */
+#if defined(NDEBUG) && defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ == 4)
+#define GCC_440_BUG_WORKAROUND  __attribute__ ((optimize("O1")))
+#else
+#define GCC_440_BUG_WORKAROUND
+#endif
+
 
 KEYBOARD_DRIVER *keyboard_driver = NULL;     /* the active driver */
 
-int _keyboard_installed = FALSE; 
+int _keyboard_installed = FALSE;
 
 static int keyboard_polled = FALSE;          /* are we in polling mode? */
 
@@ -252,7 +261,7 @@ int keypressed(void)
  *  Returns the next character code from the keyboard buffer. If the
  *  buffer is empty, it waits until a key is pressed. The low byte of
  *  the return value contains the ASCII code of the key, and the high
- *  byte the scan code. 
+ *  byte the scan code.
  */
 int readkey(void)
 {
@@ -388,12 +397,12 @@ END_OF_STATIC_FUNCTION(repeat_timer);
 
 
 /* install_keyboard_hooks:
- *  You should only use this function if you *aren't* using the rest of the 
- *  keyboard handler. It can be called in the place of install_keyboard(), 
- *  and lets you provide callback routines to detect and read keypresses, 
- *  which will be used by the main keypressed() and readkey() functions. This 
- *  can be useful if you want to use Allegro's GUI code with a custom 
- *  keyboard handler, as it provides a way for the GUI to access keyboard 
+ *  You should only use this function if you *aren't* using the rest of the
+ *  keyboard handler. It can be called in the place of install_keyboard(),
+ *  and lets you provide callback routines to detect and read keypresses,
+ *  which will be used by the main keypressed() and readkey() functions. This
+ *  can be useful if you want to use Allegro's GUI code with a custom
+ *  keyboard handler, as it provides a way for the GUI to access keyboard
  *  input from your own code.
  */
 void install_keyboard_hooks(int (*keypressed)(void), int (*readkey)(void))
@@ -464,7 +473,7 @@ void _handle_key_press(int keycode, int scancode)
    }
 
    /* autorepeat? */
-   if ((keyboard_driver->autorepeat) && (repeat_delay) && 
+   if ((keyboard_driver->autorepeat) && (repeat_delay) &&
        (keycode >= 0) && (scancode > 0) && (scancode != KEY_PAUSE) &&
        ((keycode != repeat_key) || (scancode != repeat_scan))) {
       repeat_key = keycode;
@@ -519,6 +528,7 @@ END_OF_FUNCTION(_handle_key_release);
  *  switch into polling mode and will no longer operate asynchronously
  *  even if the driver actually does support that.
  */
+int poll_keyboard(void) GCC_440_BUG_WORKAROUND;
 int poll_keyboard(void)
 {
    int i;
@@ -549,7 +559,7 @@ int poll_keyboard(void)
       }
 
       while (_key_buffer.start != _key_buffer.end) {
-	 add_key(&key_buffer, _key_buffer.key[_key_buffer.start], 
+	 add_key(&key_buffer, _key_buffer.key[_key_buffer.start],
 			      _key_buffer.scancode[_key_buffer.start]);
 
 	 if (_key_buffer.start < KEY_BUFFER_SIZE-1)
@@ -617,7 +627,7 @@ AL_CONST char *scancode_to_name(int scancode)
 
 
 /* install_keyboard:
- *  Installs Allegro's keyboard handler. You must call this before using 
+ *  Installs Allegro's keyboard handler. You must call this before using
  *  any of the keyboard input routines. Returns -1 on failure.
  */
 int install_keyboard(void)
@@ -690,7 +700,7 @@ int install_keyboard(void)
 
 
 /* remove_keyboard:
- *  Removes the keyboard handler. You don't normally need to call this, 
+ *  Removes the keyboard handler. You don't normally need to call this,
  *  because allegro_exit() will do it for you.
  */
 void remove_keyboard(void)
diff --git a/src/linux/ljoy.c b/src/linux/ljoy.c
index 283b809..75c49bb 100644
--- a/src/linux/ljoy.c
+++ b/src/linux/ljoy.c
@@ -53,9 +53,6 @@ static int joy_init(void)
    AL_CONST char *device_name = NULL;
    char tmp[128], tmp1[128], tmp2[128];
    unsigned int raw_version;
-   struct {
-      unsigned char build, minor, major;
-   } version;
    char num_axes, num_buttons;
    int throttle;
    int i, s, a, b;
@@ -93,14 +90,10 @@ static int joy_init(void)
 
       if (ioctl(joy_fd[i], JSIOCGVERSION, &raw_version) < 0) {
          /* NOTE: IOCTL fails if the joystick API is version 0.x */
-         uszprintf(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Your Linux joystick API is version 0.x which is unsupported."));
+         ustrzcpy(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Your Linux joystick API is version 0.x which is unsupported."));
          return -1; 
       }
       
-      version.major = (raw_version & 0xFF0000) >> 16;
-      version.minor = (raw_version & 0xFF00) >> 8;
-      version.build = (raw_version & 0xFF);
-      
       ioctl(joy_fd[i], JSIOCGAXES, &num_axes);
       ioctl(joy_fd[i], JSIOCGBUTTONS, &num_buttons);
 
diff --git a/src/linux/lmsedrv.c b/src/linux/lmsedrv.c
index ce2bfbf..0cc7bb8 100644
--- a/src/linux/lmsedrv.c
+++ b/src/linux/lmsedrv.c
@@ -31,7 +31,9 @@ _DRIVER_INFO _linux_mouse_driver_list[] =
 #ifdef ALLEGRO_HAVE_LINUX_INPUT_H
    {  MOUSEDRV_LINUX_EVDEV,    &mousedrv_linux_evdev,    TRUE  },
 #endif
+#ifdef ALLEGRO_LINUX_TSLIB
+   {  MOUSEDRV_LINUX_TSLIB,    &mousedrv_linux_tslib,    TRUE  },
+#endif
    {  MOUSEDRV_NONE,           &mousedrv_none,           TRUE  },
    {  0,                       NULL,                     0     }
 };
-
diff --git a/src/linux/tslib.c b/src/linux/tslib.c
new file mode 100644
index 0000000..35b7631
--- /dev/null
+++ b/src/linux/tslib.c
@@ -0,0 +1,169 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Linux console mouse driver for tslib (touch screens).
+ *
+ *      By Tobi Vollebregt.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+
+#ifdef ALLEGRO_LINUX_TSLIB
+
+#include <stdio.h>
+#include <tslib.h>
+
+#define PREFIX_I                "al-tslib INFO: "
+#define PREFIX_W                "al-tslib WARNING: "
+#define PREFIX_E                "al-tslib ERROR: "
+
+#define ARRAY_SIZE(a)           ((int)sizeof((a)) / (int)sizeof((a)[0]))
+
+static struct tsdev *ts;
+
+static int mouse_minx = 0;          /* mouse range */
+static int mouse_miny = 0;
+static int mouse_maxx = 319;
+static int mouse_maxy = 199;
+
+
+static int al_tslib_error_callback(const char *fmt, va_list ap)
+{
+   char tmp[ALLEGRO_ERROR_SIZE];
+   int ret;
+
+   ret = vsnprintf(tmp, sizeof(tmp), fmt, ap);
+
+   TRACE(PREFIX_E "%s\n", tmp);
+   uconvert(tmp, U_ASCII, allegro_error, U_CURRENT, ALLEGRO_ERROR_SIZE);
+
+   return ret;
+}
+
+static int mouse_init(void)
+{
+   char tmp1[128], tmp2[128];
+   AL_CONST char *udevice;
+
+   /* Set custom error handling function */
+   ts_error_fn = al_tslib_error_callback;
+
+   /* Find the device filename */
+   udevice = get_config_string(uconvert_ascii("mouse", tmp1),
+                               uconvert_ascii("mouse_device", tmp2),
+                               NULL);
+
+   /* Open mouse device.  Devices are cool. */
+   if (udevice) {
+      TRACE(PREFIX_I "Trying %s device\n", udevice);
+      ts = ts_open(uconvert_toascii(udevice, tmp1), TRUE);
+      if (ts == NULL) {
+         uszprintf(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Unable to open %s: %s"),
+                   udevice, ustrerror(errno));
+         return -1;
+      }
+   }
+   else {
+      /* If not specified in the config file, try several /dev/input/event<n>
+       * devices. */
+      const char *device_name[] = { "/dev/input/event0",
+                                    "/dev/input/event1",
+                                    "/dev/input/event2",
+                                    "/dev/input/event3",
+                                    NULL };
+      int i;
+
+      TRACE(PREFIX_I "Trying /dev/input/event[0-3] devices\n");
+
+      for (i=0; device_name[i]; i++) {
+         ts = ts_open(device_name[i], TRUE);
+         if (ts != NULL)
+	    break;
+      }
+
+      if (!device_name[i]) {
+	 uszprintf(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Unable to open a touch screen device: %s"),
+		   ustrerror(errno));
+	 return -1;
+      }
+   }
+
+   if (ts_config(ts)) {
+      uszprintf(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Unable to configure touch screen device: %s"),
+                ustrerror(errno));
+      ts_close(ts);
+      return -1;
+   }
+
+   return 0;
+}
+
+static void mouse_exit(void)
+{
+   if (ts) {
+      ts_close(ts);
+      ts = NULL;
+   }
+}
+
+static void mouse_position(int x, int y)
+{
+   _mouse_x = CLAMP(mouse_minx, x, mouse_maxx);
+   _mouse_y = CLAMP(mouse_miny, y, mouse_maxy);
+}
+
+static void mouse_set_range(int x1, int y1, int x2, int y2)
+{
+   mouse_minx = x1;
+   mouse_miny = y1;
+   mouse_maxx = x2;
+   mouse_maxy = y2;
+
+   mouse_position(_mouse_x, _mouse_y);
+}
+
+static void mouse_timer_poll(void)
+{
+   struct ts_sample samp[16];
+   int n;
+
+   n = ts_read(ts, samp, ARRAY_SIZE(samp));
+   if (n > 0) {
+      --n;
+      mouse_position(samp[n].x, samp[n].y);
+      _mouse_b = samp[n].pressure > 0;
+      /*TRACE(PREFIX_I "Read %d samples.  x:%3d y:%3d pressure:%3d\n",
+	      n + 1, samp[n].x, samp[n].y, samp[n].pressure);*/
+   }
+}
+
+MOUSE_DRIVER mousedrv_linux_tslib =
+{
+   MOUSEDRV_LINUX_TSLIB,
+   empty_string,
+   empty_string,
+   "Linux tslib touch screen",
+   mouse_init,
+   mouse_exit,
+   NULL, /* poll */
+   mouse_timer_poll,
+   mouse_position,
+   mouse_set_range,
+   NULL, /* set_speed */
+   NULL, /* get_mickeys */
+   NULL, /* analyse_data */
+   NULL, /* enable_hardware_cursor */
+   NULL, /* select_system_cursor */
+};
+
+#endif
diff --git a/src/macosx/cocoagl.m b/src/macosx/cocoagl.m
new file mode 100644
index 0000000..556bb4f
--- /dev/null
+++ b/src/macosx/cocoagl.m
@@ -0,0 +1,573 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      MacOS X quartz windowed gfx driver
+ *
+ *      By Angelo Mottola.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintosx.h"
+
+#ifndef ALLEGRO_MACOSX
+   #error something is wrong with the makefile
+#endif
+
+#include <OpenGL/gl.h>
+
+#define PREFIX_I "al-osxgl INFO: "
+#define PREFIX_W "al-osxgl WARNING: "
+
+@class AllegroCocoaGLView;
+
+static BITMAP *osx_gl_window_init(int, int, int, int, int);
+static void osx_gl_window_exit(BITMAP *);
+
+static BITMAP *osx_gl_full_init(int, int, int, int, int);
+static void osx_gl_full_exit(BITMAP *);
+
+static void gfx_cocoa_enable_acceleration(GFX_VTABLE *vtable);
+
+GFX_DRIVER gfx_cocoagl_window =
+{
+   GFX_COCOAGL_WINDOW,
+   empty_string,
+   empty_string,
+   "Cocoa GL window",
+   osx_gl_window_init,
+   osx_gl_window_exit,
+   NULL,                         /* AL_METHOD(int, scroll, (int x, int y)); */
+   NULL,                         /* AL_METHOD(void, vsync, (void)); */
+   NULL,                         /* AL_METHOD(void, set_palette, (AL_CONST struct RGB *p, int from, int to, int retracesync)); */
+   NULL,                         /* AL_METHOD(int, request_scroll, (int x, int y)); */
+   NULL,                         /* AL_METHOD(int, poll_scroll, (void)); */
+   NULL,                         /* AL_METHOD(void, enable_triple_buffer, (void)); */
+   NULL,                         /* AL_METHOD(struct BITMAP *, create_video_bitmap, (int width, int height)); */
+   NULL,                         /* AL_METHOD(void, destroy_video_bitmap, (struct BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(int, show_video_bitmap, (BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(int, request_video_bitmap, (BITMAP *bitmap)); */
+   NULL,                         /* AL_METHOD(BITMAP *, create_system_bitmap, (int width, int height)); */
+   NULL,                         /* AL_METHOD(void, destroy_system_bitmap, (BITMAP *bitmap)); */
+   osx_mouse_set_sprite,         /* AL_METHOD(int, set_mouse_sprite, (BITMAP *sprite, int xfocus, int yfocus)); */
+   osx_mouse_show,               /* AL_METHOD(int, show_mouse, (BITMAP *bmp, int x, int y)); */
+   osx_mouse_hide,               /* AL_METHOD(void, hide_mouse, (void)); */
+   osx_mouse_move,               /* AL_METHOD(void, move_mouse, (int x, int y)); */
+   NULL,                         /* AL_METHOD(void, drawing_mode, (void)); */
+   NULL,                         /* AL_METHOD(void, save_video_state, (void)); */
+   NULL,                         /* AL_METHOD(void, restore_video_state, (void)); */
+   NULL,                         /* AL_METHOD(void, set_blender_mode, (int mode, int r, int g, int b, int a)); */
+   NULL,                         /* AL_METHOD(int, fetch_mode_list, (void)); */
+   0, 0,                         /* physical (not virtual!) screen size */
+   TRUE,                         /* true if video memory is linear */
+   0,                            /* bank size, in bytes */
+   0,                            /* bank granularity, in bytes */
+   0,                            /* video memory size, in bytes */
+   0,                            /* physical address of video memory */
+   TRUE                          /* true if driver runs windowed */
+};
+
+GFX_DRIVER gfx_cocoagl_full =
+{
+    GFX_COCOAGL_FULLSCREEN,
+    empty_string,
+    empty_string,
+    "Cocoa GL full",
+    osx_gl_full_init,
+    osx_gl_full_exit,
+    NULL,                         /* AL_METHOD(int, scroll, (int x, int y)); */
+    NULL,                         /* AL_METHOD(void, vsync, (void)); */
+    NULL,                         /* AL_METHOD(void, set_palette, (AL_CONST struct RGB *p, int from, int to, int retracesync)); */
+    NULL,                         /* AL_METHOD(int, request_scroll, (int x, int y)); */
+    NULL,                         /* AL_METHOD(int, poll_scroll, (void)); */
+    NULL,                         /* AL_METHOD(void, enable_triple_buffer, (void)); */
+    NULL,                         /* AL_METHOD(struct BITMAP *, create_video_bitmap, (int width, int height)); */
+    NULL,                         /* AL_METHOD(void, destroy_video_bitmap, (struct BITMAP *bitmap)); */
+    NULL,                         /* AL_METHOD(int, show_video_bitmap, (BITMAP *bitmap)); */
+    NULL,                         /* AL_METHOD(int, request_video_bitmap, (BITMAP *bitmap)); */
+    NULL,                         /* AL_METHOD(BITMAP *, create_system_bitmap, (int width, int height)); */
+    NULL,                         /* AL_METHOD(void, destroy_system_bitmap, (BITMAP *bitmap)); */
+    osx_mouse_set_sprite,         /* AL_METHOD(int, set_mouse_sprite, (BITMAP *sprite, int xfocus, int yfocus)); */
+    osx_mouse_show,               /* AL_METHOD(int, show_mouse, (BITMAP *bmp, int x, int y)); */
+    osx_mouse_hide,               /* AL_METHOD(void, hide_mouse, (void)); */
+    osx_mouse_move,               /* AL_METHOD(void, move_mouse, (int x, int y)); */
+    NULL,                         /* AL_METHOD(void, drawing_mode, (void)); */
+    NULL,                         /* AL_METHOD(void, save_video_state, (void)); */
+    NULL,                         /* AL_METHOD(void, restore_video_state, (void)); */
+    NULL,                         /* AL_METHOD(void, set_blender_mode, (int mode, int r, int g, int b, int a)); */
+    NULL,                         /* AL_METHOD(int, fetch_mode_list, (void)); */
+    0, 0,                         /* physical (not virtual!) screen size */
+    TRUE,                         /* true if video memory is linear */
+    0,                            /* bank size, in bytes */
+    0,                            /* bank granularity, in bytes */
+    0,                            /* video memory size, in bytes */
+    0,                            /* physical address of video memory */
+    FALSE                         /* true if driver runs windowed */
+};
+
+
+
+static BITMAP *osx_gl_real_init(int w, int h, int v_w, int v_h, int color_depth, GFX_DRIVER * driver)
+{
+    bool is_fullscreen = driver->windowed == FALSE;
+
+    GFX_VTABLE* vtable = _get_vtable(color_depth);
+
+    if (color_depth != 32 && color_depth != 16)
+        ustrzcpy(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Unsupported color depth"));
+
+    BITMAP *displayed_video_bitmap = create_bitmap_ex(color_depth, w, h);
+
+    driver->w = w;
+    driver->h = h;
+    driver->vid_mem = w * h * BYTES_PER_PIXEL(color_depth);
+
+    gfx_cocoa_enable_acceleration(vtable);
+
+    // Run on the main thread because we're manipulating the API
+    runOnMainQueueWithoutDeadlocking(^{
+
+    // setup REAL window
+    NSRect rect = NSMakeRect(0, 0, w, h);
+    NSUInteger styleMask = NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask | NSResizableWindowMask;
+    //if (is_fullscreen) {
+      //  rect = [[NSScreen mainScreen] frame];
+      //  styleMask = NSBorderlessWindowMask;
+    //}
+
+    osx_window = [[AllegroWindow alloc] initWithContentRect: rect
+                                                  styleMask: styleMask
+                                                    backing: NSBackingStoreBuffered
+                                                      defer: NO
+                                                     screen:[NSScreen mainScreen]];
+
+    AllegroWindowDelegate *osx_window_delegate = [[AllegroWindowDelegate alloc] init];
+    [osx_window setDelegate: (id<NSWindowDelegate>)osx_window_delegate];
+    [osx_window setOneShot: YES];
+    [osx_window setAcceptsMouseMovedEvents: YES];
+    [osx_window setViewsNeedDisplay: NO];
+    [osx_window setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
+
+    [osx_window center];
+    if (is_fullscreen) {
+        [osx_window  toggleFullScreen:nil];
+//        [osx_window setLevel:NSMainMenuWindowLevel+1];
+//        [osx_window setOpaque:YES];
+//        [osx_window setHidesOnDeactivate:YES];
+    }
+
+    set_window_title(osx_window_title);
+
+    AllegroCocoaGLView *osx_gl_view = [[[AllegroCocoaGLView alloc] initWithFrame: rect windowed:driver->windowed backing: displayed_video_bitmap] autorelease];
+    [osx_window setContentView: osx_gl_view];
+
+    [osx_window makeKeyAndOrderFront: nil];
+
+    });
+
+    osx_keyboard_focused(FALSE, 0);
+    clear_keybuf();
+
+    osx_skip_mouse_move = TRUE;
+    osx_window_first_expose = TRUE;
+    osx_gfx_mode = OSX_GFX_GL;
+
+    return displayed_video_bitmap;
+}
+
+static BITMAP *osx_gl_window_init(int w, int h, int v_w, int v_h, int color_depth)
+{
+    BITMAP *bmp = osx_gl_real_init(w, h, v_w, v_h, color_depth, &gfx_cocoagl_window);
+    return bmp;
+}
+
+
+static BITMAP *osx_gl_full_init(int w, int h, int v_w, int v_h, int color_depth)
+{
+    BITMAP *bmp = osx_gl_real_init(w, h, v_w, v_h, color_depth, &gfx_cocoagl_full);
+
+    _unix_lock_mutex(osx_skip_events_processing_mutex);
+    osx_skip_events_processing = FALSE;
+    _unix_unlock_mutex(osx_skip_events_processing_mutex);
+
+    return bmp;
+}
+
+static void osx_gl_window_exit(BITMAP *bmp)
+{
+    runOnMainQueueWithoutDeadlocking(^{
+        if (osx_window) {
+            [[osx_window contentView] stopRendering];
+            
+            [osx_window close];
+            osx_window = nil;
+        }
+    });
+
+    osx_gfx_mode = OSX_GFX_NONE;
+}
+
+
+static void osx_gl_full_exit(BITMAP *bmp)
+{
+    _unix_lock_mutex(osx_skip_events_processing_mutex);
+    osx_skip_events_processing = TRUE;
+    _unix_unlock_mutex(osx_skip_events_processing_mutex);
+
+    osx_gl_window_exit(bmp);
+}
+
+static void gfx_cocoa_enable_acceleration(GFX_VTABLE *vtable)
+{
+    gfx_capabilities |= (GFX_HW_VRAM_BLIT | GFX_HW_MEM_BLIT);
+}
+
+
+/* NSOpenGLPixelFormat *init_pixel_format(int windowed)
+ *
+ * Generate a pixel format. First try and get all the 'suggested' settings.
+ * If this fails, just get the 'required' settings,
+ * or nil if no format can be found
+ */
+#define MAX_ATTRIBUTES           64
+
+static NSOpenGLPixelFormat *init_pixel_format(int windowed)
+{
+    NSOpenGLPixelFormatAttribute attribs[MAX_ATTRIBUTES], *attrib;
+   attrib=attribs;
+    *attrib++ = kCGLPFAOpenGLProfile;
+    *attrib++ = kCGLOGLPVersion_Legacy;
+    *attrib++ = NSOpenGLPFADoubleBuffer;
+    *attrib++ = NSOpenGLPFAColorSize;
+    *attrib++ = 16;
+
+//   if (!windowed) {
+//      *attrib++ = NSOpenGLPFAScreenMask;
+//      *attrib++ = CGDisplayIDToOpenGLDisplayMask(kCGDirectMainDisplay);
+//   }
+   *attrib = 0;
+
+   NSOpenGLPixelFormat *pf = [[NSOpenGLPixelFormat alloc] initWithAttributes: attribs];
+
+   return pf;
+}
+
+static CVReturn display_link_render_callback(CVDisplayLinkRef displayLink, const CVTimeStamp* now, const CVTimeStamp* outputTime, CVOptionFlags flagsIn, CVOptionFlags* flagsOut, void* displayLinkContext)
+{
+    @autoreleasepool {
+        [((AllegroCocoaGLView *)displayLinkContext) render];
+    }
+    return kCVReturnSuccess;
+}
+
+struct MyVertex {
+    GLfloat x;
+    GLfloat y;
+};
+
+@interface AllegroCocoaGLView: NSOpenGLView {
+
+    BITMAP *_displayed_video_bitmap;
+
+    int _gameWidth;
+    int _gameHeight;
+    int _colourDepth;
+
+    GLuint _osx_screen_texture;
+    int _osx_screen_color_depth;
+    GLuint _osx_texture_format;
+    GLenum _osx_texture_storage;
+
+    CVDisplayLinkRef _displayLink;
+
+    struct MyVertex _gl_VertexCoords[4];
+    struct MyVertex _gl_TextureCoords[4];
+}
+
+@end
+
+@implementation AllegroCocoaGLView
+
+// Used to override default cursor
+- (void)resetCursorRects
+{
+    [super resetCursorRects];
+    [self addCursorRect: [self visibleRect]
+                 cursor: osx_cursor];
+    [osx_cursor setOnMouseEntered: YES];
+}
+
+/* Custom view: when created, select a suitable pixel format */
+- (id) initWithFrame: (NSRect) frame windowed:(BOOL)windowed backing: (BITMAP *) bmp
+{
+    _displayed_video_bitmap = bmp;
+    _gameWidth = bmp->w;
+    _gameHeight = bmp->h;
+    _colourDepth = bmp->vtable->color_depth;
+
+   NSOpenGLPixelFormat* pf = init_pixel_format(windowed);
+   if (pf) {
+        self = [super initWithFrame:frame pixelFormat: pf];
+        [pf release];
+        return self;
+   }
+   else
+   {
+        TRACE(PREFIX_W "Unable to find suitable pixel format\n");
+   }
+
+   return nil;
+}
+
+- (void)renewGState
+{   
+    // Called whenever graphics state updated (such as window resize)
+    
+    // OpenGL rendering is not synchronous with other rendering on the OSX.
+    // Therefore, call disableScreenUpdatesUntilFlush so the window server
+    // doesn't render non-OpenGL content in the window asynchronously from
+    // OpenGL content, which could cause flickering.  (non-OpenGL content
+    // includes the title bar and drawing done by the app with other APIs)
+    [[self window] disableScreenUpdatesUntilFlush];
+
+    [super renewGState];
+}
+
+- (void)stopRendering
+{
+    CVDisplayLinkStop(_displayLink);
+
+    CVDisplayLinkRelease(_displayLink);
+    _displayLink = nil;
+    
+    CGLLockContext([[self openGLContext] CGLContextObj]);
+    @try {
+        [[self openGLContext] makeCurrentContext];
+        
+        _displayed_video_bitmap = nil;
+        
+        [self delete_osx_screen_texture];
+        
+        [NSOpenGLContext clearCurrentContext];
+    } @finally {
+        CGLUnlockContext([[self openGLContext] CGLContextObj]);
+    }
+
+    if (osx_mouse_tracking_rect != -1) {
+      [self removeTrackingRect: osx_mouse_tracking_rect];
+    }
+}
+
+- (void)dealloc
+{
+    [self stopRendering];
+
+    [super dealloc];
+
+}
+
+- (void)delete_osx_screen_texture
+{
+    if (_osx_screen_texture != 0)
+    {
+        glDeleteTextures(1, &_osx_screen_texture);
+        _osx_screen_texture = 0;
+    }  
+}
+
+- (void) prepareOpenGL 
+{
+    [super prepareOpenGL];
+    
+    /* Print out OpenGL version info */
+    TRACE(PREFIX_I "OpenGL Version: %s\n", (AL_CONST char*)glGetString(GL_VERSION));
+    TRACE(PREFIX_I "Vendor: %s\n", (AL_CONST char*)glGetString(GL_VENDOR));
+    TRACE(PREFIX_I "Renderer: %s\n", (AL_CONST char*)glGetString(GL_RENDERER));
+
+    // enable vsync
+    GLint swapInt = 1;
+    [[self openGLContext] setValues:&swapInt forParameter:NSOpenGLCPSwapInterval];
+
+    [self osx_gl_setup];
+
+    [[self openGLContext] flushBuffer];
+
+    CVDisplayLinkCreateWithActiveCGDisplays(&_displayLink);
+
+    CVDisplayLinkSetOutputCallback(_displayLink, &display_link_render_callback, self);
+
+    // Select the display link most optimal for the current renderer of an OpenGL context
+    CGLContextObj cglContext = [[self openGLContext] CGLContextObj];
+    CGLPixelFormatObj cglPixelFormat = [[self pixelFormat] CGLPixelFormatObj];
+    CVDisplayLinkSetCurrentCGDisplayFromOpenGLContext(_displayLink, cglContext, cglPixelFormat);
+
+    CVDisplayLinkStart(_displayLink);
+}
+
+- (void) osx_gl_setup
+{
+    [self osx_gl_setup_arrays];
+
+    glDisable(GL_DITHER);
+    glDisable(GL_ALPHA_TEST);
+    glDisable(GL_BLEND);
+    glDisable(GL_STENCIL_TEST);
+    glDisable(GL_FOG);
+    glDisable(GL_TEXTURE_2D);
+    glDisable(GL_DEPTH_TEST);
+    glPixelZoom(1.0,1.0);
+
+    glShadeModel(GL_FLAT);
+    glEnable(GL_TEXTURE_RECTANGLE_ARB);
+
+    [self reshape];
+
+    glEnableClientState(GL_VERTEX_ARRAY);
+    glPolygonMode(GL_FRONT_AND_BACK, GL_LINES);
+    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+    glVertexPointer(2, GL_FLOAT, sizeof(struct MyVertex), (const GLvoid*)&_gl_VertexCoords[0]);
+    glTexCoordPointer(2, GL_FLOAT, sizeof(struct MyVertex), (const GLvoid*)&_gl_TextureCoords[0]);
+
+    glActiveTexture(GL_TEXTURE0);
+    [self osx_gl_create_screen_texture];
+}
+
+- (void) osx_gl_create_screen_texture
+{
+    [self delete_osx_screen_texture];
+
+    switch (_colourDepth) {
+        case 16:
+            _osx_texture_format = GL_RGB;
+            _osx_texture_storage = GL_UNSIGNED_SHORT_5_6_5;
+            break;
+        case 32:
+            _osx_texture_format = GL_RGBA;
+            _osx_texture_storage = GL_UNSIGNED_BYTE;
+            break;
+        default:
+            TRACE(PREFIX_I "unsupported color depth\n");
+            return;
+    }
+
+    glGenTextures(1, &_osx_screen_texture);
+    glBindTexture(GL_TEXTURE_RECTANGLE_ARB, _osx_screen_texture);
+    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glTexImage2D(GL_TEXTURE_RECTANGLE_EXT, 0, GL_RGB, _gameWidth, _gameHeight, 0, _osx_texture_format, _osx_texture_storage, NULL);
+}
+
+- (void) osx_gl_setup_arrays
+{
+    _gl_VertexCoords[0].x = 0;
+    _gl_VertexCoords[0].y = 0;
+    _gl_TextureCoords[0].x = 0;
+    _gl_TextureCoords[0].y = _gameHeight;
+
+    _gl_VertexCoords[1].x = _gameWidth;
+    _gl_VertexCoords[1].y = 0;
+    _gl_TextureCoords[1].x = _gameWidth;
+    _gl_TextureCoords[1].y = _gameHeight;
+
+    _gl_VertexCoords[2].x = 0;
+    _gl_VertexCoords[2].y = _gameHeight;
+    _gl_TextureCoords[2].x = 0;
+    _gl_TextureCoords[2].y = 0;
+
+    _gl_VertexCoords[3].x = _gameWidth;
+    _gl_VertexCoords[3].y = _gameHeight;
+    _gl_TextureCoords[3].x = _gameWidth;
+    _gl_TextureCoords[3].y = 0;
+}
+
+- (void) drawRect: (NSRect) theRect
+{
+    [self render];
+}
+
+
+- (void) render
+{
+    [[self openGLContext] makeCurrentContext];
+    
+    CGLLockContext([[self openGLContext] CGLContextObj]);
+    @try {
+ 
+        if (!_displayed_video_bitmap) { return; }
+        
+        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+        glTexSubImage2D(GL_TEXTURE_RECTANGLE_EXT, 0,
+                        0, 0, _gameWidth, _gameHeight,
+                        _osx_texture_format, _osx_texture_storage, _displayed_video_bitmap->line[0]);
+
+        glClear(GL_COLOR_BUFFER_BIT);
+        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+
+        CGLFlushDrawable([[self openGLContext] CGLContextObj]);
+    } @finally {
+        CGLUnlockContext([[self openGLContext] CGLContextObj]);
+    }
+}
+
+
+- (void) reshape
+{
+    [super reshape];
+
+    if (osx_mouse_tracking_rect != -1) {
+      [self removeTrackingRect: osx_mouse_tracking_rect];
+    }
+
+    osx_mouse_tracking_rect = [self addTrackingRect: self.frame
+                                                     owner: NSApp
+                                                  userData: nil
+                                              assumeInside: YES];
+
+    CGLLockContext([[self openGLContext] CGLContextObj]);
+    @try {
+        [[self openGLContext] makeCurrentContext];
+
+        NSSize myNSWindowSize = [ self frame ].size;
+
+        float aspect = ((float)_gameWidth) / _gameHeight;
+
+        /* if 320x200 or 640x400 - non square pixels */
+        if ( (_gameWidth == 320) && (_gameHeight == 200) ||
+            (_gameWidth == 640) && (_gameHeight == 400) ) {
+            aspect = 1.333333333333;
+        }
+
+        NSRect viewport = NSMakeRect((myNSWindowSize.width - myNSWindowSize.height * aspect)/2, 0, myNSWindowSize.height * aspect, myNSWindowSize.height);
+        glViewport(viewport.origin.x, viewport.origin.y, viewport.size.width, viewport.size.height);
+        glScissor(viewport.origin.x, viewport.origin.y, viewport.size.width, viewport.size.height);
+        
+        glMatrixMode(GL_PROJECTION);
+        glLoadIdentity();
+        glOrtho(0, _gameWidth - 1, 0, _gameHeight - 1, 0, 1);
+
+        glMatrixMode(GL_MODELVIEW);
+        glLoadIdentity();
+
+        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    } @finally {
+        CGLUnlockContext([[self openGLContext] CGLContextObj]);
+    }
+
+}
+
+@end
diff --git a/src/macosx/cocoashared.m b/src/macosx/cocoashared.m
new file mode 100644
index 0000000..27d8c9e
--- /dev/null
+++ b/src/macosx/cocoashared.m
@@ -0,0 +1,124 @@
+#include "allegro.h"
+#include "allegro/internal/aintern.h"
+#include "allegro/platform/aintosx.h"
+
+#ifndef ALLEGRO_MACOSX
+#error something is wrong with the makefile
+#endif
+
+// Quickdraw specific
+#ifdef ENABLE_QUICKDRAW
+void osx_qz_mark_dirty();
+void prepare_window_for_animation(int refresh_view);
+#endif
+
+@implementation AllegroWindow
+
+#ifdef ENABLE_QUICKDRAW
+/* display:
+ *  Called when the window is about to be deminiaturized.
+ */
+- (void)display
+{
+    [super display];
+    prepare_window_for_animation(TRUE);
+}
+
+
+
+/* miniaturize:
+ *  Called when the window is miniaturized.
+ */
+- (void)miniaturize: (id)sender
+{
+    prepare_window_for_animation(FALSE);
+    [super miniaturize: sender];
+}
+#endif
+
+- (BOOL)canBecomeKeyWindow
+{
+    return YES;
+}
+
+- (BOOL)canBecomeMainWindow
+{
+    return YES;
+}
+
+@end
+
+
+@implementation AllegroWindowDelegate
+
+/* windowShouldClose:
+ *  Called when the user attempts to close the window.
+ *  Default behaviour is to call the user callback (if any) and deny closing.
+ */
+- (BOOL)windowShouldClose: (id)sender
+{
+    if (osx_window_close_hook)
+        osx_window_close_hook();
+    return NO;
+}
+
+
+
+/* windowDidDeminiaturize:
+ *  Called when the window deminiaturization animation ends; marks the whole
+ *  window contents as dirty, so it is updated on next refresh.
+ */
+- (void)windowDidDeminiaturize: (NSNotification *)aNotification
+{
+#ifdef ENABLE_QUICKDRAW
+    _unix_lock_mutex(osx_window_mutex);
+    osx_qz_mark_dirty();
+    _unix_unlock_mutex(osx_window_mutex);
+#endif
+}
+
+
+
+/* windowDidBecomeKey:
+ * Sent by the default notification center immediately after an NSWindow
+ * object has become key.
+ */
+- (void)windowDidBecomeKey:(NSNotification *)notification
+{
+    _unix_lock_mutex(osx_skip_events_processing_mutex);
+    osx_skip_events_processing = FALSE;
+    _unix_unlock_mutex(osx_skip_events_processing_mutex);
+}
+
+
+
+/* windowDidResignKey:
+ * Sent by the default notification center immediately after an NSWindow
+ * object has resigned its status as key window.
+ */
+- (void)windowDidResignKey:(NSNotification *)notification
+{
+    _unix_lock_mutex(osx_skip_events_processing_mutex);
+    osx_skip_events_processing = TRUE;
+    _unix_unlock_mutex(osx_skip_events_processing_mutex);
+}
+
+@end
+
+void runOnMainQueueWithoutDeadlocking(void (^block)(void))
+{
+    if ([NSThread isMainThread])
+    {
+        block();
+    }
+    else
+    {
+        dispatch_sync(dispatch_get_main_queue(), block);
+    }
+}
+
+/* Local variables:       */
+/* c-basic-offset: 3      */
+/* indent-tabs-mode: nil  */
+/* c-file-style: "linux" */
+/* End:                   */
diff --git a/src/macosx/drivers.m b/src/macosx/drivers.m
index 9284d67..8f28f7f 100644
--- a/src/macosx/drivers.m
+++ b/src/macosx/drivers.m
@@ -47,20 +47,22 @@ _DRIVER_INFO _mouse_driver_list[] =
 
 
 BEGIN_GFX_DRIVER_LIST
+#ifdef ENABLE_QUICKDRAW
 {   GFX_QUARTZ_FULLSCREEN,    &gfx_quartz_full,         TRUE  },
 {   GFX_QUARTZ_WINDOW,        &gfx_quartz_window,       TRUE  },
+#endif
+{   GFX_COCOAGL_WINDOW,       &gfx_cocoagl_window,      TRUE  },
+{   GFX_COCOAGL_FULLSCREEN,   &gfx_cocoagl_full,        TRUE  },
 END_GFX_DRIVER_LIST
 
 
 BEGIN_DIGI_DRIVER_LIST
 {   DIGI_CORE_AUDIO,          &digi_core_audio,         TRUE  },
-{   DIGI_SOUND_MANAGER,       &digi_sound_manager,      TRUE  },
 END_DIGI_DRIVER_LIST
 
 
 BEGIN_MIDI_DRIVER_LIST
 {   MIDI_CORE_AUDIO,          &midi_core_audio,         TRUE  },
-{   MIDI_QUICKTIME,           &midi_quicktime,          TRUE  },
 END_MIDI_DRIVER_LIST
 
 
diff --git a/src/macosx/main.m b/src/macosx/main.m
index 33f60fa..602a3b9 100644
--- a/src/macosx/main.m
+++ b/src/macosx/main.m
@@ -34,10 +34,11 @@ extern char **__crt0_argv;
 extern void *_mangled_main_address;
 
 static char *arg0, *arg1 = NULL;
-static int refresh_rate = 70;
 
 static volatile BOOL ready_to_terminate = NO;
 
+extern void osx_add_event_monitor();
+
 static BOOL in_bundle(void)
 {
    /* This comes from the ADC tips & tricks section: how to detect if the app
@@ -48,12 +49,15 @@ static BOOL in_bundle(void)
    FSCatalogInfo processInfo;
    GetProcessBundleLocation(&psn, &processRef);
    FSGetCatalogInfo(&processRef, kFSCatInfoNodeFlags, &processInfo, NULL, NULL, NULL);
-   if (processInfo.nodeFlags & kFSNodeIsDirectoryMask) 
+   if (processInfo.nodeFlags & kFSNodeIsDirectoryMask)
      return YES;
    else
      return NO;
 }
 
+@interface AllegroAppDelegate ()
+@end
+
 @implementation AllegroAppDelegate
 
 - (BOOL)application: (NSApplication *)theApplication openFile: (NSString *)filename
@@ -63,14 +67,13 @@ static BOOL in_bundle(void)
 }
 
 
-
 /* applicationDidFinishLaunching:
  *  Called when the app is ready to run. This runs the system events pump and
  *  updates the app window if it exists.
  */
 - (void)applicationDidFinishLaunching: (NSNotification *)aNotification
 {
-   NSAutoreleasePool *pool = NULL;
+
    CFDictionaryRef mode;
    NSString* exename, *resdir;
    NSFileManager* fm;
@@ -79,9 +82,8 @@ static BOOL in_bundle(void)
    /* create mutex */
    osx_event_mutex = _unix_create_mutex();
    osx_skip_events_processing_mutex = _unix_create_mutex();
-   
-   pool = [[NSAutoreleasePool alloc] init];
-   if (in_bundle() == YES)   
+
+   if (in_bundle() == YES)
    {
       /* In a bundle, so chdir to the containing directory,
        * or to the 'magic' resource directory if it exists.
@@ -92,7 +94,7 @@ static BOOL in_bundle(void)
       resdir = [[osx_bundle resourcePath] stringByAppendingPathComponent: exename];
       fm = [NSFileManager defaultManager];
       if ([fm fileExistsAtPath: resdir isDirectory: &isDir] && isDir) {
-          /* Yes, it exists inside the bundle */
+           // Yes, it exists inside the bundle
           [fm changeCurrentDirectoryPath: resdir];
       }
       else {
@@ -106,10 +108,10 @@ static BOOL in_bundle(void)
       arg0 = strdup([[osx_bundle bundlePath] fileSystemRepresentation]);
       if (arg1) {
          static char *args[2];
-	 args[0] = arg0;
-	 args[1] = arg1;
-	 __crt0_argv = args;
-	 __crt0_argc = 2;
+         args[0] = arg0;
+         args[1] = arg1;
+         __crt0_argv = args;
+         __crt0_argc = 2;
       }
       else {
          __crt0_argv = &arg0;
@@ -117,57 +119,19 @@ static BOOL in_bundle(void)
       }
    }
    /* else: not in a bundle so don't chdir */
-   
-   mode = CGDisplayCurrentMode(kCGDirectMainDisplay);
-   CFNumberGetValue(CFDictionaryGetValue(mode, kCGDisplayRefreshRate), kCFNumberSInt32Type, &refresh_rate);
-   if (refresh_rate <= 0)
-      refresh_rate = 70;
-   
+
+    osx_add_event_monitor();
+
    [NSThread detachNewThreadSelector: @selector(app_main:)
       toTarget: [AllegroAppDelegate class]
       withObject: nil];
-   
-   while (!ready_to_terminate) {
-      if (osx_gfx_mode == OSX_GFX_WINDOW)
-         osx_update_dirty_lines();
-      _unix_lock_mutex(osx_event_mutex);
-      if (osx_gfx_mode == OSX_GFX_FULL) {
-         if ((osx_palette) && (osx_palette_dirty)) {
-            CGDisplaySetPalette(kCGDirectMainDisplay, osx_palette);
-	    osx_palette_dirty = FALSE;
-	 }
-      }
-      osx_event_handler();
-      _unix_unlock_mutex(osx_event_mutex);
-      usleep(1000000 / refresh_rate);
-   }
-   
-   [pool release];
-   _unix_destroy_mutex(osx_event_mutex);
-
-   [NSApp terminate:self];
 }
 
-
-
 /* applicationDidChangeScreenParameters:
  *  Invoked when the screen did change resolution/color depth.
  */
 - (void)applicationDidChangeScreenParameters: (NSNotification *)aNotification
 {
-   CFDictionaryRef mode;
-   int new_refresh_rate;
-   
-   if ((osx_window) && (osx_gfx_mode == OSX_GFX_WINDOW)) 
-   {
-      osx_setup_colorconv_blitter();
-      [osx_window display];
-   }
-   mode = CGDisplayCurrentMode(kCGDirectMainDisplay);
-   CFNumberGetValue(CFDictionaryGetValue(mode, kCGDisplayRefreshRate), kCFNumberSInt32Type, &new_refresh_rate);
-   if (new_refresh_rate <= 0)
-      new_refresh_rate = 70;
-   refresh_rate = new_refresh_rate;
 }
 
 
@@ -179,22 +143,22 @@ static void call_user_main(void)
    real_main(__crt0_argc, __crt0_argv);
    allegro_exit();
    ready_to_terminate = YES;
+   runOnMainQueueWithoutDeadlocking(^{
+     [NSApp terminate:nil];
+   });
 }
 
-
-
 /* app_main:
  *  Thread dedicated to the user program; real main() gets called here.
  */
 + (void)app_main: (id)arg
 {
-   NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-   call_user_main();
-   [pool release];
+  @autoreleasepool {
+    call_user_main();
+  }
 }
 
 
-
 /* applicationShouldTerminate:
  *  Called upon Command-Q or "Quit" menu item selection.
  *  If the window close callback is set, calls it, otherwise does
@@ -242,37 +206,23 @@ static void call_user_main(void)
 
 
 
-/* This prevents warnings that 'NSApplication might not
- * respond to setAppleMenu' on OS X 10.4
- */
-@interface NSApplication(AllegroOSX)
-- (void)setAppleMenu:(NSMenu *)menu;
-@end
-
-
-
 /* main:
  *  Replacement for main function.
  */
 int main(int argc, char *argv[])
 {
-   NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-   AllegroAppDelegate *app_delegate = [[AllegroAppDelegate alloc] init];
+   @autoreleasepool {
+
    NSMenu *menu;
    NSMenuItem *menu_item, *temp_item;
 
-   /* I don't know what that NSAutoreleasePool line does but the variable was
-    * otherwise unused --pw
-    */
-   (void)pool;
-
    __crt0_argc = argc;
    __crt0_argv = argv;
-   
-   if (!osx_bootstrap_ok()) /* not safe to use NSApplication */
-      call_user_main();
-      
-   [NSApplication sharedApplication];
+
+   AllegroAppDelegate *app_delegate = [[AllegroAppDelegate alloc] init];
+
+    [NSApplication sharedApplication];
+    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];
 
    /* Load the main menu nib if possible */
    if ((!in_bundle()) || ([NSBundle loadNibNamed: @"MainMenu"
@@ -281,39 +231,40 @@ int main(int argc, char *argv[])
        /* Didn't load the nib; create a default menu programmatically */
        NSString* title = nil;
        NSDictionary* app_dictionary = [[NSBundle mainBundle] infoDictionary];
-       if (app_dictionary) 
+       if (app_dictionary)
        {
           title = [app_dictionary objectForKey: @"CFBundleName"];
        }
-       if (title == nil) 
+       if (title == nil)
        {
           title = [[NSProcessInfo processInfo] processName];
        }
        [NSApp setMainMenu: [[NSMenu allocWithZone: [NSMenu menuZone]] initWithTitle: @"temp"]];
        menu = [[NSMenu allocWithZone: [NSMenu menuZone]] initWithTitle: @"temp"];
        temp_item = [[NSMenuItem allocWithZone: [NSMenu menuZone]]
-		     initWithTitle: @"temp"
-		     action: NULL
-		     keyEquivalent: @""];
+                     initWithTitle: @"temp"
+                     action: NULL
+                     keyEquivalent: @""];
        [[NSApp mainMenu] addItem: temp_item];
        [[NSApp mainMenu] setSubmenu: menu forItem: temp_item];
        [NSApp setAppleMenu: menu];
        NSString *quit = [@"Quit " stringByAppendingString: title];
        menu_item = [[NSMenuItem allocWithZone: [NSMenu menuZone]]
-		     initWithTitle: quit
-		     action: @selector(quitAction:)
-		     keyEquivalent: @"q"];
+                     initWithTitle: quit
+                     action: @selector(quitAction:)
+                     keyEquivalent: @"q"];
        [menu_item setKeyEquivalentModifierMask: NSCommandKeyMask];
        [menu_item setTarget: app_delegate];
        [menu addItem: menu_item];
    }
 
    [NSApp setDelegate: app_delegate];
-   
+
    [NSApp run];
    /* Can never get here */
-   
+
    return 0;
+   }
 }
 
 /* Local variables:       */
diff --git a/src/macosx/quartz.m b/src/macosx/quartz.m
index e7e76e7..09fc09b 100644
--- a/src/macosx/quartz.m
+++ b/src/macosx/quartz.m
@@ -49,7 +49,7 @@ void setup_direct_shifts(void)
    _rgb_b_shift_32 = 0;
 }
 
-
+#ifdef ENABLE_QUICKDRAW
 
 /* osx_qz_write_line:
  *  Line switcher for video bitmaps.
@@ -254,3 +254,5 @@ void osx_qz_blit_to_self(BITMAP *source, BITMAP *dest, int source_x, int source_
    if (!(dest->id & BMP_ID_LOCKED))
       UnlockPortBits(BMP_EXTRA(dest)->port);
 }
+
+#endif
\ No newline at end of file
diff --git a/src/macosx/qzfull.m b/src/macosx/qzfull.m
index 7df89ad..d4f967b 100644
--- a/src/macosx/qzfull.m
+++ b/src/macosx/qzfull.m
@@ -24,6 +24,7 @@
    #error something is wrong with the makefile
 #endif
 
+#ifdef ENABLE_QUICKDRAW
 
 #define FADE_STEPS               16
 
@@ -455,3 +456,4 @@ static GFX_MODE_LIST *osx_qz_fetch_mode_list(void)
    return gfx_mode_list;
 }
 
+#endif
diff --git a/src/macosx/qzmouse.m b/src/macosx/qzmouse.m
index 5da32af..79f171c 100644
--- a/src/macosx/qzmouse.m
+++ b/src/macosx/qzmouse.m
@@ -211,8 +211,7 @@ static void osx_mouse_exit(void)
 static void osx_mouse_position(int x, int y)
 {
    CGPoint point;
-   NSRect frame;
-   int screen_height;
+   NSRect frame, screen_frame;
    
    _unix_lock_mutex(osx_event_mutex);
    
@@ -220,13 +219,19 @@ static void osx_mouse_position(int x, int y)
    _mouse_y = point.y = y;
    
    if (osx_window) {
-      CFNumberGetValue(CFDictionaryGetValue(CGDisplayCurrentMode(kCGDirectMainDisplay), kCGDisplayHeight), kCFNumberSInt32Type, &screen_height);
+      screen_frame = [[NSScreen mainScreen] frame];
       frame = [osx_window frame];
+      // scale position
+      point.x *= (frame.size.width / gfx_driver->w);
+      point.y *= (frame.size.height / gfx_driver->h);
+
       point.x += frame.origin.x;
-      point.y += (screen_height - (frame.origin.y + gfx_driver->h));
+      point.y += (screen_frame.size.height - (frame.origin.y + frame.size.height));
+   }
+
+   if (osx_gfx_mode != OSX_GFX_NONE) {
+      CGDisplayMoveCursorToPoint(kCGDirectMainDisplay, point);
    }
-   
-   CGDisplayMoveCursorToPoint(kCGDirectMainDisplay, point);
    
    mymickey_x = mymickey_y = 0;
    osx_mouse_warped = TRUE;
@@ -274,19 +279,12 @@ int osx_mouse_set_sprite(BITMAP *sprite, int x, int y)
 {
    int ix, iy;
    int sw, sh;
-   
+
    if (!sprite)
       return -1;
    sw = sprite->w;
    sh = sprite->h;
-   if (floor(NSAppKitVersionNumber) <= NSAppKitVersionNumber10_2) {
-      // Before MacOS X 10.3, NSCursor can handle only 16x16 cursor sprites
-      // Pad to 16x16 or fail if the sprite is already larger.
-      if (sw>16 || sh>16)
-         return -1;
-      sh = sw = 16;
-   }
-   
+
    // Delete the old cursor (OK to send a message to nil)
    [cursor release];
 
diff --git a/src/macosx/qzwindow.m b/src/macosx/qzwindow.m
index 8e4a606..e62e6ae 100644
--- a/src/macosx/qzwindow.m
+++ b/src/macosx/qzwindow.m
@@ -24,6 +24,7 @@
    #error something is wrong with the makefile
 #endif
 
+#ifdef ENABLE_QUICKDRAW
 
 static BITMAP *osx_qz_window_init(int, int, int, int, int);
 static void osx_qz_window_exit(BITMAP *);
@@ -56,8 +57,6 @@ static GFX_VTABLE _special_vtable; /* special vtable for active video page */
 static GFX_VTABLE _unspecial_vtable; /* special vtable for inactive video page */
 static BITMAP* current_video_page = NULL;
 
-void* osx_window_mutex;
-
 
 GFX_DRIVER gfx_quartz_window =
 {
@@ -97,8 +96,6 @@ GFX_DRIVER gfx_quartz_window =
    TRUE
 };
 
-
-
 /* prepare_window_for_animation:
  *  Prepares the window for a (de)miniaturization animation.
  *  Called by the window display method when the window is about to be
@@ -107,124 +104,41 @@ GFX_DRIVER gfx_quartz_window =
  *  When called from the miniaturize window method, only the alpha value
  *  is updated.
  */
-static void prepare_window_for_animation(int refresh_view)
-{
-   struct GRAPHICS_RECT src_gfx_rect, dest_gfx_rect;
-   unsigned int *addr;
-   int pitch, y, x;
-   
-   _unix_lock_mutex(osx_window_mutex);
-   while (![qd_view lockFocusIfCanDraw]);
-   while (!QDDone([qd_view qdPort]));
-   LockPortBits([qd_view qdPort]);
-   pitch = GetPixRowBytes(GetPortPixMap([qd_view qdPort])) / 4;
-   addr = (unsigned int *)GetPixBaseAddr(GetPortPixMap([qd_view qdPort])) +
-      ((int)([osx_window frame].size.height) - gfx_quartz_window.h) * pitch;
-   if (refresh_view && colorconv_blitter) {
-      src_gfx_rect.width  = gfx_quartz_window.w;
-      src_gfx_rect.height = gfx_quartz_window.h;
-      src_gfx_rect.pitch  = pseudo_screen_pitch;
-      src_gfx_rect.data   = pseudo_screen_addr;
-      dest_gfx_rect.pitch = pitch * 4;
-      dest_gfx_rect.data  = addr;
-      colorconv_blitter(&src_gfx_rect, &dest_gfx_rect);
-   }
-   for (y = gfx_quartz_window.h; y; y--) {
-      for (x = 0; x < gfx_quartz_window.w; x++)
-         *(addr + x) |= 0xff000000;
-      addr += pitch;
-   }
-   UnlockPortBits([qd_view qdPort]);
-   [qd_view unlockFocus];
-   _unix_unlock_mutex(osx_window_mutex);
-}
-
-
-
-@implementation AllegroWindow
-
-/* display:
- *  Called when the window is about to be deminiaturized.
- */
-- (void)display
-{
-   [super display];
-   if (desktop_depth == 32)
-      prepare_window_for_animation(TRUE);
-}
-
-
-
-/* miniaturize:
- *  Called when the window is miniaturized.
- */
-- (void)miniaturize: (id)sender
-{
-   if (desktop_depth == 32)
-      prepare_window_for_animation(FALSE);
-   [super miniaturize: sender];
-}
-
-@end
-
-
-
-@implementation AllegroWindowDelegate
-
-/* windowShouldClose:
- *  Called when the user attempts to close the window.
- *  Default behaviour is to call the user callback (if any) and deny closing.
- */
-- (BOOL)windowShouldClose: (id)sender
+void prepare_window_for_animation(int refresh_view)
 {
-   if (osx_window_close_hook)
-      osx_window_close_hook();
-   return NO;
+    struct GRAPHICS_RECT src_gfx_rect, dest_gfx_rect;
+    unsigned int *addr;
+    int pitch, y, x;
+
+    if (desktop_depth != 32)
+        return;
+    
+    _unix_lock_mutex(osx_window_mutex);
+    while (![qd_view lockFocusIfCanDraw]);
+    while (!QDDone([qd_view qdPort]));
+    LockPortBits([qd_view qdPort]);
+    pitch = GetPixRowBytes(GetPortPixMap([qd_view qdPort])) / 4;
+    addr = (unsigned int *)GetPixBaseAddr(GetPortPixMap([qd_view qdPort])) +
+    ((int)([osx_window frame].size.height) - gfx_quartz_window.h) * pitch;
+    if (refresh_view && colorconv_blitter) {
+        src_gfx_rect.width  = gfx_quartz_window.w;
+        src_gfx_rect.height = gfx_quartz_window.h;
+        src_gfx_rect.pitch  = pseudo_screen_pitch;
+        src_gfx_rect.data   = pseudo_screen_addr;
+        dest_gfx_rect.pitch = pitch * 4;
+        dest_gfx_rect.data  = addr;
+        colorconv_blitter(&src_gfx_rect, &dest_gfx_rect);
+    }
+    for (y = gfx_quartz_window.h; y; y--) {
+        for (x = 0; x < gfx_quartz_window.w; x++)
+            *(addr + x) |= 0xff000000;
+        addr += pitch;
+    }
+    UnlockPortBits([qd_view qdPort]);
+    [qd_view unlockFocus];
+    _unix_unlock_mutex(osx_window_mutex);
 }
 
-
-
-/* windowDidDeminiaturize:
- *  Called when the window deminiaturization animation ends; marks the whole
- *  window contents as dirty, so it is updated on next refresh.
- */
-- (void)windowDidDeminiaturize: (NSNotification *)aNotification
-{
-   _unix_lock_mutex(osx_window_mutex);
-   memset(dirty_lines, 1, gfx_quartz_window.h);
-   _unix_unlock_mutex(osx_window_mutex);
-}
-
-
-
-/* windowDidBecomeKey:
- * Sent by the default notification center immediately after an NSWindow
- * object has become key.
- */
-- (void)windowDidBecomeKey:(NSNotification *)notification
-{
-   _unix_lock_mutex(osx_skip_events_processing_mutex);
-   osx_skip_events_processing = FALSE;
-   _unix_unlock_mutex(osx_skip_events_processing_mutex);
-}
-
-
-
-/* windowDidResignKey:
- * Sent by the default notification center immediately after an NSWindow
- * object has resigned its status as key window.
- */
-- (void)windowDidResignKey:(NSNotification *)notification
-{
-   _unix_lock_mutex(osx_skip_events_processing_mutex);
-   osx_skip_events_processing = TRUE;
-   _unix_unlock_mutex(osx_skip_events_processing_mutex);
-}
-
-@end
-
-
-
 @implementation AllegroView
 
 /* resetCursorRects:
@@ -269,7 +183,10 @@ static void osx_qz_release_win(BITMAP *bmp)
 	_unix_unlock_mutex(osx_window_mutex);
 }
 
-
+void osx_qz_mark_dirty()
+{
+    memset(dirty_lines, 1, gfx_quartz_window.h);
+}
 
 /* osx_qz_write_line_win:
  *  Line switcher for Quartz windowed mode.
@@ -810,6 +727,9 @@ static void osx_destroy_video_bitmap(BITMAP* bm)
 	}
 	// Otherwise it wasn't a video page
 }
+
+#endif
+
 /* Local variables:       */
 /* c-basic-offset: 3      */
 /* indent-tabs-mode: nil  */
diff --git a/src/macosx/system.m b/src/macosx/system.m
index 1b01839..3ff7bdf 100644
--- a/src/macosx/system.m
+++ b/src/macosx/system.m
@@ -26,8 +26,6 @@
 
 #ifndef SCAN_DEPEND
 #include <CoreFoundation/CoreFoundation.h>
-#include <mach/mach_port.h>
-#include <servers/bootstrap.h>
 #endif
 
 
@@ -137,26 +135,31 @@ SYSTEM_DRIVER system_macosx =
 static RETSIGTYPE osx_signal_handler(int num)
 {
    _unix_unlock_mutex(osx_event_mutex);
-   _unix_unlock_mutex(osx_window_mutex);
-   
+
    allegro_exit();
-   
+
    _unix_destroy_mutex(osx_event_mutex);
-   _unix_destroy_mutex(osx_window_mutex);
-   
+
    fprintf(stderr, "Shutting down Allegro due to signal #%d\n", num);
    raise(num);
 }
 
 
-
-/* osx_event_handler:
- *  Event handling function; gets repeatedly called inside a dedicated thread.
- */
-void osx_event_handler()
+inline static void osx_scale_mouse(NSPointPointer position, const NSRectPointer window, const NSRectPointer view)
 {
-   NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-   NSEvent *event;
+    // flip the vertical to top down
+    position->y = window->size.height - position->y;
+    if (!NSEqualSizes(window->size, view->size)) {
+        position->x = position->x / window->size.width * view->size.width;
+        position->y = position->y / window->size.height * view->size.height;
+    }
+}
+
+
+void osx_add_event_monitor() {
+
+   [NSEvent addLocalMonitorForEventsMatchingMask:NSAnyEventMask handler:^NSEvent * (NSEvent *event) {
+
    NSDate *distant_past = [NSDate distantPast];
    NSPoint point;
    NSRect frame, view;
@@ -166,251 +169,171 @@ void osx_event_handler()
    static int buttons = 0;
    int event_type;
    BOOL gotmouseevent = NO;
-   
-   while ((event = [NSApp nextEventMatchingMask: NSAnyEventMask
-         untilDate: distant_past
-         inMode: NSDefaultRunLoopMode
-         dequeue: YES]) != nil)
-   {
-      _unix_lock_mutex(osx_skip_events_processing_mutex);
-      int skip_events_processing = osx_skip_events_processing;
-      _unix_unlock_mutex(osx_skip_events_processing_mutex);
 
-      if ((skip_events_processing) || (osx_gfx_mode == OSX_GFX_NONE)) {
-         [NSApp sendEvent: event];
-	 continue;
-      }
-      
-      view = NSMakeRect(0, 0, gfx_driver->w, gfx_driver->h);
-      point = [event locationInWindow];
-      if (osx_window) 
-      {
-	 frame = [[osx_window contentView] frame];
-      }
-      else
-      {
-	 frame = [[NSScreen mainScreen] frame];
-      }
-      event_type = [event type];
-      switch (event_type) {
-	 
-         case NSKeyDown:
-	    if (_keyboard_installed)
-	       osx_keyboard_handler(TRUE, event);
-	    if ([event modifierFlags] & NSCommandKeyMask) 
-	       [NSApp sendEvent: event];
-	    break;
-	
-         case NSKeyUp:
-	    if (_keyboard_installed)
-	       osx_keyboard_handler(FALSE, event);
-	    if ([event modifierFlags] & NSCommandKeyMask) 
-	       [NSApp sendEvent: event];
-	    break;
-
-         case NSFlagsChanged:
-	    if (_keyboard_installed)
-	       osx_keyboard_modifiers([event modifierFlags]);
-	    break;
-	 
-         case NSLeftMouseDown:
-         case NSOtherMouseDown:
-         case NSRightMouseDown:
-	    if (![NSApp isActive]) {
-	       /* App is regaining focus */
-	       if (_mouse_installed) {
-	          if ((osx_window) && (NSPointInRect(point, view))) {
-                     mx = point.x;
-	             my = frame.size.height - point.y;
-		     buttons = 0;
-                     _mouse_on = TRUE;
-	          }
-	       }
-	       if (osx_window)
-                  [osx_window invalidateCursorRectsForView: [osx_window contentView]];
-	       if (_keyboard_installed)
-	          osx_keyboard_focused(TRUE, 0);
-	       _switch_in();
-	       gotmouseevent = YES;
-	       [NSApp sendEvent: event];
-	       break;
-	    }
-	    /* fallthrough */
-         case NSLeftMouseUp:
-         case NSOtherMouseUp:
-         case NSRightMouseUp:
-	    if (osx_emulate_mouse_buttons) {
-	       if (event_type == NSLeftMouseDown) {
-                  if ((!osx_window) || (NSPointInRect(point, view))) {
-		     buttons = 0x1;
-		     if (key[KEY_ALT])
-		        buttons = 0x4;
-		     if (key[KEY_LCONTROL])
-		        buttons = 0x2;
-		  }
-	       }
-	       else if (event_type == NSLeftMouseUp)
-	          buttons &= ~0x7;
-	    }
-	    else {
-	       if ((!osx_window) || (NSPointInRect(point, view))) {
-	          /* Deliver mouse downs only if cursor is on the window */
-	          buttons |= ((event_type == NSLeftMouseDown) ? 0x1 : 0);
-	          buttons |= ((event_type == NSRightMouseDown) ? 0x2 : 0);
-	          buttons |= ((event_type == NSOtherMouseDown) ? 0x4 : 0);
-	       }
-	       buttons &= ~((event_type == NSLeftMouseUp) ? 0x1 : 0);
-	       buttons &= ~((event_type == NSRightMouseUp) ? 0x2 : 0);
-	       buttons &= ~((event_type == NSOtherMouseUp) ? 0x4 : 0);
-	    }
-	    gotmouseevent = YES;
-	    [NSApp sendEvent: event];
-	    break;
-	    
-         case NSLeftMouseDragged:
-         case NSRightMouseDragged:
-         case NSOtherMouseDragged:
-         case NSMouseMoved:
-	    dx += [event deltaX];
-	    dy += [event deltaY];
-
-	    mx=point.x;
-	    my=frame.size.height-point.y;
-
-	    [NSApp sendEvent: event];
-	    gotmouseevent = YES;
-	    break;
-            
-         case NSScrollWheel:
-	    dz += [event deltaY];
-	    gotmouseevent = YES;
-            break;
-	    
-	 case NSMouseEntered:
-	    if (([event trackingNumber] == osx_mouse_tracking_rect) && ([NSApp isActive])) {
-	       if (_mouse_installed) {
-		  mx = point.x;
-	          my = frame.size.height - point.y;
-		  buttons = 0;
-                  _mouse_on = TRUE;
-		  gotmouseevent = YES;
-	       }
-	    }
-	    [NSApp sendEvent: event];
-	    break;
-            
-	 case NSMouseExited:
-	    if ([event trackingNumber] == osx_mouse_tracking_rect) {
-	       if (_mouse_installed) {
-	          _mouse_on = FALSE;
-		  gotmouseevent = YES;
-	       }
-	    }
-            [NSApp sendEvent: event];
-	    break;
-            
-	 case NSAppKitDefined:
-            switch ([event subtype]) {
-               case NSApplicationActivatedEventType:
-	          if (osx_window) {
-		     [osx_window invalidateCursorRectsForView: [osx_window contentView]];
-                     if (_keyboard_installed)
-	                osx_keyboard_focused(TRUE, 0);
-		  }
-		  _switch_in();
-                  break;
-		  
-               case NSApplicationDeactivatedEventType:
-		  if (osx_window && _keyboard_installed)
-		     osx_keyboard_focused(FALSE, 0);
-		  _switch_out();
-                  break;
-	       
-	       case NSWindowMovedEventType:
-                  /* This is needed to ensure the shadow gets drawn when the window is
-		   * created. It's weird, but when the window is created on another
-		   * thread, sometimes its shadow doesn't get drawn. The same applies
-		   * to the cursor rectangle, which doesn't seem to be set at window
-		   * creation (it works once you move the mouse though).
-		   */
-	          if ((osx_window) && (osx_window_first_expose)) {
-		     osx_window_first_expose = FALSE;
-                     [osx_window setHasShadow: NO];
-                     [osx_window setHasShadow: YES];
-		     [osx_window invalidateCursorRectsForView: [osx_window contentView]];
-		  }
-		  break;
-	    }
-            [NSApp sendEvent: event];
-            break;
-	 
-	 default:
-	    [NSApp sendEvent: event];
-	    break;
-      }
-   }
-   if (gotmouseevent == YES)
-      osx_mouse_handler(mx, my, dx, dy, dz, buttons);
-   [pool release];
-}
+   _unix_lock_mutex(osx_skip_events_processing_mutex);
+   int skip_events_processing = osx_skip_events_processing;
+   _unix_unlock_mutex(osx_skip_events_processing_mutex);
 
+   if ((skip_events_processing) || (osx_gfx_mode == OSX_GFX_NONE)) {
+      return event;
+   }
 
+   view = NSMakeRect(0, 0, gfx_driver->w, gfx_driver->h);
+   point = [event locationInWindow];
+   if (osx_window)
+   {
+      frame = [[osx_window contentView] frame];
+   }
+   else
+   {
+       frame = [[NSScreen mainScreen] frame];
+   }
 
-/* osx_tell_dock:
- *  Tell the dock about us; the origins of this hack are unknown, but it's
- *  currently the only way to make a Cocoa app to work when started from a
- *  console.
- *  For the future, (10.3 and above) investigate TranformProcessType in the 
- *  HIServices framework.
- */
-static void osx_tell_dock(void)
-{
-   struct CPSProcessSerNum psn;
+   osx_scale_mouse(&point, &frame, &view);
+
+   event_type = [event type];
+   switch (event_type) {
+
+      case NSKeyDown:
+         if (_keyboard_installed) {
+            osx_keyboard_handler(TRUE, event);
+         }
+         if (! ([event modifierFlags] & NSCommandKeyMask) )
+         {
+            event = nil;
+         }
+         break;
+
+
+      case NSKeyUp:
+         if (_keyboard_installed) {
+            osx_keyboard_handler(FALSE, event);
+         }
+         if (! ([event modifierFlags] & NSCommandKeyMask) )
+         {
+            event = nil;
+         }
+         break;
+
+      case NSFlagsChanged:
+         if (_keyboard_installed) {
+            osx_keyboard_modifiers([event modifierFlags]);
+         }
+         event = nil;
+         break;
+
+      case NSLeftMouseDown:
+      case NSOtherMouseDown:
+      case NSRightMouseDown:
+         if (![NSApp isActive]) {
+            /* App is regaining focus */
+            if (_mouse_installed) {
+               if ((osx_window) && (NSPointInRect(point, view))) {
+              mx = point.x;
+              my = point.y;
+              buttons = 0;
+              _mouse_on = TRUE;
+               }
+            }
+            if (osx_window)
+               [osx_window invalidateCursorRectsForView: [osx_window contentView]];
+            if (_keyboard_installed)
+               osx_keyboard_focused(TRUE, 0);
+            _switch_in();
+            gotmouseevent = YES;
+            break;
+         }
+         /* fallthrough */
+      case NSLeftMouseUp:
+      case NSOtherMouseUp:
+      case NSRightMouseUp:
+         if (osx_emulate_mouse_buttons) {
+            if (event_type == NSLeftMouseDown) {
+               if ((!osx_window) || (NSPointInRect(point, view))) {
+                  buttons = 0x1;
+                  if (key[KEY_ALT])
+                     buttons = 0x4;
+                  if (key[KEY_LCONTROL])
+                     buttons = 0x2;
+               }
+            }
+            else if (event_type == NSLeftMouseUp)
+               buttons &= ~0x7;
+         }
+         else {
+            if ((!osx_window) || (NSPointInRect(point, view))) {
+               /* Deliver mouse downs only if cursor is on the window */
+               buttons |= ((event_type == NSLeftMouseDown) ? 0x1 : 0);
+               buttons |= ((event_type == NSRightMouseDown) ? 0x2 : 0);
+               buttons |= ((event_type == NSOtherMouseDown) ? 0x4 : 0);
+            }
+            buttons &= ~((event_type == NSLeftMouseUp) ? 0x1 : 0);
+            buttons &= ~((event_type == NSRightMouseUp) ? 0x2 : 0);
+            buttons &= ~((event_type == NSOtherMouseUp) ? 0x4 : 0);
+         }
+         gotmouseevent = YES;
+         break;
+
+      case NSLeftMouseDragged:
+      case NSRightMouseDragged:
+      case NSOtherMouseDragged:
+      case NSMouseMoved:
+         dx += [event deltaX];
+         dy += [event deltaY];
+
+         mx=point.x;
+         my=point.y;
+
+         gotmouseevent = YES;
+         break;
+
+      case NSScrollWheel:
+         dz += [event deltaY];
+         gotmouseevent = YES;
+         break;
+
+      case NSMouseEntered:
+         if (([event trackingNumber] == osx_mouse_tracking_rect) && ([NSApp isActive])) {
+            if (_mouse_installed) {
+               mx = point.x;
+               my = point.y;
+               buttons = 0;
+               _mouse_on = TRUE;
+               gotmouseevent = YES;
+            }
+         }
+         break;
+
+      case NSMouseExited:
+         if ([event trackingNumber] == osx_mouse_tracking_rect) {
+            if (_mouse_installed) {
+               _mouse_on = FALSE;
+               gotmouseevent = YES;
+            }
+         }
+         break;
+
+
+      default:
+         break;
+   }
 
-   if ((!CPSGetCurrentProcess(&psn)) &&
-       (!CPSEnableForegroundOperation(&psn, 0x03, 0x3C, 0x2C, 0x1103)) &&
-       (!CPSSetFrontProcess(&psn)))
-      [NSApplication sharedApplication];
-}
+   if (gotmouseevent == YES) {
+      osx_mouse_handler(mx, my, dx, dy, dz, buttons);
+   }
 
+   return event;
 
+   }];
 
-/* osx_bootstrap_ok:
- *  Check if the current bootstrap context is privilege. If it's not, we can't
- *  use NSApplication, and instead have to go directly to main.
- *  Returns 1 if ok, 0 if not.
- */
-int osx_bootstrap_ok(void)
-{
-   static int _ok = -1;
-   mach_port_t bp;
-   kern_return_t ret;
-   CFMachPortRef cfport;
-
-   /* If have tested once, just return that answer */
-   if (_ok >= 0)
-      return _ok;
-   cfport = CFMachPortCreate(NULL, NULL, NULL, NULL);
-   task_get_bootstrap_port(mach_task_self(), &bp);
-   ret = bootstrap_register(bp, "bootstrap-ok-test", CFMachPortGetPort(cfport));
-   CFRelease(cfport);
-   _ok = (ret == KERN_SUCCESS) ? 1 : 0;
-   return _ok;
 }
 
-
-
 /* osx_sys_init:
  *  Initalizes the MacOS X system driver.
  */
 static int osx_sys_init(void)
 {
    long result;
-   
-   /* If we're in the 'dead bootstrap' environment, the Mac driver won't work. */
-   if (!osx_bootstrap_ok()) {
-      return -1;
-   }
 
    /* Install emergency-exit signal handlers */
    old_sig_abrt = signal(SIGABRT, osx_signal_handler);
@@ -420,21 +343,15 @@ static int osx_sys_init(void)
    old_sig_term = signal(SIGTERM, osx_signal_handler);
    old_sig_int  = signal(SIGINT,  osx_signal_handler);
    old_sig_quit = signal(SIGQUIT, osx_signal_handler);
-   
-    
 
-   if (osx_bundle == NULL) {
-       /* If in a bundle, the dock will recognise us automatically */
-       osx_tell_dock();
-   }
-   
+
    /* Setup OS type & version */
    os_type = OSTYPE_MACOSX;
    Gestalt(gestaltSystemVersion, &result);
    os_version = (((result >> 12) & 0xf) * 10) + ((result >> 8) & 0xf);
    os_revision = (result >> 4) & 0xf;
    os_multitasking = TRUE;
-   
+
    /* Setup a blank cursor */
    cursor_data = calloc(1, 16 * 16 * 4);
    cursor_rep = [[NSBitmapImageRep alloc] initWithBitmapDataPlanes: &cursor_data
@@ -595,10 +512,17 @@ static int osx_sys_set_display_switch_mode(int mode)
  */
 static void osx_sys_get_gfx_safe_mode(int *driver, struct GFX_MODE *mode)
 {
+#ifdef ENABLE_QUICKDRAW
    *driver = GFX_QUARTZ_WINDOW;
    mode->width = 320;
    mode->height = 200;
    mode->bpp = 8;
+#else
+   *driver = GFX_COCOAGL_WINDOW;
+   mode->width = 640;
+   mode->height = 480;
+   mode->bpp = 32;
+#endif
 }
 
 
@@ -608,13 +532,10 @@ static void osx_sys_get_gfx_safe_mode(int *driver, struct GFX_MODE *mode)
  */
 static int osx_sys_desktop_color_depth(void)
 {
-   CFDictionaryRef mode = NULL;
    int color_depth;
    
-   mode = CGDisplayCurrentMode(kCGDirectMainDisplay);
-   if (!mode)
-      return -1;
-   CFNumberGetValue(CFDictionaryGetValue(mode, kCGDisplayBitsPerPixel), kCFNumberSInt32Type, &color_depth);
+   NSWindowDepth depth = [[NSScreen mainScreen] depth];
+   color_depth = NSBitsPerPixelFromDepth(depth);
    
    return color_depth == 16 ? 15 : color_depth;
 }
@@ -625,13 +546,9 @@ static int osx_sys_desktop_color_depth(void)
  */
 static int osx_sys_get_desktop_resolution(int *width, int *height)
 {
-   CFDictionaryRef mode = NULL;
-   
-   mode = CGDisplayCurrentMode(kCGDirectMainDisplay);
-   if (!mode)
-      return -1;
-   CFNumberGetValue(CFDictionaryGetValue(mode, kCGDisplayWidth), kCFNumberSInt32Type, width);
-   CFNumberGetValue(CFDictionaryGetValue(mode, kCGDisplayHeight), kCFNumberSInt32Type, height);
-   
-   return 0;
+   NSRect r = [[NSScreen mainScreen] frame];
+   *width = r.size.width;
+   *height = r.size.height;
+
+    return 0;
 }
diff --git a/src/mouse.c b/src/mouse.c
index 96b25b2..02d7bb2 100644
--- a/src/mouse.c
+++ b/src/mouse.c
@@ -1012,9 +1012,9 @@ static void set_mouse_etc(void)
    else
       hw_cursor_dirty = TRUE;
 
+   position_mouse(SCREEN_W/2, SCREEN_H/2);
    set_mouse_range(0, 0, SCREEN_W-1, SCREEN_H-1);
    set_mouse_speed(2, 2);
-   position_mouse(SCREEN_W/2, SCREEN_H/2);
 }
 
 
diff --git a/src/poly3d.c b/src/poly3d.c
index b950589..18b97c2 100644
--- a/src/poly3d.c
+++ b/src/poly3d.c
@@ -1708,7 +1708,7 @@ void _soft_triangle3d_f(BITMAP *bmp, int type, BITMAP *texture, V3D_f *v1, V3D_f
  */
 void _soft_quad3d(BITMAP *bmp, int type, BITMAP *texture, V3D *v1, V3D *v2, V3D *v3, V3D *v4)
 {
-   #if (defined ALLEGRO_GCC) && (defined ALLEGRO_I386)
+   #if 0 && (defined ALLEGRO_GCC) && (defined ALLEGRO_I386)
       ASSERT(bmp);
 
       /* dodgy assumption alert! See comments for triangle() */
@@ -1735,7 +1735,7 @@ void _soft_quad3d(BITMAP *bmp, int type, BITMAP *texture, V3D *v1, V3D *v2, V3D
  */
 void _soft_quad3d_f(BITMAP *bmp, int type, BITMAP *texture, V3D_f *v1, V3D_f *v2, V3D_f *v3, V3D_f *v4)
 {
-   #if (defined ALLEGRO_GCC) && (defined ALLEGRO_I386)
+   #if 0 && (defined ALLEGRO_GCC) && (defined ALLEGRO_I386)
       ASSERT(bmp);
 
       /* dodgy assumption alert! See comments for triangle() */
diff --git a/src/polygon.c b/src/polygon.c
index c39e7f3..d221046 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -260,7 +260,8 @@ void _soft_triangle(BITMAP *bmp, int x1, int y1, int x2, int y2, int x3, int y3,
 {
    ASSERT(bmp);
 
-   #if (defined ALLEGRO_GCC) && (defined ALLEGRO_I386)
+   /* Disabling this as it horribly blows up on GCC 4.2 on OS X*/
+   #if 0 && (defined ALLEGRO_GCC) && (defined ALLEGRO_I386)
 
       /* note: this depends on a dodgy assumption about parameter passing 
        * conventions. I assume that the point coordinates are all on the 
diff --git a/src/tga.c b/src/tga.c
index d40762e..2340fbb 100644
--- a/src/tga.c
+++ b/src/tga.c
@@ -280,8 +280,8 @@ BITMAP *load_tga_pf(PACKFILE *f, RGB *pal)
    unsigned char image_id[256], image_palette[256][3];
    unsigned char id_length, palette_type, image_type, palette_entry_size;
    unsigned char bpp, descriptor_bits;
-   short unsigned int first_color, palette_colors;
-   short unsigned int left, top, image_width, image_height;
+   short unsigned int palette_colors;
+   short unsigned int image_width, image_height;
    unsigned int c, i, y, yc;
    int dest_depth;
    int compressed;
@@ -299,11 +299,11 @@ BITMAP *load_tga_pf(PACKFILE *f, RGB *pal)
    id_length = pack_getc(f);
    palette_type = pack_getc(f);
    image_type = pack_getc(f);
-   first_color = pack_igetw(f);
+   /* first_color */ pack_igetw(f);
    palette_colors  = pack_igetw(f);
    palette_entry_size = pack_getc(f);
-   left = pack_igetw(f);
-   top = pack_igetw(f);
+   /* left */ pack_igetw(f);
+   /* top  */ pack_igetw(f);
    image_width = pack_igetw(f);
    image_height = pack_igetw(f);
    bpp = pack_getc(f);
diff --git a/src/unix/sdl2digi.c b/src/unix/sdl2digi.c
new file mode 100644
index 0000000..68ef461
--- /dev/null
+++ b/src/unix/sdl2digi.c
@@ -0,0 +1,233 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      SDL2 sound driver.
+ *
+ *      By Edward Rudd.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#include "allegro.h"
+
+#if (defined ALLEGRO_WITH_SDL2DIGI) && ((!defined ALLEGRO_WITH_MODULES) || (defined ALLEGRO_MODULE))
+
+#include "allegro/internal/aintern.h"
+#ifdef ALLEGRO_QNX
+#include "allegro/platform/aintqnx.h"
+#else
+#include "allegro/platform/aintunix.h"
+#endif
+
+#ifndef SCAN_DEPEND
+#include <string.h>
+#include <math.h>
+#include <SDL.h>
+#endif
+
+#define PREFIX_I                "al-sdl2 INFO: "
+#define PREFIX_W                "al-sdl2 WARNING: "
+#define PREFIX_E                "al-sdl2 ERROR: "
+
+static int sdl2_bits, sdl2_signed, sdl2_stereo;
+static unsigned int sdl2_rate;
+
+static SDL_AudioSpec sdl2_audiospec;
+static SDL_AudioDeviceID sdl2_deviceID;
+
+static char sdl2_desc[256] = EMPTY_STRING;
+
+static int sdl2_detect(int input);
+static int sdl2_init(int input, int voices);
+static void sdl2_exit(int input);
+static int sdl2_set_mixer_volume(int volume);
+static int sdl2_get_mixer_volume(void);
+static int sdl2_buffer_size(void);
+
+DIGI_DRIVER digi_sdl2 = {
+    DIGI_SDL2,
+    empty_string,
+    empty_string,
+    "SDL2",
+    0,
+    0,
+    MIXER_MAX_SFX,
+    MIXER_DEF_SFX,
+
+    sdl2_detect,
+    sdl2_init,
+    sdl2_exit,
+    sdl2_set_mixer_volume,
+    sdl2_get_mixer_volume,
+
+    NULL,
+    NULL,
+    sdl2_buffer_size,
+    _mixer_init_voice,
+    _mixer_release_voice,
+    _mixer_start_voice,
+    _mixer_stop_voice,
+    _mixer_loop_voice,
+
+    _mixer_get_position,
+    _mixer_set_position,
+
+    _mixer_get_volume,
+    _mixer_set_volume,
+    _mixer_ramp_volume,
+    _mixer_stop_volume_ramp,
+
+    _mixer_get_frequency,
+    _mixer_set_frequency,
+    _mixer_sweep_frequency,
+    _mixer_stop_frequency_sweep,
+
+    _mixer_get_pan,
+    _mixer_set_pan,
+    _mixer_sweep_pan,
+    _mixer_stop_pan_sweep,
+
+    _mixer_set_echo,
+    _mixer_set_tremolo,
+    _mixer_set_vibrato,
+    0, 0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0
+};
+
+#define DEFAULT_BUFFER_SIZE   1024
+#define MIN_BUFFER_SIZE       128
+
+static int sdl2_detect(int input) {
+    int ret = SDL_InitSubSystem(SDL_INIT_AUDIO) == 0 ? TRUE : FALSE;
+    return ret;
+}
+
+static void sdl2_update(int threaded) {
+    
+}
+
+static void sdl2_callback(void *udata, Uint8 *stream, int len) {
+    if((Uint32)len == sdl2_audiospec.size) {
+        _mix_some_samples((uintptr_t)stream, 0, sdl2_signed);
+    } else {
+        printf("ERROR!!!\n");
+    }
+}
+
+static int sdl2_init(int input, int voices) {
+    char tmp1[128], tmp2[128];
+    SDL_AudioSpec want;
+
+    if (input) {
+        ustrzcpy(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Input is not supported"));
+        return -1;
+    }
+
+    sdl2_bits = (_sound_bits == 8) ? 8 : 16;
+    sdl2_stereo = (_sound_stereo) ? 1 : 0;
+    sdl2_rate = (_sound_freq > 0) ? _sound_freq : 44100;
+
+    SDL_zero(want);
+    want.freq = sdl2_rate;
+    want.channels = sdl2_stereo + 1;
+    want.samples = DEFAULT_BUFFER_SIZE;
+    want.callback = sdl2_callback;
+
+    if (sdl2_bits == 8) {
+        want.format = AUDIO_U8;
+        sdl2_signed = 0;
+    } else if (sdl2_bits == 16) {
+        want.format = AUDIO_S16SYS;
+        sdl2_signed = 1;
+    } else {
+        ustrzcpy(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Unsupported sample format"));
+        return -1;
+    }
+
+    sdl2_deviceID = SDL_OpenAudioDevice(NULL, 0, &want, &sdl2_audiospec, 0);
+    if (sdl2_deviceID == 0) {
+        uszprintf(allegro_error, ALLEGRO_ERROR_SIZE, "Failed to open audio: %s", SDL_GetError());
+        return -1;
+    }
+
+    digi_driver->voices = voices;
+
+    if (_mixer_init(sdl2_audiospec.samples * (sdl2_stereo ? 2 : 1), sdl2_rate,
+            sdl2_stereo, ((sdl2_bits == 16) ? 1 : 0),
+            &digi_driver->voices) != 0) {
+        ustrzcpy(allegro_error, ALLEGRO_ERROR_SIZE, get_config_text("Can not init software mixer"));
+        SDL_CloseAudioDevice(sdl2_deviceID);
+        sdl2_deviceID = 0;
+        return -1;
+    }
+
+    /* Add audio interrupt. */
+    _unix_bg_man->register_func(sdl2_update);
+
+    uszprintf(sdl2_desc, sizeof (sdl2_desc),
+            get_config_text
+            ("SDL2: %d bits, %s, %d bps, %s"),
+            sdl2_bits,
+            uconvert_ascii((sdl2_signed ? "signed" : "unsigned"), tmp1),
+            sdl2_rate, uconvert_ascii((sdl2_stereo ? "stereo" : "mono"), tmp2));
+
+    digi_driver->desc = sdl2_desc;
+
+    SDL_PauseAudioDevice(sdl2_deviceID, 0);
+
+    return 0;
+}
+
+static void sdl2_exit(int input) {
+    if (input)
+        return;
+
+    if (sdl2_deviceID > 0) {
+        _unix_bg_man->unregister_func(sdl2_update);
+
+        SDL_PauseAudioDevice(sdl2_deviceID, 1);
+
+        _mixer_exit();
+
+        SDL_CloseAudioDevice(sdl2_deviceID);
+    }
+}
+
+static int sdl2_set_mixer_volume(int volume) {
+    /* Not implemented */
+    return 0;
+}
+
+static int sdl2_get_mixer_volume(void) {
+    /* Not implemented */
+    return 255;
+}
+
+static int sdl2_buffer_size(void) {
+    return sdl2_audiospec.samples;
+}
+
+#ifdef ALLEGRO_MODULE
+
+/* _module_init:
+ *  Called when loaded as a dynamically linked module.
+ */
+void _module_init(int system_driver) {
+    _unix_register_digi_driver(DIGI_SDL2, &digi_sdl2, TRUE, TRUE);
+}
+
+#endif
+
+#endif
diff --git a/src/unix/umodules.c b/src/unix/umodules.c
index aaa070c..9511e7b 100644
--- a/src/unix/umodules.c
+++ b/src/unix/umodules.c
@@ -126,11 +126,11 @@ void _unix_load_modules(int system_driver)
 	 continue;
 
       if (!fullpath_slash) {
-         snprintf(fullpath, sizeof fullpath, filename);
+         strncpy(fullpath, filename, sizeof fullpath);
 	 fullpath[(sizeof fullpath) - 1] = 0;
       }
       else {
-	 snprintf(fullpath_slash+1, (sizeof fullpath) - (fullpath_slash - fullpath) - 1, filename);
+	 strncpy(fullpath_slash+1, filename, (sizeof fullpath) - (fullpath_slash - fullpath) - 1);
 	 fullpath[(sizeof fullpath) - 1] = 0;
       }
       
diff --git a/src/unix/usystem.c b/src/unix/usystem.c
index a8a171c..3812c8e 100644
--- a/src/unix/usystem.c
+++ b/src/unix/usystem.c
@@ -370,7 +370,7 @@ void _unix_get_executable_name(char *output, int size)
    #ifdef ALLEGRO_HAVE_SV_PROCFS_H
       sprintf (linkname, "/proc/%d/exe", (int)pid);
       fd = open(linkname, O_RDONLY);
-      if (!fd == -1) {
+      if (fd != -1) {
          ioctl(fd, PIOCPSINFO, &psinfo);
          close(fd);
    
diff --git a/src/win/dllver.rc b/src/win/dllver.rc
index d6b986b..59ecf65 100644
--- a/src/win/dllver.rc
+++ b/src/win/dllver.rc
@@ -5,8 +5,8 @@
 
 
 1 VERSIONINFO 
-FILEVERSION 4, 4, 2, 0
-PRODUCTVERSION 4, 4, 2, 0
+FILEVERSION 4, 4, 3, 0
+PRODUCTVERSION 4, 4, 3, 0
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_DLL
 BEGIN
@@ -17,12 +17,12 @@ BEGIN
          VALUE "Comments", "Please see AUTHORS for a list of contributors\000"
          VALUE "CompanyName", "Allegro Developers\000\000"
          VALUE "FileDescription", "Allegro\000"
-         VALUE "FileVersion", "4.4.2\000"
+         VALUE "FileVersion", "4.4.3 (SVN)\000"
          VALUE "InternalName", "ALLEG44\000"
          VALUE "LegalCopyright", "Copyright  1994-2011 Allegro Developers\000\000"
          VALUE "OriginalFilename", "ALLEG44.DLL\000"
          VALUE "ProductName", "Allegro\000"
-         VALUE "ProductVersion", "4.4.2\000"
+         VALUE "ProductVersion", "4.4.3 (SVN)\000"
       END
    END
 
diff --git a/src/win/wddbmpl.c b/src/win/wddbmpl.c
index c65a5ec..9b5b57e 100644
--- a/src/win/wddbmpl.c
+++ b/src/win/wddbmpl.c
@@ -113,11 +113,13 @@ void unregister_all_ddraw_surfaces(void)
  */
 int restore_all_ddraw_surfaces(void)
 {
-   DDRAW_SURFACE *item = ddraw_surface_list;
+   DDRAW_SURFACE *item;
    HRESULT hr;
 
    _enter_gfx_critical();
 
+   item = ddraw_surface_list;
+
    while (item) {
       hr = IDirectDrawSurface2_Restore(item->id);
       if (FAILED(hr)) {
diff --git a/src/win/wddovl.c b/src/win/wddovl.c
index 02de59c..72fca29 100644
--- a/src/win/wddovl.c
+++ b/src/win/wddovl.c
@@ -320,7 +320,7 @@ static struct BITMAP *init_directx_ovl(int w, int h, int v_w, int v_h, int color
 
    /* Paint window background with overlay color key. */
    overlay_brush = CreateSolidBrush(MASK_COLOR_32);
-   SetClassLong(allegro_wnd, GCL_HBRBACKGROUND, (LONG) overlay_brush);
+   SetClassLongPtr(allegro_wnd, GCLP_HBRBACKGROUND, (LONG_PTR)overlay_brush);
 
    if (adjust_window(w, h) != 0) {
       _TRACE(PREFIX_E "window size not supported.\n");
@@ -445,7 +445,7 @@ static void gfx_directx_ovl_exit(struct BITMAP *bmp)
    /* destroy the overlay surface */
    if (overlay_surface) {
       hide_overlay();
-      SetClassLong(allegro_wnd, GCL_HBRBACKGROUND, (LONG) NULL);
+      SetClassLongPtr(allegro_wnd, GCLP_HBRBACKGROUND, (LONG_PTR)NULL);
       DeleteObject(overlay_brush);
       gfx_directx_destroy_surface(overlay_surface);
       overlay_surface = NULL;
diff --git a/src/win/wdispsw.c b/src/win/wdispsw.c
index 258565f..8707ea1 100644
--- a/src/win/wdispsw.c
+++ b/src/win/wdispsw.c
@@ -165,8 +165,8 @@ void _win_switch_out(void)
 
       /* if the thread doesn't stop, lower its priority only if another window is active */ 
       allegro_thread_priority = GetThreadPriority(allegro_thread); 
-      if ((HINSTANCE)GetWindowLong(GetForegroundWindow(), GWL_HINSTANCE) != allegro_inst)
-	 SetThreadPriority(allegro_thread, THREAD_PRIORITY_LOWEST); 
+      if ((HINSTANCE)GetWindowLongPtr(GetForegroundWindow(), GWLP_HINSTANCE) != allegro_inst)
+         SetThreadPriority(allegro_thread, THREAD_PRIORITY_LOWEST);
    }
 
    _switch_out();
diff --git a/src/win/winput.c b/src/win/winput.c
index 3d8a095..9bad0b1 100644
--- a/src/win/winput.c
+++ b/src/win/winput.c
@@ -1,6 +1,6 @@
-/*         ______   ___    ___ 
- *        /\  _  \ /\_ \  /\_ \ 
- *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
  *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
  *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
  *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
@@ -59,7 +59,7 @@ static HANDLE input_thread = NULL;
  */
 static void input_thread_proc(LPVOID unused)
 {
-   int result;
+   DWORD result;
 
    _win_thread_init();
    _TRACE(PREFIX_I "input thread starts\n");
@@ -69,7 +69,7 @@ static void input_thread_proc(LPVOID unused)
       result = WaitForMultipleObjects(_win_input_events, _win_input_event_id, FALSE, INFINITE);
       if (result == WAIT_OBJECT_0 + 2)
          break;  /* thread suicide */
-      else if ((result >= WAIT_OBJECT_0) && (result < WAIT_OBJECT_0 + _win_input_events))
+      else if (result < (DWORD)(WAIT_OBJECT_0 + _win_input_events))
          (*_win_input_event_handler[result - WAIT_OBJECT_0])();
    }
 
@@ -187,6 +187,12 @@ void _win_input_unregister_event(HANDLE event_id)
  */
 void _win_input_init(int need_thread)
 {
+   int i;
+   for (i = 0; i < MAX_EVENTS; ++i) {
+      _win_input_event_id[i]      = 0;
+      _win_input_event_handler[i] = NULL;
+   }
+
    _win_input_event_id[0] = CreateEvent(NULL, FALSE, FALSE, NULL);
    _win_input_event_handler[0] = register_pending_event;
    _win_input_event_id[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
diff --git a/src/win/wjoydx.c b/src/win/wjoydx.c
index 655cb21..61abf3a 100644
--- a/src/win/wjoydx.c
+++ b/src/win/wjoydx.c
@@ -1,6 +1,6 @@
-/*         ______   ___    ___ 
- *        /\  _  \ /\_ \  /\_ \ 
- *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
  *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
  *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
  *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
@@ -12,7 +12,7 @@
  *
  *      By Eric Botcazou.
  *
- *      Omar Cornut fixed it to handle a weird peculiarity of 
+ *      Omar Cornut fixed it to handle a weird peculiarity of
  *      the DirectInput joystick API.
  *
  *      See readme.txt for copyright information.
@@ -186,17 +186,17 @@ static int joystick_dinput_poll(void)
 
          /* In versions of the DirectInput joystick API earlier than 8.00, slider
           * data is to be found in the Z axis data member, although the object was
-          * reported as a slider during enumeration. 
+          * reported as a slider during enumeration.
           *
           * Very few locations seem to describe this "feature". Here is one:
           * http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dx81_vb/directx_vb/Input/VB_Ref/Types/dijoystate2.asp
           *
           * The interesting part is the note at the bottom of the page:
           * " Note: Under Microsoft DirectX 7, sliders on some joysticks could be assigned
-          *   to the Z axis, with subsequent code retrieving data from that member. 
-          *   Using DirectX 8, those same sliders will be assigned to the slider array. 
-          *   This should be taken into account when porting applications to DirectX 8. 
-          *   Make any necessary alterations to ensure that slider data is retrieved from 
+          *   to the Z axis, with subsequent code retrieving data from that member.
+          *   Using DirectX 8, those same sliders will be assigned to the slider array.
+          *   This should be taken into account when porting applications to DirectX 8.
+          *   Make any necessary alterations to ensure that slider data is retrieved from
           *   the slider array. "
           */
 
@@ -333,7 +333,7 @@ static BOOL CALLBACK joystick_enum_callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pv
    HRESULT hr;
    LPVOID temp;
    HWND allegro_wnd = win_get_window();
-   
+
    DIPROPRANGE property_range =
    {
       /* the header */
@@ -438,7 +438,7 @@ static int joystick_dinput_init(void)
       return -1;
 
    /* get the DirectInput interface */
-   hr = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER, &IID_IDirectInput, &joystick_dinput);
+   hr = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER, &IID_IDirectInput, (void**)&joystick_dinput);
    if (FAILED(hr))
       return -1;
 
diff --git a/src/win/wkeybd.c b/src/win/wkeybd.c
index d85f079..f8ab424 100644
--- a/src/win/wkeybd.c
+++ b/src/win/wkeybd.c
@@ -13,6 +13,9 @@
  *      By Stefan Schimanski, hacked up by Peter Wang and Elias Pschernig.
  *
  *      See readme.txt for copyright information.
+ *
+ ****** CJ CHANGE SIN THIS FILE: Made hw_to_mycode non-static;
+                               changed key_dinput_handle_scancode to ignore windows key on Vista
  */
 
 
@@ -40,12 +43,12 @@
 static HANDLE key_input_event = NULL;
 static HANDLE key_input_processed_event = NULL;
 static LPDIRECTINPUT key_dinput = NULL;
-static LPDIRECTINPUTDEVICE key_dinput_device = NULL;
+LPDIRECTINPUTDEVICE key_dinput_device = NULL;
 
 
 /* lookup table for converting DIK_* scancodes into Allegro KEY_* codes */
 /* this table was from pckeys.c  */
-static const unsigned char hw_to_mycode[256] = {
+const unsigned char hw_to_mycode[256] = {
    /* 0x00 */ 0, KEY_ESC, KEY_1, KEY_2,
    /* 0x04 */ KEY_3, KEY_4, KEY_5, KEY_6,
    /* 0x08 */ KEY_7, KEY_8, KEY_9, KEY_0,
@@ -322,11 +325,26 @@ static void key_dinput_handle_scancode(unsigned char scancode, int pressed)
 {
    HWND allegro_wnd = win_get_window();
    static int ignore_three_finger_flag = FALSE;
+   
+   static BOOL just_pressed_alt = FALSE;
+   if (scancode == DIK_LMENU)
+   {
+     just_pressed_alt = TRUE;
+   }
+   else if (scancode != DIK_TAB)
+   {
+     just_pressed_alt = FALSE;
+   }
+
    /* ignore special Windows keys (alt+tab, alt+space, (ctrl|alt)+esc) */
    if (((scancode == DIK_TAB) && (_key_shifts & KB_ALT_FLAG))
        || ((scancode == DIK_SPACE) && (_key_shifts & KB_ALT_FLAG))
-       || ((scancode == DIK_ESCAPE) && (_key_shifts & (KB_CTRL_FLAG | KB_ALT_FLAG))))
+       || ((scancode == DIK_ESCAPE) && (_key_shifts & (KB_CTRL_FLAG | KB_ALT_FLAG)))
+       || ((scancode == DIK_TAB) && (just_pressed_alt)))
+   {
+     just_pressed_alt = FALSE;
       return;
+   }
 
    /* alt+F4 triggers a WM_CLOSE under Windows */
    if ((scancode == DIK_F4) && (_key_shifts & KB_ALT_FLAG)) {
@@ -676,7 +694,7 @@ static int key_dinput_init(void)
    };
 
    /* Get DirectInput interface */
-   hr = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER, &IID_IDirectInput, &key_dinput);
+   hr = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER, &IID_IDirectInput, (void**)&key_dinput);
    if (FAILED(hr))
       goto Error;
 
@@ -685,7 +703,7 @@ static int key_dinput_init(void)
       goto Error;
 
    /* Create the keyboard device */
-   hr = IDirectInput_CreateDevice(key_dinput, &GUID_SysKeyboard, &key_dinput_device, NULL);
+   hr = IDirectInput_CreateDevice(key_dinput, &GUID_SysKeyboardEm2, &key_dinput_device, NULL);
    if (FAILED(hr))
       goto Error;
 
diff --git a/src/win/wmouse.c b/src/win/wmouse.c
index ff85b73..b3d599d 100644
--- a/src/win/wmouse.c
+++ b/src/win/wmouse.c
@@ -1,6 +1,6 @@
-/*         ______   ___    ___ 
- *        /\  _  \ /\_ \  /\_ \ 
- *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
  *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
  *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
  *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
@@ -82,7 +82,7 @@ HCURSOR _win_hcursor = NULL;	/* Hardware cursor to display */
 #define DINPUT_BUFFERSIZE 256
 static HANDLE mouse_input_event = NULL;
 static LPDIRECTINPUT mouse_dinput = NULL;
-static LPDIRECTINPUTDEVICE mouse_dinput_device = NULL;
+LPDIRECTINPUTDEVICE mouse_dinput_device = NULL;
 
 static int dinput_buttons = 0;
 static int dinput_wheel = FALSE;
@@ -234,7 +234,7 @@ static void mouse_dinput_handle_event(int ofs, int data)
                mag = last_data_x*last_data_x + last_data_y*last_data_y;
                if (mag >= mouse_accel_thr2)
                   data *= (mouse_accel_mult<<1);
-               else if (mag >= mouse_accel_thr1) 
+               else if (mag >= mouse_accel_thr1)
                   data *= mouse_accel_mult;
             }
 
@@ -252,7 +252,7 @@ static void mouse_dinput_handle_event(int ofs, int data)
                mag = last_data_x*last_data_x + last_data_y*last_data_y;
                if (mag >= mouse_accel_thr2)
                   data *= (mouse_accel_mult<<1);
-               else if (mag >= mouse_accel_thr1) 
+               else if (mag >= mouse_accel_thr1)
                   data *= mouse_accel_mult;
             }
 
@@ -606,7 +606,7 @@ static int mouse_dinput_init(void)
    };
 
    /* Get DirectInput interface */
-   hr = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER, &IID_IDirectInput, &mouse_dinput);
+   hr = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER, &IID_IDirectInput, (void**)&mouse_dinput);
    if (FAILED(hr))
       goto Error;
 
@@ -615,7 +615,7 @@ static int mouse_dinput_init(void)
       goto Error;
 
    /* Create the mouse device */
-   hr = IDirectInput_CreateDevice(mouse_dinput, &GUID_SysMouse, &mouse_dinput_device, NULL);
+   hr = IDirectInput_CreateDevice(mouse_dinput, &GUID_SysMouseEm2, &mouse_dinput_device, NULL);
    if (FAILED(hr))
       goto Error;
 
@@ -628,7 +628,7 @@ static int mouse_dinput_init(void)
       goto Error;
 
    /* Check to see if the buttons are swapped (left-hand) */
-   mouse_swap_button = GetSystemMetrics(SM_SWAPBUTTON);   
+   mouse_swap_button = GetSystemMetrics(SM_SWAPBUTTON);
 
    /* Set data format */
    hr = IDirectInputDevice_SetDataFormat(mouse_dinput_device, &c_dfDIMouse);
@@ -802,13 +802,13 @@ static void mouse_directx_enable_hardware_cursor(int mode)
 
 
 /* mouse_directx_select_system_cursor:
- *  Select an OS native cursor 
+ *  Select an OS native cursor
  */
 static int mouse_directx_select_system_cursor (int cursor)
 {
    HCURSOR wc;
    HWND allegro_wnd = win_get_window();
-   
+
    wc = NULL;
    switch(cursor) {
       case MOUSE_CURSOR_ARROW:
@@ -830,6 +830,6 @@ static int mouse_directx_select_system_cursor (int cursor)
    _win_hcursor = wc;
    SetCursor(_win_hcursor);
    PostMessage(allegro_wnd, WM_MOUSEMOVE, 0, 0);
-   
+
    return cursor;
 }
diff --git a/src/win/wsystem.c b/src/win/wsystem.c
index 45008c4..7a34080 100644
--- a/src/win/wsystem.c
+++ b/src/win/wsystem.c
@@ -31,7 +31,7 @@
 #endif
 
 /* DMC requires a DllMain() function, or else the DLL hangs. */
-#ifndef ALLEGRO_STATICLINK
+#if !defined(ALLEGRO_STATICLINK) && defined(ALLEGRO_DMC)
 BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason, LPVOID lpReserved)
 {
    return TRUE;
@@ -491,7 +491,7 @@ int _WinMain(void *_main, void *hInst, void *hPrev, char *Cmd, int nShow)
 
    /* can't use parameter because it doesn't include the executable name */
    cmdline = GetCommandLine();
-   i = strlen(cmdline) + 1;
+   i = (int)strlen(cmdline) + 1;
    argbuf = _AL_MALLOC(i);
    memcpy(argbuf, cmdline, i);
 
diff --git a/src/win/wwnd.c b/src/win/wwnd.c
index fc19076..96d0cdd 100644
--- a/src/win/wwnd.c
+++ b/src/win/wwnd.c
@@ -1,6 +1,6 @@
-/*         ______   ___    ___ 
- *        /\  _  \ /\_ \  /\_ \ 
- *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
  *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
  *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
  *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
@@ -13,6 +13,8 @@
  *      By Stefan Schimanski.
  *
  *      See readme.txt for copyright information.
+ *
+ ****** CJ CHANGES: Made allegro_wnd non-static
  */
 
 
@@ -36,7 +38,7 @@
 
 
 /* general */
-static HWND allegro_wnd = NULL;
+HWND allegro_wnd = NULL;
 char wnd_title[WND_TITLE_SIZE];  /* ASCII string */
 int wnd_x = 0;
 int wnd_y = 0;
@@ -189,7 +191,7 @@ static void exit_window_modules(struct WINDOW_MODULES *wm)
  */
 int wnd_call_proc(int (*proc) (void))
 {
-   return SendMessage(allegro_wnd, msg_call_proc, (DWORD) proc, 0);
+   return SendMessage(allegro_wnd, msg_call_proc, (WPARAM)proc, (LPARAM)0);
 }
 
 
@@ -200,7 +202,7 @@ int wnd_call_proc(int (*proc) (void))
  */
 void wnd_schedule_proc(int (*proc) (void))
 {
-   PostMessage(allegro_wnd, msg_call_proc, (DWORD) proc, 0);
+   PostMessage(allegro_wnd, msg_call_proc, (WPARAM)proc, (LPARAM)0);
 }
 
 
@@ -213,7 +215,7 @@ static LRESULT CALLBACK directx_wnd_proc(HWND wnd, UINT message, WPARAM wparam,
    PAINTSTRUCT ps;
 
    if (message == msg_call_proc)
-      return ((int (*)(void))wparam) ();
+      return ( ( LRESULT(*)( void ) )wparam ) ( );
 
    if (message == msg_suicide) {
       DestroyWindow(wnd);
@@ -224,7 +226,7 @@ static LRESULT CALLBACK directx_wnd_proc(HWND wnd, UINT message, WPARAM wparam,
    if (wnd_msg_pre_proc){
       int retval = 0;
       if (wnd_msg_pre_proc(wnd, message, wparam, lparam, &retval) == 0)
-         return retval;
+         return (LRESULT)retval;
    }
 
    /* See get_reverse_mapping() in wkeybd.c to see what this is for. */
@@ -373,7 +375,7 @@ static LRESULT CALLBACK directx_wnd_proc(HWND wnd, UINT message, WPARAM wparam,
 
       case WM_MENUCHAR :
          return (MNC_CLOSE<<16)|(wparam&0xffff);
-         
+
       case WM_CLOSE:
          if (!user_wnd_proc) {
             if (user_close_proc)
@@ -456,7 +458,7 @@ static HWND create_directx_window(void)
  */
 static void wnd_thread_proc(HANDLE setup_event)
 {
-   int result;
+   DWORD result;
    MSG msg;
 
    _win_thread_init();
@@ -477,7 +479,7 @@ static void wnd_thread_proc(HANDLE setup_event)
    /* message loop */
    while (TRUE) {
       result = MsgWaitForMultipleObjects(_win_input_events, _win_input_event_id, FALSE, INFINITE, QS_ALLINPUT);
-      if ((result >= WAIT_OBJECT_0) && (result < WAIT_OBJECT_0 + _win_input_events)) {
+      if ((result >= WAIT_OBJECT_0) && (result < (int)(WAIT_OBJECT_0 + _win_input_events))) {
          /* one of the registered events is in signaled state */
          (*_win_input_event_handler[result - WAIT_OBJECT_0])();
       }
@@ -523,7 +525,7 @@ int init_directx_window(void)
       _win_input_init(TRUE);
 
       /* hook the user window */
-      user_wnd_proc = (WNDPROC) SetWindowLong(user_wnd, GWL_WNDPROC, (long)directx_wnd_proc);
+      user_wnd_proc = (WNDPROC) SetWindowLongPtr(user_wnd, GWLP_WNDPROC, (LONG_PTR)directx_wnd_proc);
       if (!user_wnd_proc)
          return -1;
 
@@ -557,7 +559,7 @@ int init_directx_window(void)
 
 	 default:               /* thread failed to create window */
 	    return -1;
-      } 
+      }
    }
 
    /* initialize gfx critical section */
@@ -579,7 +581,7 @@ void exit_directx_window(void)
 {
    if (user_wnd) {
       /* restore old window proc */
-      SetWindowLong(user_wnd, GWL_WNDPROC, (long)user_wnd_proc);
+      SetWindowLongPtr(user_wnd, GWLP_WNDPROC, (LONG_PTR)user_wnd_proc);
       user_wnd_proc = NULL;
       user_wnd = NULL;
       allegro_wnd = NULL;
@@ -598,7 +600,7 @@ void exit_directx_window(void)
    DeleteCriticalSection(&gfx_crit_sect);
 
    _win_input_exit();
-   
+
    window_is_initialized = FALSE;
 }
 
@@ -651,11 +653,11 @@ int adjust_window(int w, int h)
          }
          if (!user32_handle || !get_title_bar_info)
             tb_height = GetSystemMetrics(SM_CYSIZE);
-         
+
 	 /* try to center the window relative to its last position */
 	 last_wnd_x += (last_w - w)/2;
 	 last_wnd_y += (last_h - h)/2;
-	 
+
 	 if (last_wnd_x + w >= working_area.right)
 	    last_wnd_x = working_area.right - w;
 	 if (last_wnd_y + h >= working_area.bottom)
@@ -680,7 +682,7 @@ int adjust_window(int w, int h)
 
       /* retrieve the size of the decorated window */
       AdjustWindowRect(&win_size, GetWindowLong(allegro_wnd, GWL_STYLE), FALSE);
-   
+
       /* display the window */
       MoveWindow(allegro_wnd, win_size.left, win_size.top,
                  win_size.right - win_size.left, win_size.bottom - win_size.top, TRUE);
@@ -702,7 +704,7 @@ int adjust_window(int w, int h)
 
 
 /* save_window_pos:
- *  Stores the position of the current window before closing it so that 
+ *  Stores the position of the current window before closing it so that
  *  it can be used as the initial position for the next window.
  */
 void save_window_pos(void)
@@ -746,7 +748,7 @@ void win_set_window(HWND wnd)
       init_directx_window();
       init_window_modules(&wm);
    }
-   
+
    window_is_initialized = TRUE;
 }
 
diff --git a/src/x/xdga2.c b/src/x/xdga2.c
index 0199d49..abf087a 100644
--- a/src/x/xdga2.c
+++ b/src/x/xdga2.c
@@ -23,7 +23,7 @@
 #if (defined ALLEGRO_XWINDOWS_WITH_XF86DGA2) && ((!defined ALLEGRO_WITH_MODULES) || (defined ALLEGRO_MODULE))
 
 #include <X11/Xlib.h>
-#include <X11/extensions/xf86dga.h>
+#include <X11/extensions/Xxf86dga.h>
 
 
 #define RESYNC()     XDGASync(_xwin.display, _xwin.screen);
diff --git a/tests/play.c b/tests/play.c
index c282302..4885223 100644
--- a/tests/play.c
+++ b/tests/play.c
@@ -74,7 +74,7 @@ void usage(void)
 
    strcat(msg, "\nIf you don't specify the card, Allegro will auto-detect (ie. guess :-)\n");
 
-   allegro_message(msg);
+   allegro_message("%s", msg);
    free(msg);
 }
 
diff --git a/tools/pack.c b/tools/pack.c
index 0941853..58d7f17 100644
--- a/tools/pack.c
+++ b/tools/pack.c
@@ -42,7 +42,7 @@ static void err(char *s1, char *s2)
       printf(": %s", s1);
 
    if (s2)
-      printf(s2);
+      printf("%s", s2);
 
    printf("\n");
 
diff --git a/tools/textconv.c b/tools/textconv.c
index 499536b..4f44d3c 100644
--- a/tools/textconv.c
+++ b/tools/textconv.c
@@ -62,8 +62,8 @@ void usage(void)
    printf("\ta - 8 bit ASCII (Latin-1 codepage)\n");
    printf("\tb - 7 bit bare ASCII or codepage loaded via -f\n");
    printf("\tu - UTF-8 encoding\n");
-   printf("\tw - 16 bit Unicode (current machine endianess)\n");
-   printf("\tW - 16 bit Unicode (flip endianess)\n");
+   printf("\tw - 16 bit Unicode (current machine endianness)\n");
+   printf("\tW - 16 bit Unicode (flip endianness)\n");
    printf("\n");
    printf("Option flags:\n");
    printf("\t-f{file} = load alternate codepage file\n");
@@ -71,7 +71,7 @@ void usage(void)
    printf("\t-h = output data in hex format (default is binary)\n");
    printf("\t-d = output line breaks in DOS (CR/LF) format\n");
    printf("\t-u = output line breaks in Unix (LF) format\n");
-   printf("\t-w = add an endianess watermark to Unicode output files\n");
+   printf("\t-w = add an endianness watermark to Unicode output files\n");
    printf("\t-v = verbose output\n");
    printf("\n");
    printf("If filenames are not specified, stdin and stdout will be used\n");
@@ -99,12 +99,12 @@ UTYPE_INFO *get_format_info(int type, char **desc, int *flip)
 	 return _find_utype(U_UTF8);
 
       case 'w': 
-	 *desc = "Unicode (default endianess)";
+	 *desc = "Unicode (default endianness)";
 	 *flip = FALSE;
 	 return _find_utype(U_UNICODE);
 
       case 'W': 
-	 *desc = "Unicode (flip endianess)";
+	 *desc = "Unicode (flip endianness)";
 	 *flip = TRUE;
 	 return _find_utype(U_UNICODE);
    }
@@ -430,7 +430,7 @@ int main(int argc, char *argv[])
 
    if (flag_watermark) {
       if (flag_verbose)
-	 printf("Adding Unicode endianess watermark\n");
+	 printf("Adding Unicode endianness watermark\n");
       write_output(out_file, 0xFEFF);
    }
 
@@ -452,13 +452,13 @@ int main(int argc, char *argv[])
 
 	 case 0xFEFF:
 	    if (flag_verbose)
-	       printf("Endianess watermark ok\n");
+	       printf("Endianness watermark ok\n");
 	    was_cr = FALSE;
 	    continue;
 
 	 case 0xFFFE:
 	    if (flag_verbose)
-	       printf("Bad endianess watermark! Toggling input format...\n");
+	       printf("Bad endianness watermark! Toggling input format...\n");
 	    in_flip = !in_flip;
 	    was_cr = FALSE;
 	    continue;
